- [总结](#总结)
- [对一个整数m删除n位数后，顺序不变，输出最大值](#对一个整数m删除n位数后顺序不变输出最大值)
- [8 字符串转整数](#8-字符串转整数)
- [9 数字是回环数字](#9-数字是回环数字)
- [10. 正则表达式匹配](#10-正则表达式匹配)
- [13 Roman to Integer(中)](#13-roman-to-integer中)
- [14 返回最长公共字符串前缀](#14-返回最长公共字符串前缀)
- [20 括号开闭校验](#20-括号开闭校验)
- [21 合并两个有序列表](#21-合并两个有序列表)
- [11 最大水量(中)](#11-最大水量中)
- [12 Intege to Roman (中)](#12-intege-to-roman-中)
- [15 Three Sum(中)](#15-three-sum中)
- [16 最接近目标值的三数之和](#16-最接近目标值的三数之和)
- [17 电话号码的字母组合](#17-电话号码的字母组合)
- [18 四数之和](#18-四数之和)
- [19 从List结尾移除第N项节点](#19-从list结尾移除第n项节点)
- [20 括号的可能组合](#20-括号的可能组合)
- [23 合并多个有序链表](#23-合并多个有序链表)
- [24 两两交换链表中的节点](#24-两两交换链表中的节点)
- [25 K 个一组翻转链表](#25-k-个一组翻转链表)
- [26 删除有序数组中的重复项](#26-删除有序数组中的重复项)
- [27 移除指定值元素](#27-移除指定值元素)
- [28 Find the Index of the First Occurrence in a String](#28-find-the-index-of-the-first-occurrence-in-a-string)
- [29 Divide Two Integers](#29-divide-two-integers)
- [30 Substring with Concatenation of All Words](#30-substring-with-concatenation-of-all-words)
- [31. 下一个排列](#31-下一个排列)
- [32 最长有效圆括号](#32-最长有效圆括号)
- [33 搜索旋转排序数组](#33-搜索旋转排序数组)
- [34 在排序数组中查找元素的第一个和最后一个位置](#34-在排序数组中查找元素的第一个和最后一个位置)
- [35 在排序数组中查找插入位置(Easy)](#35-在排序数组中查找插入位置easy)
- [36 有效的数独(中)](#36-有效的数独中)
- [37 解数独(难)](#37-解数独难)
- [38 报数序列(中)](#38-报数序列中)
- [39 组合总和(中)](#39-组合总和中)
- [40 组合总和 II(中)](#40-组合总和-ii中)
- [41 缺失的第一个正数(难)](#41-缺失的第一个正数难)
- [42. Trapping Rain Water(困难)](#42-trapping-rain-water困难)
- [43. Multiply Strings(中等)](#43-multiply-strings中等)
- [44. Wildcard Matching(困难)](#44-wildcard-matching困难)
- [45. Jump Game II(中等)](#45-jump-game-ii中等)
- [46. Permutations(中等)](#46-permutations中等)
- [47. Permutations II(中等)](#47-permutations-ii中等)
- [48. Rotate Image(中等)](#48-rotate-image中等)
- [49. Group Anagrams(中等)](#49-group-anagrams中等)
- [50. Pow(x, n)(中等)](#50-powx-n中等)
- [51. N-Queens(困难)](#51-n-queens困难)
- [52. N-Queens II(中等)](#52-n-queens-ii中等)
- [53. Maximum Subarray(简单)](#53-maximum-subarray简单)
- [54. Spiral Matrix(中等)](#54-spiral-matrix中等)
- [55. Jump Game(中等)](#55-jump-game中等)
- [56. Merge Intervals(中等)](#56-merge-intervals中等)
- [57. Insert Interval(中等)](#57-insert-interval中等)
- [58. Length of Last Word(简单)](#58-length-of-last-word简单)
- [59. Spiral Matrix II(中等)](#59-spiral-matrix-ii中等)
- [60. Permutation Sequence(中等)](#60-permutation-sequence中等)
- [61. Rotate List(中等)](#61-rotate-list中等)
- [62. Unique Paths(中等)](#62-unique-paths中等)
- [63. Unique Paths II(中等)](#63-unique-paths-ii中等)
- [64. Minimum Path Sum(中等)](#64-minimum-path-sum中等)
- [65. Valid Number(中等)](#65-valid-number中等)
- [66. Plus One(简单)](#66-plus-one简单)
- [67. Add Binary(简单)](#67-add-binary简单)
- [68. Text Justification(中等)](#68-text-justification中等)
- [69. Sqrt(x)(简单)](#69-sqrtx简单)
- [70. Climbing Stairs(简单)](#70-climbing-stairs简单)
- [71. Simplify Path(中等)](#71-simplify-path中等)
- [72. Edit Distance(困难)](#72-edit-distance困难)
- [73. Set Matrix Zeroes(中等)](#73-set-matrix-zeroes中等)
- [74. Search a 2D Matrix(中等)](#74-search-a-2d-matrix中等)
- [75. Sort Colors(中等)](#75-sort-colors中等)
- [76. Minimum Window Substring(困难)](#76-minimum-window-substring困难)
- [77. Combinations(中等)](#77-combinations中等)
- [78. Subsets(中等)](#78-subsets中等)
- [79. Word Search(中等)](#79-word-search中等)
- [80. Remove Duplicates from Sorted Array II(中等)](#80-remove-duplicates-from-sorted-array-ii中等)
- [81. Search in Rotated Sorted Array II(中等)](#81-search-in-rotated-sorted-array-ii中等)
- [82. Remove Duplicates from Sorted List II(中等)](#82-remove-duplicates-from-sorted-list-ii中等)
- [83. Remove Duplicates from Sorted List(简单)](#83-remove-duplicates-from-sorted-list简单)
- [84. Largest Rectangle in Histogram(困难)](#84-largest-rectangle-in-histogram困难)
- [85. Maximal Rectangle(困难)](#85-maximal-rectangle困难)
- [86. Partition List(中等)](#86-partition-list中等)
- [87. Scramble String(困难)](#87-scramble-string困难)
- [88. Merge Sorted Array(简单)](#88-merge-sorted-array简单)
- [94. Binary Tree Inorder Traversal(简单)](#94-binary-tree-inorder-traversal简单)
- [100. Same Tree(简单)](#100-same-tree简单)
- [101. Symmetric Tree(简单)](#101-symmetric-tree简单)
- [104. Maximum Depth of Binary Tree(简单)](#104-maximum-depth-of-binary-tree简单)
- [108. Convert Sorted Array to Binary Search Tree(简单)](#108-convert-sorted-array-to-binary-search-tree简单)
- [110. Balanced Binary Tree(简单)](#110-balanced-binary-tree简单)
- [111. Minimum Depth of Binary Tree(简单)](#111-minimum-depth-of-binary-tree简单)
- [112. Path Sum(简单)](#112-path-sum简单)
- [118. Pascal's Triangle(简单,帕斯卡三角形)](#118-pascals-triangle简单帕斯卡三角形)
- [119. Pascal's Triangle II(简单,帕斯卡三角形)](#119-pascals-triangle-ii简单帕斯卡三角形)
- [121. Best Time to Buy and Sell Stock(简单)](#121-best-time-to-buy-and-sell-stock简单)
- [125. Valid Palindrome(简单)](#125-valid-palindrome简单)
- [136. Single Number(简单)](#136-single-number简单)
- [141. Linked List Cycle(简单)](#141-linked-list-cycle简单)
- [144. Binary Tree Preorder Traversal(简单)](#144-binary-tree-preorder-traversal简单)
- [145. Binary Tree Postorder Traversal(简单)](#145-binary-tree-postorder-traversal简单)
- [157. Read N Characters Given Read4(中等)](#157-read-n-characters-given-read4中等)
- [160. Intersection of Two Linked Lists(简单)](#160-intersection-of-two-linked-lists简单)
- [163. Missing Ranges(中等)](#163-missing-ranges中等)
- [168. Excel Sheet Column Title(简单)](#168-excel-sheet-column-title简单)
- [169. Majority Element(简单)](#169-majority-element简单)
- [170. Two Sum III - Data Structure Design(简单)](#170-two-sum-iii---data-structure-design简单)
- [171. Excel Sheet Column Number(简单)](#171-excel-sheet-column-number简单)
- [175. Combine Two Tables(简单)](#175-combine-two-tables简单)
- [181. Employees Earning More Than Their Managers(简单)](#181-employees-earning-more-than-their-managers简单)
- [182. Duplicate Emails(简单)](#182-duplicate-emails简单)
- [183. Customers Who Never Order(简单)](#183-customers-who-never-order简单)
- [190. Reverse Bits(简单)](#190-reverse-bits简单)
- [191. Number of 1 Bits(简单)](#191-number-of-1-bits简单)
- [193. Valid Phone Numbers(简单)](#193-valid-phone-numbers简单)
- [195. Tenth Line(简单)](#195-tenth-line简单)
- [196. Delete Duplicate Emails(简单)](#196-delete-duplicate-emails简单)
- [197. Rising Temperature(简单)](#197-rising-temperature简单)
- [202. Happy Number(简单)](#202-happy-number简单)
- [203. Remove Linked List Elements(简单)](#203-remove-linked-list-elements简单)
- [205. Isomorphic Strings(简单)](#205-isomorphic-strings简单)
- [206. Reverse Linked List(简单)](#206-reverse-linked-list简单)
- [217. Contains Duplicate(简单)](#217-contains-duplicate简单)
- [219. Contains Duplicate II(简单)](#219-contains-duplicate-ii简单)
- [222. Count Complete Tree Nodes(中等)](#222-count-complete-tree-nodes中等)
- [225. Implement Stack using Queues(简单)](#225-implement-stack-using-queues简单)
- [226. Invert Binary Tree(简单)](#226-invert-binary-tree简单)
- [228. Summary Ranges(简单)](#228-summary-ranges简单)
- [231. Power of Two(简单)](#231-power-of-two简单)
- [232. Implement Queue using Stacks(简单)](#232-implement-queue-using-stacks简单)
- [234. Palindrome Linked List(简单)](#234-palindrome-linked-list简单)
- [242. Valid Anagram(简单)](#242-valid-anagram简单)
- [326. Power of Three(简单)](#326-power-of-three简单)
- [342. Power of Four(简单)](#342-power-of-four简单)
- [498. Diagonal Traverse(中等)](#498-diagonal-traverse中等)
- [679. 24 Game(困难)](#679-24-game困难)
- [808. Soup Servings(中等)](#808-soup-servings中等)
- [837. New 21 Game(中等)](#837-new-21-game中等)
- [869. Reordered Power of 2(中等)](#869-reordered-power-of-2中等)
- [898. Bitwise ORs of Subarrays(中等)](#898-bitwise-ors-of-subarrays中等)
- [904. Fruit Into Baskets(中等)](#904-fruit-into-baskets中等)
- [1277. Count Square Submatrices with All Ones(中等)](#1277-count-square-submatrices-with-all-ones中等)
- [1304. Find N Unique Integers Sum up to Zero(简单)](#1304-find-n-unique-integers-sum-up-to-zero简单)
- [1317. Convert Integer to the Sum of Two No-Zero Integers(简单)](#1317-convert-integer-to-the-sum-of-two-no-zero-integers简单)
- [1323. Maximum 69 Number(简单)](#1323-maximum-69-number简单)
- [1493. Longest Subarray of 1's After Deleting One Element(中等)](#1493-longest-subarray-of-1s-after-deleting-one-element中等)
- [1504. Count Submatrices With All Ones(中等)](#1504-count-submatrices-with-all-ones中等)
- [1717. Maximum Score From Removing Substrings(中等)](#1717-maximum-score-from-removing-substrings中等)
- [1733. Minimum Number of People to Teach(中等)](#1733-minimum-number-of-people-to-teach中等)
- [1792. Maximum Average Pass Ratio(中等)](#1792-maximum-average-pass-ratio中等)
- [2044. Count Number of Maximum Bitwise OR Subsets(中等)](#2044-count-number-of-maximum-bitwise-or-subsets中等)
- [2106. Maximum Fruits Harvested After at Most K Steps(困难)](#2106-maximum-fruits-harvested-after-at-most-k-steps困难)
- [2210. Count Hills and Valleys in an Array(简单)](#2210-count-hills-and-valleys-in-an-array简单)
- [2264. Largest 3-Same-Digit Number in String(简单)](#2264-largest-3-same-digit-number-in-string简单)
- [2322. Minimum Score After Removals on a Tree(困难)](#2322-minimum-score-after-removals-on-a-tree困难)
- [2327. Number of People Aware of a Secret(中等)](#2327-number-of-people-aware-of-a-secret中等)
- [2348. Number of Zero-Filled Subarrays(中等)](#2348-number-of-zero-filled-subarrays中等)
- [2411. Smallest Subarrays With Maximum Bitwise OR(中等)](#2411-smallest-subarrays-with-maximum-bitwise-or中等)
- [2419. Longest Subarray With Maximum Bitwise AND(中等)](#2419-longest-subarray-with-maximum-bitwise-and中等)
- [2749. Minimum operations to Make the Integer Zero(中等)](#2749-minimum-operations-to-make-the-integer-zero中等)
- [2785. Sort Vowels in a String(中等)](#2785-sort-vowels-in-a-string中等)
- [2787. Ways to Express an Integer as Sum of Powers(中等)](#2787-ways-to-express-an-integer-as-sum-of-powers中等)
- [3000. Maximum Area of Longest Diagonal Rectangle(简单)](#3000-maximum-area-of-longest-diagonal-rectangle简单)
- [3021. Alice and Bob Playing Flower Games(中等)](#3021-alice-and-bob-playing-flower-games中等)
- [3025. Find the Number of Ways to Place People I(中等)](#3025-find-the-number-of-ways-to-place-people-i中等)
- [3027. Find the Number of Ways to Place People II(困难)](#3027-find-the-number-of-ways-to-place-people-ii困难)
- [3195. Find the Minimum Area to Cover All Ones I(中等)](#3195-find-the-minimum-area-to-cover-all-ones-i中等)
- [3197. Find the Minimum Area to Cover All Ones II(困难)](#3197-find-the-minimum-area-to-cover-all-ones-ii困难)
- [3227. Vowels Game in a String(中等)](#3227-vowels-game-in-a-string中等)
- [3330. Find the Original Typed String I(简单)](#3330-find-the-original-typed-string-i简单)
- [3363. Find the Maximum Number of Fruits Collected(困难)](#3363-find-the-maximum-number-of-fruits-collected困难)
- [3446. Sort Matrix by Diagonals(中等)](#3446-sort-matrix-by-diagonals中等)
- [3459. Length of Longest V-Shaped Diagonal Segment(困难)](#3459-length-of-longest-v-shaped-diagonal-segment困难)
- [3477. Fruits into Baskets II(简单)](#3477-fruits-into-baskets-ii简单)
- [3479. Fruits into Baskets III(简单)](#3479-fruits-into-baskets-iii简单)
- [3487. Maximum Unique Subarray Sum After Deletion(简单)](#3487-maximum-unique-subarray-sum-after-deletion简单)
- [3495. Minimum Operations to Make Array Elements zero(困难)](#3495-minimum-operations-to-make-array-elements-zero困难)
- [3516. Find Closest Person(简单)](#3516-find-closest-person简单)
- [3541. Find Most Frequency Vowel and Consonant(简单)](#3541-find-most-frequency-vowel-and-consonant简单)


# 总结
* 算法方法：二分法、双指针、滑动窗口、BFS、DFS、并查集、位运算、数学、字符串、数组、链表、树、图、堆、栈、队列、哈希表、排序、搜索
* 算法思想：分治，贪心，回溯，动态规划，分支有界
  * **使用动态规划时避免重复计算问题**
* 算法应用：排序、查找、字符串处理、数组处理、链表处理、树处理、图处理、堆处理、栈处理、队列处理、哈希表处理
* 运算符
  * 位运算
    * `&`：与运算，最大的肯定是最大`&`单只值,结果不大于最小值
    * `|`：或运算
* 字符操作
  * 使用char对比
  * 将char转int对比
  * 字符串数字相乘：使用数组存储同位积
* 数字操作
  * 使用位运算
  * 注意数据类型范围限制
  * 是否是一个数的幂次结果：若余数为0，重置为除该数，直到非余数，判断结果是否为1
* 语言环境
  * java语言，可以使用`static`调用方法：
    * 热点代码，JIT编译器会将其编译为本地机器码，大幅提升执行速度，
    * 使用`static`调用，制造**人为触发JIT编译**，一般需要一定次数(如500)
    * 在**LeetCode的评测系统**中:每个测试用例可能运行在独立的JVM实例中（或运行时状态被重置）
* Leetcode加速
  * 数据类型尽可能选最小的
  * (java)使用`static`调用方法，制造人为触发**JIT编译**
  * 将数据处理放在读取时，例如自定义实现`AbstractList`

# 对一个整数m删除n位数后，顺序不变，输出最大值
* 题目说明：给定任意一个数字 m，然后给出数字 n，则需在 m 中去掉 n 位数，保持各位顺序不变的情况下，得到最大数。
* 输入描述：输入整数m,n.(1<=m<=1e100,1<=n<=100)
* 输出描述：输出删除后的最大数。
* 示例：输入1234 2，输出34

```java
import java.util.ArrayList;
import java.util.Scanner;

class Main {
    // 本实例支持正负整数处理
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        String str_0 = scan.nextLine();
        String[] line_list_0 = str_0.trim().split(" ");
        ArrayList<Integer> arr = new ArrayList<>();
        for (String s : line_list_0) {
            arr.add(Integer.parseInt(s));
        }
        scan.close();
        int result = solution(arr);
        System.out.println(result);
    }

    public static int solution(ArrayList<Integer> arr) {
        int result = 0;

        // TODO: 请在此编写代码
        // 获取m，n
        if (arr == null || arr.size() == 0) {
            return result;
        }
        Integer m = arr.get(0);
        Integer n = arr.size() > 1 ? arr.get(1) : null;
        // 验证m，n有效性
        if (m == null || n == null || m == 0) {
            return result;
        }
        if (n <= 0) {
            return m;
        }
        // 判断正负
        boolean flag = true;
        if (m < 0) {
            flag = false;
            m = -m;
        }
        // 比较最大位数
        int max_num = (int) Math.pow(10, (n - 1));
        if (m <= max_num) {
            return result;
        }
        // 整数m转数组
        String ms = String.valueOf(m);
        Integer[] mss = new Integer[ms.length()];
        for (int i = 0; i < ms.length(); i++) {
            mss[i] = Integer.parseInt(Character.toString(ms.charAt(i)));
        }

        // 循环n次，每次处理一个最大或最小值
        solution(mss,n,flag);

        // 合并非null内容为整数
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < mss.length; i++) {
            if (mss[i] != null) {
                sb.append(mss[i]);
            }
        }
        result = Integer.parseInt(sb.toString());
        // 根据正负处理最终结果
        if (!flag) {
            result = -result;
        }
        return result;
    }
    // 
    public static void solution(Integer[] mss,int n,boolean flag){
        for (int i = 0; i < n; i++) {
            int index = 0;
            Integer tmp = mss[0];
            for (int j = 1; j < mss.length; j++) {
                // 过滤无效对比
                if (tmp == null) {
                    tmp = mss[j];
                    index = j;
                    continue;
                }
                if (mss[j] == null) {
                    continue;
                }
                if (flag) { // 正数筛选最小值
                    if (tmp > mss[j]) {
                        tmp = mss[j];
                        index = j;
                    }
                } else { // 负数筛选理最大值
                    if (tmp < mss[j]) {
                        tmp = mss[j];
                        index = j;
                    }
                }
            }
            // 处理最值为null
            if (tmp != null) {
                mss[index] = null;
            }
        }
    }
}
```

# 8 字符串转整数
    * 读入字符串并丢弃无用的前导空格
    * 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
    * 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
    * 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
    * 如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数* 应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。
    * 返回整数作为最终结果。

注意：
* 本题中的空白字符只包括空格字符 ' ' 。
* 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。

示例：
* "42" => 42
* "   -42" => -42
* "-54654685465" => -27483648
* "564654564654" => 27483647
* "a 987" => 0
* "" => 0
* "-5-" => -5
* "+-5" => 0
```java
class Solution {
    public int myAtoi(String str) {
        // if(str == null) return 0;
        str = str.trim();
        // 去空后为空输出0
        if (str.length() == 0) return 0;
        int num = 0,i = 0,digit = 0;boolean isF = false;
        char ch = str.charAt(i);
        // 判断首位正负
        if (ch == 43){ // ch == '+'
            i++;
        }else if (ch==45){ // ch == '-'
            isF = true;
            i++;
        }
        
        for (; i < str.length(); i++) {
            ch = str.charAt(i);
            if (47 < ch && ch < 58){ // if(Character.isDigit(ch))
                digit = Character.getNumericValue(ch);
                if (num > (Integer.MAX_VALUE - digit) / 10){
                    return isF ? Integer.MIN_VALUE : Integer.MAX_VALUE;
                }
                num = num * 10 + digit;
            }else{
                break;
            }
        }
        return isF ? -num:num;
    }
}
```

# 9 数字是回环数字
* int整数数字对称
* 负数非回环
```java
// 初版：通过字符串索引前后对比实现
class Solution {
    public boolean isPalindrome(int x) {
        if (x == 0) return true;
        if (x < 0 || x%10==0) return false;
        
        String str = String.valueOf(x);
        int lo = 0, hi = str.length()-1;
        while (lo < hi) {
            if (str.charAt(lo++) != str.charAt(hi--))
                return false;
        }
        return true;
    }
}

// 学习版：通过余数反转对比实现
class Solution {
    public boolean isPalindrome(int x) {
        if (x<0 || (x!=0 && x%10==0)) return false;
        int rev = 0;
        while (x>rev){
            rev = rev*10 + x%10; // 相当于复制左半部分
            x = x/10;
        }
        return (x==rev || x==rev/10);
    }
}
```

# 10. 正则表达式匹配
Given an input string s and a pattern p, implement regular expression matching with support for `.` and `*` where:
```markdown
`.` Matches any single character.​​​​
`*` Matches zero or more of the preceding element.
```
The matching should cover the entire input string (not partial).


* 约束
  * `1 <= s.length <= 20`
  * `1 <= p.length <= 20`
  * `s` contains only lowercase English letters.
  * `p` contains only lowercase English letters, `.`, and `*`.
  * It is guaranteed for each appearance of the character `*`, there will be a previous valid character to match.
* **思路**：从后向前匹配
  *  遇到`*` 正则向前2步，因至少`*`前一个是匹配的
  *  遇到`.` 内容向前1步
  *  都走完，则匹配成功
  *  正则走完，则失败
  *  内容走完，单正则非`*`，则失败
```java
public boolean isMatch(String s, String p) {
    return checkMatch(s, p, p.length() - 1, s.length() - 1);
}

public boolean checkMatch(String s, String p, int pe, int se) { // 右侧开始匹配，从后向前匹配
    if (pe < 0 && se < 0) {
        return true;
    } else if (se < 0 && pe >= 0) {
        if (p.charAt(pe) == '*') {
            return checkMatch(s, p, pe - 2, se);
        } else {
            return false;
        }
    } else if (pe < 0) {
        return false;
    }

    if (p.charAt(pe) == '*') {
        if (p.charAt(pe - 1) == s.charAt(se) || p.charAt(pe - 1) == '.') {
            return checkMatch(s, p, pe, se - 1) || checkMatch(s, p, pe - 2, se);
        } else {
            return checkMatch(s, p, pe - 2, se);
        }
    } else if (p.charAt(pe) == s.charAt(se) || p.charAt(pe) == '.') {
        return checkMatch(s, p, pe - 1, se - 1);
    } else {
        return false;
    }
}
```

# 13 Roman to Integer(中)
    Roman numerals are usually written largest to smallest from left to right.
    I can be placed before V (5) and X (10) to make 4 and 9. 
    X can be placed before L (50) and C (100) to make 40 and 90. 
    C can be placed before D (500) and M (1000) to make 400 and 900.
```py
# 45ms 86.56% 16.4MB 39.26%
class Solution:
    def romanToInt(self, s: str) -> int:
        sm = {"I":1,"V":5,"X":10,"L":50,"C":100,"D":500,"M":1000}
        sum = 0
        pre = ""
        num=0
        for i in s:
            if pre == "I" and (i == "V" or i=="X"):
                sum = sum - num
                num = sm[i] -1
            elif pre == "X" and (i == "L" or i=="C"):
                sum = sum - num
                num = sm[i] -10
            elif pre == "C" and (i == "D" or i=="M"):
                sum = sum - num
                num = sm[i] -100
            else:
                num = sm[i]
            sum = sum + num
            pre = i
        return sum
```
```py
# 52ms 55.28% 16.4MB 39.26%
class Solution:
    def romanToInt(self, s: str) -> int:
        romans = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000,'CD':400,'CM':900,'XC':90,'XL':40,'IX':9,'IV':4}
        roman = 0
        pre = 0
        for i in s:
            if pre == 0:
                pre = romans[i]
                continue
            if pre < romans[i]:
                roman += romans[i] - pre
                pre = 0
            else:
                roman += pre
                pre = romans[i]
            print( i,pre,roman)
        if pre != 0:
            roman += pre
        return roman
```
```py
# 58ms 25.26% 16.1MB 93.92%
class Solution:
    def romanToInt(self, s: str) -> int:
        romans = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}
        roman = 0
        for i in range(len(s)):
            if i < len(s) -1 and romans[s[i]] < romans[s[i+1]]:
                roman -= romans[s[i]]
            else:
                roman += romans[s[i]]
        return roman
```

# 14 返回最长公共字符串前缀
    Write a function to find the longest common prefix string amongst an array of strings.
    If there is no common prefix, return an empty string "".
* 个人版
```java
public String longestCommonPrefix(String[] strs){
    if (strs == null || strs.length == 0) return "";
    if (strs.length == 1 && strs[0]!=null) return strs[0];
    StringBuilder sb = new StringBuilder();
    int len = 0;boolean cur=true;
    all: while(true){
        char c = 0;
        boolean cur_first=true;
        for (String str : strs) {
            if (str == null || len == str.length() || !cur)
                break all;
            if (cur_first) {
                c = str.charAt(len);
                cur_first = false;
            }
            cur = c == str.charAt(len);
        }
        if (cur){
            sb.append(c);
            len++;
        }else {
            break;
        }
    }
    return sb.toString();
}
```
* 官方最优解法
  * 先选一个前缀，用前缀与其它比较
  * 使用indexOf方法判断是否存在，不存在减一位继续
  * 不足：未判空，并且前缀缩减至空时应终止程序
```java
public String longestCommonPrefix(String[] strs){
    String prefix=strs[0];
    for (int i = 1; i < strs.length; i++) {
        while (strs[i].indexOf(prefix)!=0)
            prefix = prefix.substring(0,prefix.length()-1);
    }
    return prefix;
}
```
* 修订版
```java
public String longestCommonPrefix(String[] strs){
    // 预处理
    if (strs == null || strs.length == 0) return "";
    if (strs.length == 1 && strs[0]!=null) return strs[0];
    String prefix=strs[0];
    for (int i = 1; i < strs.length; i++) {
        if(strs[i]==null || strs[i].equals("")) return ""; // 判空
        while (strs[i].indexOf(prefix)!=0)
            prefix = prefix.substring(0,prefix.length()-1);
            if(prefix.equals("")) return "";//防止缩减至空
    }
    return prefix;
}
```

# 20 括号开闭校验
    Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

    An input string is valid if:
     Open brackets must be closed by the same type of brackets.
     Open brackets must be closed in the correct order.
     Every close bracket has a corresponding open bracket of the same type.

* 算法逻辑：
  * 开括号入栈，比括号同类型出栈
* 初版
  * 代码较多，但简单易懂
  * 使用了java源码的Stack类，对象比较大
```java
public static boolean isValid(String s){
    Stack<Integer> stack = new Stack<>();
    boolean flag = true;
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (c == '(') {
            stack.push(1);
        }
        if (c == ')') {
            if (stack.isEmpty() || stack.pop()!=1) {
                return false;
            }
        }
        if (c == '[') {
            stack.push(2);
        }
        if (c == ']') {
            if (stack.isEmpty() || stack.pop()!=2) {
                return false;
            }
        }
        if (c == '{') {
            stack.push(3);
        }
        if (c == '}') {
            if (stack.isEmpty() || stack.pop()!=3) {
                return false;
            }
        }
    }
    return flag && stack.isEmpty();
}
```
* 优解
  * 代码简洁，但可读性较差
  * 逻辑：开括号入栈，比括号同类型出栈
```java
public boolean isValid(String s) {
    int i=-1;
    char[] stack=new char[s.length()];

    for(char ch:s.toCharArray())
    {
        if(ch=='[' ||ch=='{' ||ch=='('){
            stack[++i]=ch;
        }
        else{
            if(i>=0 && ((stack[i]=='{' && ch=='}') ||
                        (stack[i]=='[' && ch==']') ||
                        (stack[i]=='(' && ch==')')))
                --i;
            else
                return false;
        }
    }
    return i==-1;
}
```
* 修订出版
```java
public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    Character pre;
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (c == '(' || c == '[' || c == '{') {
            stack.push(c);
        }
        else{
            if (stack.isEmpty()) {
                return false;
            }
            pre = stack.pop();
            if ((c==')' && pre!='(')||(c==']' && pre!='[')||(c=='}' && pre!='{')) {
                return false;
            }
        }
    }
    return stack.isEmpty();
}
```
# 21 合并两个有序列表
    You are given the heads of two sorted linked lists list1 and list2.

    Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

    Return the head of the merged linked list.
```java
public static class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```
* 个人实践
  * 基础实践
  * 代码繁琐，局部变量定义较多
```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    ListNode list=null,next = null,node;
    while(true){
        if(list1 == null || list2 == null) {
            if(list == null){
                list = list1 ==null?list2:list1;
            }else{
                next.next = list1 ==null?list2:list1;
            }
            break;
        }

        if(list2.val > list1.val){
            node = list1;
            list1 = list1.next;
        }else{
            node = list2;
            list2 = list2.next;
        }		
        node.next = null;
        if(list==null){
            list =next =  node;
        }else{
            next.next = node;
            next = node;
        }
    }
    return list;
}
```
```java
// 个人版修订，但不推荐
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    ListNode list=new ListNode(-101),next = list;
    while(true){
        if(list1 == null || list2 == null) {
            next.next = list1 ==null?list2:list1;
            break;
        }

        if(list2.val > list1.val){
            next.next = list1;
            list1 = list1.next;
        }else{
            next.next = list2;
            list2 = list2.next;
        }
        next = next.next;
    }
    return list.next;
}
```
* 最优解
  * 代码少，使用递归逻辑实现，无局部变量
```java
public static ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    if (list1 == null) return list2;
    if (list2 == null) return list1;
    if (list1.val < list2.val) {
        list1.next = mergeTwoLists(list1.next, list2);
        return list1;
    }else {
        list2.next = mergeTwoLists(list1, list2.next);
        return list2;
    }
}
```

# 11 最大水量(中)
    You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).

    Find two lines that together with the x-axis form a container, such that the container contains the most water.

* 约束：
  * `n == height.length`
  * `2 <= n <= 10^5`
  * `0 <= height[i] <= 10^4`
* 个人解法:逻辑通，但超时
* **改进**
```java
public static int maxArea(int[] height) {
    int min=0,max=Math.min(height[0], height[1]);
    for(int i=2;i<height.length;i++){
        for(int j = 0;j<i;j++){
            min = Math.min(height[j], height[i]) * (i-j);
            if (min>max) {
                max = min;
            }
        }
    }
    return max;
}
```
* 最优解
```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int maxArea = 0;

        while (left < right) {
            int currentArea = Math.min(height[left], height[right]) * (right - left);
            maxArea = Math.max(maxArea, currentArea);

            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return maxArea;
    }
}
```
* 疑问：为什么最优解中，left和right的值一定会小于最大值?
  * 答案：因为每次循环，都会将left和right的值向中间移动，所以left和right的值一定会小于最大值
* **最优解升级版**:持续降低循环次数
```java
public int maxArea(int[] height) {
    int max = 0,s = 0,e = height.length-1;

    while(s<e){
        int h = Math.min(height[s],height[e]);
        int amt = h*(e-s);
        if(max<amt) max = amt;
        while(s<e && height[s]<=h) s++;
        while(s<e && height[e]<=h) e--;
    }
    return max;
}
```
# 12 Intege to Roman (中)
    Roman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:
* 逻辑
  * If the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.
  * If the value starts with 4 or 9 use the subtractive form representing one symbol subtracted from the following symbol, for example, 4 is 1 (I) less than 5 (V): IV and 9 is 1 (I) less than 10 (X): IX. Only the following subtractive forms are used: 4 (IV), 9 (IX), 40 (XL), 90 (XC), 400 (CD) and 900 (CM).
  * Only powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 (V), 50 (L), or 500 (D) multiple times. If you need to append a symbol 4 times use the subtractive form.
* 约束 ：`1 <= num <= 3999`
* 基本解法：分段处理
  * 1000+
  * >=500：900，500<900
  * >=100: 400,100<400
  * >=50: 90,50<90
  * >=10: 40,10<40
  * >=5: 9,5<9
  * >0: 4,1<4
```java
public static String intToRoman(int num) {
        StringBuilder sb = new StringBuilder();
        while (num>=1000) {num -= 1000;sb.append("M");}
        while (num>=500) {
            if (num/100 == 9) {num -= 900;sb.append("CM");
            }else{num -= 500;sb.append("D");}
        }
        while (num>=100) {
            if (num/100 == 4) {num -= 400;sb.append("CD");
            }else{num -= 100;sb.append("C");}
        }
        while (num>50) {
            if (num/10 == 9) {num -= 90;sb.append("XC");
            }else{num -= 50;sb.append("L");}
        }
        while (num>10) {
            if (num/10 == 4) {num -= 40;sb.append("XL");
            }else{num -= 10;sb.append("X");}
        }
        while (num>5) {
            if (num == 9) {num -= 9;sb.append("IX");
            }else{num -= 5;sb.append("V");}
        }
        while (num>0) {
            if (num == 4) {num -= 4;sb.append("IV");
            }else{num -= 1;sb.append("I");}
        }
        return sb.toString();
    }
```
* 其它解法
  * 将所有可能一一对应罗列，通过匹配方式输出
```java
// O(n)
public String intToRoman(int num) {
    int[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};
    String[] romans = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
    StringBuilder sb=new StringBuilder();
    for(int i=0;i<values.length;i++){
        while(num>=values[i]){
            num-=values[i];
            sb.append(romans[i]);
        }
    }
    return sb.toString();
}
```
```java
// O(1)
public String intToRoman(int num) {
    string ones[] = {"","I","II","III","IV","V","VI","VII","VIII","IX"};
    string tens[] = {"","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"};
    string hrns[] = {"","C","CC","CCC","CD","D","DC","DCC","DCCC","CM"};
    string ths[]= {"","M","MM","MMM"};
        
    return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];
}
```
# 15 Three Sum(中)
    Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

    Notice that the solution set must not contain duplicate triplets.

* 约束：
  * `3 <= nums.length <= 3000`
  * `-10^5 <= nums[i] <= 10^5`

* 个人版：超时，
  * 原因：三重循环，并且判重逻辑，补充额外大对象变量
```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    Map<String, Integer> sets = new HashMap<>();
    for(int i = 0; i < nums.length - 2; i++){
        for(int j = i + 1; j < nums.length - 1; j++){
            for(int k = j + 1; k < nums.length; k++){
                if(nums[i] + nums[j] + nums[k] == 0){
                    List<Integer> list = Arrays.asList(nums[i], nums[j], nums[k]);
                    list.sort((l1,l2)->l1-l2);
                    String key = list.get(0) + "," + list.get(1) + "," + list.get(2);
                    if (!sets.containsKey(key)) {
                        result.add(list);
                        sets.put(key, null);
                    }
                }
            }
        }
    }
    return result;
}
```
* 最优解：首先对数组进行排序，根据排序结果再匹配
  * 为避免相邻元素重复：第一和第二个元素都要对相同值跳过
  * 第一和第二从左侧开始，第三从右侧开始匹配
    * 若和大于0，则第三过大，向左移动
    * 若和小于0，则第二过小，向右移动
    * 若和等于0，则加入结果集，同时第二向右移动
  * 两重循环；通过排序解决重复问题
```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    Arrays.sort(nums); // 重点，先排序

    for(int i = 0; i < nums.length -2; i++){
        if (i > 0 && nums[i] == nums[i-1]) {continue;} // 避免重复，因已排序，故而相邻相同时，对应的结果相同
        
        int j = i + 1, k = nums.length - 1;
        if (nums[i] + nums[j] + nums[k]>0) {break;} // 修订：当初次匹配的和大于0，则无需继续，因已排序，和只会越来越大

        while (j<k) {
            int total = nums[i] + nums[j] + nums[k];
            if (total>0) {k--;}
            else if (total<0) {j++;}
            else{
                result.add(Arrays.asList(nums[i], nums[j], nums[k]));
                j++;
                while (j<k && nums[j] == nums[j-1]) { // 避免第二元素重复，同理
                    j++;
                }
            }
        }
    }
    return result;
}
```
# 16 最接近目标值的三数之和
    Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.

* 思路：和三数之和为0的问题类似，先排序，然后比较
```java
public int threeSumClosest(int[] nums, int target) {
    Arrays.sort(nums);
    int count = -1001;
    for (int i = 0; i < nums.length; i++) {
        int j = i + 1, k = nums.length - 1;
        while (j < k) {
            int sum = nums[i] + nums[j] + nums[k];
            if (sum == target) return target;

            if (count == -1001) count = sum;
            if(sum < target) j++;
            else if (sum> target) k--;

            if (Math.abs(sum - target)<Math.abs(count - target)) count = sum;
        }
    }
    return count;
}
```

# 17 电话号码的字母组合
    Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.

    A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

    { "2":"abc", "3":"def", "4":"ghi", "5":"jkl", "6":"mno", "7":"pqrs", "8":"tuv", "9":"wxyz" }

* 约束
  * `0 <= digits.length <= 4`
  * `digits[i] is a digit in the range ['2', '9'].`
* 个人版：字符串循环拼接
```java
public List<String> letterCombinations(String digits) {
    List<String> result = new ArrayList<>();

    String[] letters = { "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };

    for (int i = 0; i < digits.length(); i++) {
        String[] letter = letters[digits.charAt(i) - 50].split("");

        if (result.size() == 0) {
            result.addAll(Arrays.asList(letter));
            continue;
        }

        List<String> temp = new ArrayList<>();
        for (String str : letter) {
            for(String str2:result) temp.add(str2 + str);
        }
        result = temp;
    }

    return result;
}
```
* 升级版：
  * 使用StringBuilder加速字符串拼接
  * 使用回溯法取代循环，缩减代码
```java
public List<String> letterCombinations(String digits) {
    List<String> result = new ArrayList<>();

    String[] letters = { "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };

    combina(digits, letters, new StringBuilder(), 0, result);

    return result;
}

private void combina(String digits,String[] letters, StringBuilder sb,int start, List<String> result){
    if (start == digits.length()) {
        result.add(sb.toString());
        return;
    }

    String[] strs = letters[digits.charAt(start) - 50].split("");
    for (int i = 0; i < strs.length; i++) {
        sb.append(strs[i]);
        combina(digits, letters, sb, start + 1, result);
        sb.deleteCharAt(sb.length() - 1);
    }

}
```
# 18 四数之和
    Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:
    * 0 <= a, b, c, d < n
    * a, b, c, and d are distinct.
    * nums[a] + nums[b] + nums[c] + nums[d] == target

* 约束
  * `1 <= nums.length <= 200`
  * `-10^9 <= nums[i] <= 10^9`
  * `-10^9 <= target <= 10^9`
* 思考
  * 仿照三数之和，先排序，再对比
  * 由于数值元素限制，四数之和可能大于Integer，使用long类型转换，避免溢出
  * 固定前两个和，由后两个和与差值做对比，避免重复计算前两个和
  * 若循环者下一个值与前一个值相同，则跳过，进入下一次循环
* 个人版
```java
public List<List<Integer>> fourSum(int[] nums, int target) {
    List<List<Integer>> res = new ArrayList<>();
    Arrays.sort(nums);
    for (int i = 0; i < nums.length - 3; i++) {
        if(i>0 && nums[i]==nums[i-1]) continue; 
        for (int j = i+1; j < nums.length - 2 ; j++) {
            if (j>i+1 && nums[j] == nums[j-1]) continue;

            int k = j+1, l = nums.length - 1;
            while (k < l) {
                long sum = (long)nums[i] + nums[j] + nums[k] + nums[l];
                if (sum > Integer.MAX_VALUE) {
                    l--;
                    continue;
                }
                
                if (sum < target) k++;
                else if (sum>target) l--;
                else{
                    res.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l]));
                    while (k<l && nums[k] == nums[k+1]) k++;
                    while (k<l && nums[l] == nums[l-1]) l--;
                    k++;
                }
            }
        }
    }

    return res;
}
```
* 优化版
  * 固定前两个和，避免重复计算
```java
public List<List<Integer>> fourSum(int[] nums, int target) {
    List<List<Integer>> res = new ArrayList<>();
    Arrays.sort(nums);
    for (int i = 0; i < nums.length - 3; i++) {
        if(i>0 && nums[i]==nums[i-1]) continue; 
        for (int j = i+1; j < nums.length - 2 ; j++) {
            if (j>i+1 && nums[j] == nums[j-1]) continue;
            long sum = (long)target - nums[i] - nums[j];
            int k = j+1, l = nums.length - 1;
            while (k < l) {
                long twosum = nums[k] + nums[l];
                if (sum < twosum)  l--;
                else if (sum > twosum) k++;
                else{
                    res.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l]));
                    while (k<l && nums[k] == nums[k+1]) k++;
                    while (k<l && nums[l] == nums[l-1]) l--;
                    k++;
                    l--;
                }
            }
        }
    }

    return res;
}
```

# 19 从List结尾移除第N项节点
    Given the head of a linked list, remove the nth node from the end of the list and return its head.
* **约束**
  * 1 <= sz <= 30
  * 0 <= Node.val <= 100
  * 1 <= n <= sz
```java
public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```
* 普通版：
  * 时间复杂度为O(n)
  * 易理解
```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode next = head;int total = 0;
    while (next != null) {
        total++;
        next = next.next;
    }
    if (total == n) {
        return head.next;
    }
    total = total - n;
    next = head;
    while (total>1) {
        total--;
        next = next.next;
    }
    next.next = next.next.next;
    return head;
}
``
* 递归版
    * 时间复杂度高于O(n),低于O(n^2)
    * 使用了递归思想，简化了代码
```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    return removeNthFromEnd(head,head,n);
}
private ListNode removeNthFromEnd(ListNode head,ListNode node,int n){
    int size = ListNodeSize(node);
    if (size-1 > n ) return removeNthFromEnd(head,node.next,n);
    if (size  == n) return head.next;
    node.next = node.next.next;
    return head;
}
private int ListNodeSize(ListNode node){
    if (node == null) return 0;
    return ListNodeSize(node.next)+1;
}
```
# 20 括号的可能组合
    Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
* 约束
  * `1 <= n <= 8`
  * 结果需要**排序**，否则和LeetCode结果顺序不一致就会错误
* 个人版
  * 初次想法：比前一个，将括号添加到每个元素头部，尾部，外部，有缺漏(无法在中间插入，导致缺失部分可能性)
  * 最终想法：对一个单独括号匹配，给这个单括号在外部和相邻位置分别再加一个单括号，然后越过该单括号位置后，再继续下一次循环，直至找不到为止
    * 由于其它情形存在，最终合并后就包含所有
    * **时间复杂度O(n^2)**
```java
public List<String> generateParenthesis(int n){
    if(n == 1) return Collections.singletonList("()");
    Set<String> set = new HashSet<String>();
    generateParenthesis(n-1).forEach(sub->{
        int start = 0;
        while ((start = sub.indexOf("()", start)) != -1) {
            set.add(sub.substring(0, start) + "()()" + sub.substring(start + 2));
            set.add(sub.substring(0, start) + "(())" + sub.substring(start + 2));
            start += 2;
        }
    });
    return set.stream().sorted().collect(Collectors.toList());
}
```
* 官方较优解：分别从左右匹配,左侧每个位置加`(`,右侧每个位置加`)`，直至左右对等
  * **时间复杂度 O(n)**
```java
public List<String> generateParenthesis(int n){
    List<String> result = new ArrayList<String>();
    StringBuilder sb = new StringBuilder();
    generateParenthesis(result, sb, 0, 0, n);
    return result;
}
public void generateParenthesis(List<String> result, StringBuilder sb, int leftCount,int rifghtCount,int n) {
    if (leftCount == n && rifghtCount == n) {
        result.add(sb.toString());
        return;
    }
    if (leftCount<n) {
        sb.append("(");
        generateParenthesis(result, sb, leftCount + 1, rifghtCount, n);
        sb.deleteCharAt(sb.length()-1); // 减去多增加的 ( 字符
    }
    if (rifghtCount<n && rightCount<leftCount) {
        sb.append(")");
        generateParenthesis(result, sb, leftCount, rifghtCount + 1, n);
        sb.deleteCharAt(sb.length()-1); // 减去多增加的 ) 字符
    }
}
```
# 23 合并多个有序链表
    You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
* 约束：
  * `k == lists.length`
  * `0 <= k <= 10^4`
  * `0 <= lists[i].length <= 500`
  * `-10^4 <= lists[i][j] <= 10^4`
  * `lists[i] is sorted in ascending order.`
  * `The sum of lists[i].length will not exceed 10^4.`
```java
public static class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```
* 个人版：
  * 针对链表操作，头部初始化自定义，后续节点在next处绑定，避免判断头部是否为空
  * 遍历链表，按顺序插入到新链表中
  * 时间复杂度O(n^2)
```java
public static ListNode mergeKLists(ListNode[] lists) {
    if (lists.length == 0) return null;
    if(lists.length == 1) return lists[0];
    ListNode head = new ListNode(),list,pre,node ;
    for(int i = 0;i<lists.length;i++){
        if((node = lists[i]) == null) continue;
        if (head.next == null) {
            head.next = node;
            continue;
        }
        pre = head;
        list = head.next;
        while(list!=null && node != null){
            if(list.val<=node.val){
                pre = pre.next = list;
                list = list.next;
                continue;
            }
            
            pre = pre.next = node;
            node = node.next;
            
        }
        ListNode tmp = list == null ? node : list;
        while (tmp!=null) {
            pre = pre.next = tmp;
            tmp = tmp.next;
        }
    }
    return head.next;
}	
```
* 官方优解
  * 采用递归算法，最优解为单独一个ListNode
  * 采用二分法排序，直至最终只有一个元素结果
  * 时间复杂度O(n)
```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists.length == 0)  return null;
    if (lists.length == 1) return lists[0];
    return mergeSorted(0,lists.length-1,lists);
}

public ListNode mergeSorted(int start,int end,ListNode[] lists){
    if (start == end) {
        return lists[start];
    }
    int mid = (start + end) >>> 1;
    ListNode left = mergeSorted(start,mid,lists),right = mergeSorted(mid+1,end,lists);
    return mergeTwoLists(left, right);
}
public ListNode mergeTwoLists(ListNode list1,ListNode list2){
    ListNode head = new ListNode();
    ListNode next = head;
    while(list1!=null && list2!=null){
        if(list1.val<=list2.val){
            next = next.next = list1;
            list1 = list1.next;
            continue;
        }
        
        next = next.next = list2;
        list2 = list2.next;
    }
    ListNode tmp = list1!=null ? list1 : list2;
    while (tmp !=null) {
        next = next.next = tmp;
        tmp = tmp.next;
    }
    return head.next;
}
```
# 24 两两交换链表中的节点
    Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)

* 约束：
  * `The number of nodes in the list is in the range [0, 100].`
  * `0 <= Node.val <= 100`
* 个人版
  * 采用递归算法，最优解为节点为空或下一个节点为空
  * 每个次递归时，校验两个节点(当前节点和下一个节点)
    * 子递归，已当前节点的下下各节点为开头
    * 当前递归交换两个节点，然后下下各节点为下次递归结果
```java
public ListNode swapPairs(ListNode head) {
    if(head == null) return null;
    if(head.next == null) return head;
    
    ListNode next = head.next;
    ListNode nh = swapPairs(next.next);
    next.next = head;
    head.next = nh;
    head = next;
    return head;
}
```

# 25 K 个一组翻转链表
    Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.

    k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.

    You may not alter the values in the list's nodes, only nodes themselves may be changed.

* 约束：
  * `The number of nodes in the list is n.`
  * `1 <= k <= n <= 5000`
  * `0 <= Node.val <= 1000`
* 思路
  * 先统计k长度的不为空的节点ListNode
    * 长度不够时直接保持原样返回
  * 将k个节点做**反转**(注意是反转，不是兑换第k个节点)
  * 若后续还有节点，则采用递归形式继续，直至结束
```java
public static ListNode reverseKGroup1(ListNode head, int k) {
    if(head == null) return head;
    ListNode curr = head,dummy = null,prev = null;
    int count = 0;
    while(curr != null && count < k){
        curr = curr.next;
        count++;
    }
    if (count<k) return head;
    count = 0;curr = head;
    while(curr != null && count < k){
        dummy = curr.next;
        curr.next = prev;
        prev = curr;
        curr = dummy;
        count++;
    }
    if(dummy != null) head.next = reverseKGroup(dummy, k);
    return prev;
}
```
# 26 删除有序数组中的重复项
    Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.

    Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

    Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
    
    Return k.

* 约束
  * `1 <= nums.length <= 3 * 10^4`
  * `-100 <= nums[i] <= 100`
  * `nums is sorted in non-decreasing order.`
* 思路：
  * 无需考虑第一个元素，遍历直接从第二个开始
  * 记录结果有效元素索引
  * 以遍历值和有效索引对应值比较
    * 相等过滤
    * 不等，在有效索引下一位填充该值
  * 结果返回有效索引值+1
```java
public int removeDuplicates(int[] nums) {
    int idx = 0;
    for(int i = 1;i<nums.length;i++){
        if(nums[idx] == nums[i]) continue;
        nums[++idx] = nums[i];
    }
    return idx+1;
}
```

# 27 移除指定值元素
    Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.

    Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:

    Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.
    Return k.

* 约束
  * `0 <= nums.length <= 100`
  * `0 <= nums[i] <= 50`
  * `0 <= val <= 100`
* 思路：同上
```java
public int removeElement(int[] nums, int val) {
    int idx = 0;
    for(int i = 0;i<nums.length;i++){
        if(nums[i] == val) continue;
        nums[idx++] = nums[i];
    }
    return idx;
}
```

# 28 Find the Index of the First Occurrence in a String
    Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

* 约束；
  * `1 <= haystack.length, needle.length <= 10^4`
  * `haystack and needle consist of only lowercase English characters.`
* 思路：
  * 可以使用各语言字符串原生操作`indexOf`
* 思路：
  * 比较长度，若匹配内容长，直接返回-1
  * 遍历被匹配内容，判断第一个字符是否相等，不等下次循环
  * 相等继续匹配下一个字符是否相等
  * 若结束都未匹配完或者其它字符不等则返回-1，
  * 否则返回当前被匹配索引值
```java
// haystack.indexOf(needle);
public int strStr(String haystack, String needle) {
    if(haystack.length()<needle.length()) return -1;
    A:for(int i=0;i<haystack.length();i++){
        if(haystack.charAt(i) != needle.charAt(0)) continue A;
        if(needle.length() ==1 ) return i;
        boolean flag = false;
        for(int j=1;j<needle.length() && i+j<haystack.length();j++){
            if(i+j==haystack.length()-1 && j!=needle.length()-1) return -1;
            if(!(flag = haystack.charAt(i+j) == needle.charAt(j))) continue A;
        }
        if (flag) return i;
    }
    return -1;
}
```
* **优化版**
  * 被匹配内容索引**截止**(总长-匹配内容长度)
  * 若匹配结果索引值+1等于匹配内容长度，则返回当前被匹配索引值
  * 否则返回-1
```java
public int strStr(String haystack, String needle) {
    int hl = haystack.length(),nl = needle.length();
    if(hl<nl) return -1;
    for(int i=0; i<=hl-nl; i++){
        int j=0;
        while(j<nl && haystack.charAt(i+j) == needle.charAt(j)) j++;
        if(j==nl) return i;
    }
    return -1;
}
```

# 29 Divide Two Integers
    Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.

    The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.

    Return the quotient after dividing dividend by divisor.

* 约束：
  * `-2^31 <= dividend, divisor <= 2^31 - 1`
  * `divisor != 0`
* 个人版
  * 将所有值转为long类型正数
  * 判断最终结果正负
  * 处理除数为1的特殊情况，根据结果正负和被除数的限制，返回结果
```java
// 如果允许使用乘除，模式运算，可以考虑 
/**
 * if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;
 * return dividend/divisor
 */
public int divide(int dividend, int divisor) {
    if(dividend == 0) return 0;
    int count = 0;
    boolean df,rf,rsf;
    long dl = (df=dividend>0)?dividend:-((long)dividend);
    long d2 = (rf = divisor>0)?divisor:-((long)divisor);
    rsf = df == rf;
    if(d2 == 1) return rsf ? dividend==Integer.MIN_VALUE?Integer.MAX_VALUE:df?dividend:-dividend:df?-dividend:dividend;
    if(dl<d2) return 0;
    if(dl == d2) return rsf?1:-1;
    while(dl>=d2){
        dl -= d2;
        count++;
    }
    return rsf?count:-count;
}
```
* 优化版
  * 将dividend为最小Integer和divisor为-1的情况单独处理
  * 将Integer类型转Long类型，避免溢出
  * 加快逻辑：将被除数与除数的倍数比较(使用**位运算**)，结果直接加倍数，并将被除数减去除数倍数倍，然后继续重复，直至被除数小于除数
```java
public int divide(int dividend, int divisor) {
    if(dividend == 0) return 0;
    if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;
    int result = 0;
    boolean df,rf,rsf;
    long d1 = (df=dividend>0)?dividend:-((long)dividend);
    long d2 = (rf = divisor>0)?divisor:-((long)divisor);
    rsf = df == rf;
    if(d2 == 1) return rsf ? df?dividend:-dividend:df?-dividend:dividend;
    if(d1<d2) return 0;
    while(d1>=d2){
        int count = 0;
        while(d1>=(d2<<(count+1))) count++;
        result += 1<<count;
        d1-= d2 << count;
    }
    return rsf?result:-result;
}
```
# 30 Substring with Concatenation of All Words
    You are given a string s and an array of strings words. All the strings of words are of the same length.

    A concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.

    For example, if words = ["ab","cd","ef"], then "abcdef", "abefcd", "cdabef", "cdefab", "efabcd", and "efcdab" are all concatenated strings. "acdbef" is not a concatenated string because it is not the concatenation of any permutation of words.
    Return an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.

约束：
* `1 <= s.length <= 10^4`
* `1 <= words.length <= 5000`
* `1 <= words[i].length <= 30`
* `s and words[i] consist of lowercase English letters.`
* 个人版
  * 自定义一个节点，存储字符串和索引值
    * 对于重复值，先排序，再获取索引值
  * 检查索引有效值
    * 按索引值排序
    * 判断两两索引值之间差是否为单个字符串长度(数组中的字符串)
    * 直至循环完都相等，则记录第一个索引值(之前已排序)
    * 不相等，则对第一个字符串重新获取索引值
      * 需要排除重复值的索引值，即以重复值的最大索引+单个字符串长度为起始开始检索索引
    * 重新检查索引有效值
  * **问题**：部分用例和leetcode执行结果不一致
    * `s = "barfoofoobarthefoobarman", words = ["bar","foo","the"],result = [13]`,本地结果为`[13]`,leetcode输出`[]`导致错误无法提交
    * 不确定问题在哪里，代码感觉没有问题, 在其它平台执行结果都是正确的(只能说可能和leetcode执行逻辑不匹配)
    * 代码确实繁重了，可以优化
    * 借助了自定义类
```java
public List<Integer> findSubstring(String s, String[] words) {
    List<Integer> list = new ArrayList<>();
    int subLength = words[0].length(),subAllLength = words.length * subLength;
    // 1. 验证长度是否够总长限制
    if(s.length()<subAllLength ) return list; // 长度限制
    
    Node[] nodes = new Node[words.length];
    Arrays.sort(words);
    int preIndex = -1;
    // 2. 获取每个word对应索引值
    for(int i=0;i<words.length;i++){
        int subIndex = i != 0 && words[i] == words[i-1]?subIndex = s.indexOf(words[i],preIndex + subLength):s.indexOf(words[i]);
        if(subIndex == -1) return list; // 2.1 存在一个字符串未匹配的，则代表全部无效
        nodes[i] = new Node(words[i],subIndex);
        preIndex = subIndex;
    }
    // 3. 其它情况的索引校验
    checkIndex(s, nodes, list, subLength,subAllLength);
    return list;
}
public void checkIndex(String s,Node[] nodes,List<Integer> list,int subLength,int subAllLength){
    Arrays.sort(nodes,(l1,l2)-> l1.idx-l2.idx); // 先按索引值排序
    Node preNode = nodes[0];
    int idx = -1 ;	// 标记无效的索引，!= -1 代表无效
    // 4. 验证索引值是否连续
    for(int i = 1;i<nodes.length;i++){
        Node node = nodes[i];
        if(node.idx-preNode.idx != subLength){
            idx = i;
            break; // 中断循环
        }
        preNode = node;
    }
    if(idx == -1) list.add(nodes[0].idx); // 有效索引值记录
    if (s.length() - (nodes[0].idx+subLength) <subAllLength) return; //当剩余长度不够时，直接退出
    int start = nodes[0].idx;
    for(int i = 1;i<nodes.length;i++){
        if (nodes[i].sub.equals(nodes[0].sub)) {
            start = nodes[i].idx;
        }
    }
    // 重新匹配第一个节点索引值，重新校验：实际结果排序后可能以下一个节点为开头
    int subIndex = s.indexOf(nodes[0].sub,start + subLength); //  将从无效位置的前一个+字符串长度为索引开始重新匹配前面所有无效的下一个索引值
    if(subIndex == -1) return; // 无法获取下一个索引值时，程序中断
    nodes[0].idx = subIndex; // 更新第一个索引值
    // 继续校验
    checkIndex(s,nodes,list,subLength,subAllLength);
}

public class Node{
    private String sub;
    private int idx;
    public Node(String sub,int idx){
        this.sub = sub;
        this.idx = idx;
    }
}
```
* **优解版**
  * **以Map存储word出现次数**
  * 遍历单词数组
    * 遍历不超过字符串长度，每次**步长为一个单词长**
      * 将截取的字符串放入临时Map中，并将统计次数(默认0)+1
      * 如果截取的字段数和单词组数相当时，判断两个Map是否相等，
        * 相等则记录索引值
      * 临时Map将开头单词的次数-1，
      * 截取的单词数同理-1；
      * 将判断符合条件的索引值 k 同理加一个单词长度
```java
public List<Integer> findSubstring(String s, String[] words) {
    List<Integer> list = new ArrayList<>();
    int n = s.length(), m = words.length, w = words[0].length(),t = m * w;
    if (n < t) return list;

    Map<String,Integer> map = Arrays.stream(words).collect(Collectors.toMap(i->i, i->1, Integer::sum));
    for (int i = 0; i < w; i++) {
        Map<String,Integer> temp = new HashMap<>();
        int count = 0;
        for (int j = i,k=i; j + w<= n; j += w) {
            String word = s.substring(j, j + w);
            temp.put(word,temp.getOrDefault(word,0)+1);
            count++;

            if (count == m) { // 每次循环都判断是否满足条件
                if (map.equals(temp)) list.add(k); // 满足条件，添加索引值
                temp.computeIfPresent(s.substring(k,k+w), (a,b) -> b > 1 ? b - 1 : null);
                count--; // 移除第一个索引值，count减1
                k =k+w;
            }
        }
    }
    return list;
}
```
* 总结：
  * 以Map存储字符串及出现的次数
  * 每次单词组内字符串验证一批次之后，移除第一个字符串次数，重新遍历
  * 每次单词遍历以一个单词长为步长匹配单词

# 31. 下一个排列
    A permutation of an array of integers is an arrangement of its members into a sequence or linear order.

    Given an array of integers nums, find the next permutation of nums.

    The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).

* For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].
* For example, the next permutation of arr = [1,2,3] is [1,3,2].
* Similarly, the next permutation of arr = [2,3,1] is [3,1,2].
* While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.

约束：
* `1 <= nums.length <= 100`
* `0 <= nums[i] <= 100`

思路：
* 从后向前遍历，找到前者比后者大的索引
* 不存在时，证明为最大值，进行反转(即最小排序)，结束
* 存在时，重新从后向向前到刚才的索引处遍历，找到比索引对应大的值，进行交换
* 对索引+1到结尾进行排序(反转，因必定是最大排序，故转最小值排序)
* 因使用了第三方Arrays对数据进行反转排序，存在额外操作，导致速度相对较慢
```java
public void nextPermutation(int[] nums) {
    if(nums.length <2) return;
    int i = nums.length-2 ;
    while(i>=0 && nums[i]>=nums[i+1]){ // 过滤前者比后者大的位置
        i--;
    }
    if(i<0){ // 即最大值排序。相对应最小排序
        Arrays.sort(nums);
        return; // 结束
    }
    // 存在前一个比后一个小的现象，nums[i] < nums[i+1]
    int j = nums.length-1;
    while(i<j){
        if (nums[j] > nums[i]) {
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
            break;
        }
        j--;
    }
    // 再对 i+1 到结尾进行排序
    int[] tmps = Arrays.copyOfRange(nums,i+1,nums.length);
    Arrays.sort(tmps);
    i++;
    for (int k = 0; k < tmps.length; k++) {
        nums[i+k] = tmps[k];
    }
}
```
优化版：
* 提供自定义交换和反转操作，比Arrays操作快
```java
public void nextPermutation(int[] nums){
    if(nums.length <2) return;
    int i = nums.length-2 ;
    while(i>=0 && nums[i]>=nums[i+1]) i--; // 过滤前者比后者大的位置
    if(i<0){ // 即最大值排序。相对应最小排序
        reverse(nums, 0);
        return; // 结束
    }
    // 存在前一个比后一个小的现象，nums[i] < nums[i+1]
    for(int j = nums.length - 1;j>i;j--){
        if (nums[j] > nums[i]) {
            swap(nums,i,j);
            break;
        }
    }
    // 再对 i+1 到结尾进行排序
    reverse(nums, i+1);
}

public void swap(int [] nums ,int i,int j){
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
public void reverse(int [] nums ,int start){
    int i=start,j=nums.length-1;
    while(i<j){
        swap(nums,i,j);
        i++;
        j--;
    }
}
```

# 32 最长有效圆括号
    Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.

* 约束：
  * `0 <= s.length <= 3 * 10^4`
  * `s[i] is '(', or ')'.`
* 思路：
  * 使用栈，遇到左括号，入栈，遇到右括号，出栈，当栈为空时，记录当前长度，当栈不为空时，清空栈，重新开始
  * 遍历完成后，再次记录当前长度，返回最大值
```java
public int longestValidParentheses(String s) {
    Stack<Integer> stack = new Stack<>();
    stack.push(-1);
    int max_len = 0,n=s.length();
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == '(') {
            stack.push(i);
        } else {
            stack.pop();
            if (stack.isEmpty()) {
                stack.push(i);
            } else {
                max_len = Math.max(max_len, i - stack.peek());
            }
        }
    }

    return max_len;        
}
```

# 33 搜索旋转排序数组
    There is an integer array nums sorted in ascending order (with distinct values).

    Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

    Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

    You must write an algorithm with O(log n) runtime complexity.

* 约束：
  * `1 <= nums.length <= 5000`
  * `-10^4 <= nums[i] <= 10^4`
  * All values of nums are unique.
  * `nums` is an ascending array that is possibly rotated.
  * `-10^4 <= target <= 10^4`
* 思路：
  * 使用二分查找，找到中间值，判断中间值是否为目标值，若不是，则判断中间值与目标值的大小，从而确定目标值在左半部分还是右半部分，然后递归查找
* 个人版：
  * 先定位 旋转位点k，找到最大值索引，在根据target范围查找
  * 优化：可边定位边匹配
```java
public int search(int[] nums, int target) {
    if(nums.length ==1){
        if(nums[0] == target) return 0;
        else return -1;
    }
    int maxIndex = nums.length-1;
    if (nums[maxIndex]<nums[0]) { // 被旋转了
        maxIndex--;
        while (maxIndex>0) {
            if (nums[maxIndex]>nums[maxIndex+1]) {
                break;
            }
            maxIndex--;
        }
    } // else 未被旋转 maxIndex = nums.length-1;
    System.out.println(maxIndex);
    if (nums[0]<=target) {
        while (maxIndex>-1) {
            if (nums[maxIndex] == target) {
                return maxIndex;
            }
            maxIndex--;
        }
    }else{
        maxIndex++;
        while (maxIndex<nums.length) {
            if (nums[maxIndex] == target) {
                return maxIndex;
            }
            maxIndex++;
        }
    }
    return -1;
}
```
* 优化版：
  * 采用二分法，每一边存在某一方必需两个条件都满足时才能处理，否则就是另一边进行处理
```java
public int search(int[] nums,int target){
    int low = 0,high = nums.length-1;
    while(low<=high){
        int mid = (high-low)/2;
        if(nums[mid]==target) return mid;
        if (nums[low]<=nums[mid]) {
            if (nums[low]<=target && nums[mid]>target) {
                high= mid-1;
            }else{
                low = mid +1;
            }
        }else{
            if (nums[mid]<target && target<=nums[high]) {
                low = mid+1;
            }else{
                high = mid-1;
            }
        }
    }
    return -1;
}
```


# 34 在排序数组中查找元素的第一个和最后一个位置
    Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

    If target is not found in the array, return [-1, -1].

    You must write an algorithm with O(log n) runtime complexity.

* 约束：
  * `0 <= nums.length <= 10^5`
  * `-10^9 <= nums[i] <= 10^9`
  * nums is a non-decreasing array.
  * `-10^9 <= target <= 10^9`
* 思路
* 初版
```java
public int[] searchRange(int[] nums, int target) {
    int[] result = {-1,-1};
    int low=0,high = nums.length-1;
    while(low<=high && (result[0]==-1 || result[1]==-1)){
        if(nums[low] == target ){
            result[0] = low;
        }else{
            low++;
        }
        if(nums[high] == target){
            result[1] = high;
        }else{
            high--;
        }
    }
    return result;
}
```
# 35 在排序数组中查找插入位置(Easy)
    Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

    You must write an algorithm with O(log n) runtime complexity.

* 约束：
  * `1 <= nums.length <= 10^4`
  * `-10^4 <= nums[i] <= 10^4`
  * `nums` is sorted in non-decreasing order.
  * `-10^4 <= target <= 10^4`
* 思路：
  * 匹配大于等于项，对应索引即位置
  * 若未匹配，则结尾插入，索引对应数组长度
* 代码
```java
public int searchInsert(int[] nums, int target) {
    for(int i =0;i<nums.length;i++){
        if(nums[i]>=target){
            return i;
        }
    }
    return nums.length;
}
```
# 36 有效的数独(中)
    Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
    Each row must contain the digits 1-9 without repetition.
    Each column must contain the digits 1-9 without repetition.
    Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
    Note:
    A Sudoku board (partially filled) could be valid but is not necessarily solvable.
    Only the filled cells need to be validated according to the mentioned rules.
* 约束：
  * `board.length == 9`
  * `board[i].length == 9`
  * `board[i][j] is a digit 1-9 or '.'.`
* 思路：重点关注**九宫格**规则
  * 遍历，判断行、列、九宫格是否满足条件
  * 九宫格规则：
    * 行：`board[i][j]`
    * 列：`board[j][i]`
    * **九宫格**：`board[3*(i/3)+j/3][3*(i%3)+j%3]`
* 改进：使用二维boolean数组判断
```java
public boolean isValidSudoku(char[][] board) {
    int[] rows,cols,squares;
    for(int i = 0;i<9;i++){
        rows = new int[9];cols=new int[9];squares = new int[9];
        for(int j=0;j<9; j++){
            // 同行校验 [i][j]
            if(!isValidArrays(board[i][j], rows)) return false;
            // 同列校验 [j][i]
            if(!isValidArrays(board[j][i], cols)) return false;
            // 3x3格校验 [3*(i/3)+j/3][3*(i%3)+j%3]
            if(!isValidArrays(board[3*(i/3)+j/3][3*(i%3)+j%3], squares)) return false;
        }
    }
    return true;
}

public boolean isValidArrays(char ch,int[] nums){
    if (ch == '.')  return true;
    if (nums[ch-49] == ch)  return false;
    nums[ch-49] = ch;
    return true;
}

// 改进版
public boolean isValidSudoku(char[][] board) {
    // Each [i][j]: i = row/col/box index, j = number 0..8 for '1'..'9'
    boolean[][] rows = new boolean[9][9],cols = new boolean[9][9],boxes = new boolean[9][9];
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            char c = board[i][j];
            if (c == '.') continue;
            int num = c - '1'; // 0-based index for '1'..'9'
            int box = (i / 3) * 3 + (j / 3); // sub-box index: 0..8
            if (rows[i][num] || cols[j][num] || boxes[box][num]) return false;
            rows[i][num] = cols[j][num] = boxes[box][num] = true;
        }
    }
    return true;
}
```
# 37 解数独(难)
    Write a program to solve a Sudoku puzzle by filling the empty cells.
    A sudoku solution must satisfy all of the following rules:
    Each of the digits 1-9 must occur exactly once in each row.
    Each of the digits 1-9 must occur exactly once in each column.
    Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.
    The '.' character indicates empty cells.

* 约束：
  * `board.length == 9`
  * `board[i].length == 9`
  * `board[i][j] is a digit or '.'.`
  * `It is guaranteed that the input board has only one solution.`
* 代码（初版）
  * 思路：当某个位置不存在时，从1-9一次填充，
    * 填充一次检查是否有效
    * 有效，继续下一个位置
    * 无效，则换下一个填充
  * 问题：重复无效填充，导致时间耗时较高
```java
public void solveSudoku(char[][] board) {
    solve(board);
}
public boolean solve(char[][] board) {
    char[] nums = {'1','2','3','4','5','6','7','8','9'};
    for(int i = 0;i<9;i++){
        for(int j = 0;j<9;j++){
            if(board[i][j] != '.') continue;
            for(int k = 0;k<9;k++){
                board[i][j] = nums[k];
                if(isValidSudoku(board) && // 本次填充是否有效
                solve(board)) { // 下次填充是否有效，无效，则同步本次也无效，需要继续更换本次填充
                    return true;
                }else{
                    board[i][j] = '.' ;
                }
                
            }
            if (board[i][j]  == '.') {
                // 代表没有可选值了
                return false;
            }
        }
    }
    return true;
}
public boolean isValidSudoku(char[][] board) {
    int[] rows,cols,squares;
    for(int i = 0;i<9;i++){
        rows = new int[9];cols=new int[9];squares = new int[9];
        for(int j=0;j<9; j++){
            // 同行校验 [i][j]
            if(!isValidArrays(board[i][j], rows)) return false;
            // 同列校验 [j][i]
            if(!isValidArrays(board[j][i], cols)) return false;
            // 3x3格校验 [3*(i/3)+j/3][3*(i%3)+j%3]
            if(!isValidArrays(board[3*(i/3)+j/3][3*(i%3)+j%3], squares)) return false;
        }
    }
    return true;
}

public boolean isValidArrays(char ch,int[] nums){
    if (ch == '.')  return true;
    if (nums[ch-49] == ch)  return false;
    nums[ch-49] = ch;
    return true;
}
```

* 改进版：
  * 每次填充过滤行、列、格已存在的，避免重复填充无效值
```java
public void solveSudoku(char[][] board) {
    char[] nums = {'1','2','3','4','5','6','7','8','9'};
    solveSudoku(board,nums,0,0);
}
public boolean solveSudoku(char[][] board,char[] nums,int i,int j){
    if (j == 9) { // 当列索引j等于9时，代表列溢出，换到下一行开头
        i++;j = 0;
    }
    if (i == 9) return true; // 填充完毕
    if (board[i][j]!='.') return solveSudoku(board, nums, i, j+1);
    Set<String> exist = new HashSet<>();  // 统计其它位置已经存在的值
    for (int k = 0; k < 9; k++) {
        if (board[i][k] != '.') exist.add(String.valueOf(board[i][k])); // 同行
        if (board[k][j]!='.') exist.add(String.valueOf(board[k][j])); // 同列
        
        int tmpi = 3*(i/3)+(k)/3,tmpj = (k%3) + 3*(j/3); // 同格范围计算
        if (board[tmpi][tmpj] != '.') exist.add(String.valueOf(board[tmpi][tmpj])); // 因按行顺序填充，故九宫格的范围应以列为主
    }
    for(int k = 0;k<9;k++){
        if (exist.contains(String.valueOf(nums[k]))){
            continue;
        }
        board[i][j] = nums[k];
        if(solveSudoku(board,nums,i,j + 1)) {
            return true; // 只要没有false返回即代表一致填充到最后，直至成功
        }else{
            board[i][j] = '.' ;
        }
    }
    return false; // 默认返回false，避免未考虑的异常情况
}
```
* 官方(升级版)：
  * 按位判断是否互斥
```java
private final int[] rowMask = new int[9],colMask = new int[9],boxMask = new int[9],empties = new int[81];
private int emptyCount = 0;
public void solveSudoku(char[][] board) {
    for (int r = 0; r < 9; r++) {
        for (int c = 0; c < 9; c++) {
            char ch = board[r][c];
            if (ch == '.') empties[emptyCount++] = r * 9 + c;
            else {
                int d = ch - '1',bit = 1 << d;
                rowMask[r] |= bit;
                colMask[c] |= bit;
                boxMask[boxIndex(r, c)] |= bit;
            }
        }
    }
    dfs(board, 0);
}
private boolean dfs(char[][] board, int k) {
    if (k == emptyCount) return true; // solved
    int bestIdx = k,bestChoicesMask = 0,bestChoicesCount = 10;
    for (int i = k; i < emptyCount; i++) {
        int pos = empties[i];
        int r = pos / 9, c = pos % 9, b = boxIndex(r, c);
        int used = rowMask[r] | colMask[c] | boxMask[b];
        int choices = (~used) & 0x1FF;              // 9 bits
        int cnt = Integer.bitCount(choices);
        if (cnt < bestChoicesCount) {
            bestChoicesCount = cnt;
            bestChoicesMask = choices;
            bestIdx = i;
            if (cnt == 1) break;
        }
        if (cnt == 0) return false;
    }
    swap(empties, k, bestIdx);
    int pos = empties[k];
    int r = pos / 9, c = pos % 9, b = boxIndex(r, c);
    int choices = bestChoicesMask == 0
            ? ((~(rowMask[r] | colMask[c] | boxMask[b])) & 0x1FF)
            : bestChoicesMask;
    while (choices != 0) {
        int bit = choices & -choices;                  // isolate lowest 1 bit
        int d = Integer.numberOfTrailingZeros(bit);    // 0..8 for digit 1..9
        place(board, r, c, b, d, bit);
        if (dfs(board, k + 1)) return true;
        unplace(board, r, c, b, d, bit);
        choices -= bit;                                // next candidate
    }
    swap(empties, k, k); 
    return false;
}
private void place(char[][] board, int r, int c, int b, int d, int bit) {
    board[r][c] = (char) ('1' + d);
    rowMask[r] |= bit;
    colMask[c] |= bit;
    boxMask[b] |= bit;
}
private void unplace(char[][] board, int r, int c, int b, int d, int bit) {
    board[r][c] = '.';
    rowMask[r] ^= bit;
    colMask[c] ^= bit;
    boxMask[b] ^= bit;
}
private static int boxIndex(int r, int c) {
    return (r / 3) * 3 + (c / 3);
}
private void swap(int[] a, int i, int j) {
    int t = a[i]; a[i] = a[j]; a[j] = t;
}
```

# 38 报数序列(中)
    The count-and-say sequence is a sequence of digit strings defined by the recursive formula:
    
    Run-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string "3322251" we replace "33" with "23", replace "222" with "32", replace "5" with "15" and replace "1" with "11". Thus the compressed string becomes "23321511".
    
    Given a positive integer n, return the nth element of the count-and-say sequence.

* 约束
  * `1 <= n <= 30`
* 思路
  * 使用递归先获取前一个的结果，再通过结果进行压缩
```java
public String countAndSay(int n) {
    if(n == 1) return "1";
    if(n == 2) return "11";
    String content = countAndSay(n-1);
    char pre = '0';int count = 0;
    StringBuilder sb = new StringBuilder();
    for(int i = 0;i<content.length();i++){
        if(content.charAt(i) != pre){
            if(pre != '0') sb.append(count).append(pre);
            count = 1;pre = content.charAt(i);
        }else{
            count +=1;
        }
    }
    if (count>0) {
        sb.append(count).append(pre);
    }
    return sb.toString();
}
```
# 39 组合总和(中)
    Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.

    The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at each candidate number is different.

    The test cases are generated such that the number of unique combinations that sum to target is less than 150 combinations for the given input.

* 约束
  * `1 <= candidates.length <= 30`
  * `1 <= candidates[i] <= 200`
  * `candidates` contains distinct elements.
  * `1 <= target <= 500`

* 思路
  * 对数组排序
  * 当当前值大于目标值，则终止
  * 使用回溯算法，将余数当作新目标值，递归获取结果
  * 对结果进行去重
```java
public List<List<Integer>> combinationSum(int[] candidates, int target) {
    Arrays.sort(candidates); // 对candidates排序，便于递归逻辑中终止
    Set<Integer> set = Arrays.stream(candidates).boxed().collect(Collectors.toSet());
    Map<Integer,List<List<Integer>>> map = new HashMap<>();
    return combinationSum(candidates,set,map,target);
}

public List<List<Integer>> combinationSum(int[] candidates,Set<Integer> set,Map<Integer,List<List<Integer>>> map, int target) {
    Set<List<Integer>> result = new HashSet<>(); // 结果去重，避免重复
    for (int i = 0; i < candidates.length; i++) {
        int cur = candidates[i];
        if (cur>target) { // 因以排序，所以后续的数肯定大于target
            break;
        }
        int quote = target/cur,remain = target % cur;
        while (quote > 0) {
            if (remain == 0) { // 代表整除
                List<Integer> tmp = new ArrayList<>();
                for (int j = 0; j < quote; j++) tmp.add(cur);
                result.add(tmp);
            }else { // 代表非整除,对余数进行递归
                List<List<Integer>> remainResult;
                if (map.containsKey(remain)) { // map避免同值重复递归
                    remainResult = map.get(remain);
                }else{
                    remainResult = combinationSum(candidates,set,map,remain); // 结果一定不为空，因result已经初始化
                    map.put(remain,remainResult);
                }
                for (List<Integer> list : remainResult) {
                    List<Integer> tmp = new ArrayList<>(list);
                    for (int j = 0; j < quote; j++) tmp.add(cur);
                    tmp.sort((t1,t2)->t1-t2);
                    result.add(tmp);
                }
            }
            // 对商减一，对余数追加，进行下一轮循环
            quote--;remain+=cur;
        }
    }
    return result.stream().collect(Collectors.toList());
}
```
* **改进版**(官方)
  * 直接使用目标值减去当前值，做递归循环，直到
    * 目标值为0，代表可以被整除
    * 起始索引不小于数组长度，代表遍历结束
```java
public List<List<Integer>> combinationSum(int[] candidates, int target) {
    List<List<Integer>> result = new ArrayList<>();
    Arrays.sort(candidates); // 对candidates排序，便于递归逻辑中终止
    combinationSum(candidates,result,new ArrayList<>(),0,target);
    return result;
}

public void combinationSum(int[] candidates,List<List<Integer>> result,List<Integer> curr,int idx, int target) {
    if (target == 0) { // 当余数为0，代表可以被整除，返回上一层
        result.add(new ArrayList<>(curr)); // 代表数组有效，可将数组加入结果集中
        return;
    }
    for (int i = idx; i < candidates.length; i++) { // 当起始位置溢出时，代表已经遍历完，返回上一层
        int cur = candidates[i];
        if (cur>target) break; // 因以排序，所以后续的数肯定大于target
        curr.add(cur); // 将当前值加入当前数组中
        combinationSum(candidates,result,curr,i,target-cur);// 递归余数
        curr.remove(curr.size()-1); // 移除当前值,继续下一轮循环
    }
}
```
* **官方最优版**
  * 因为是返回一个抽象数组，初始化时不会执行逻辑
  * 仅在对结果内容获取时，才会执行逻辑，故而执行逻辑不会耗时(**耗时逻辑在结果调用时**)
```java
public List<List<Integer>> combinationSum(int[] candidates, int target) {
    return new AbstractList<List<Integer>>() {
        List<List<Integer>> ret;
        ArrayList<Integer> curr;
        void init() {
            if (ret != null) {
                return;
            }
            ret = new LinkedList<>();
            curr = new ArrayList<>();
            Arrays.sort(candidates);
            rec(candidates, 0, target);
        }
        @Override
        public List<Integer> get(int index) {
            init();
            return ret.get(index);
        }
        @Override
        public int size() {
            init();
            return ret.size();
        }
        void rec(int[] candidates, int idx, int target) {
            if (target == 0) {
                ret.add(new ArrayList<>(curr));
                return;
            }
            for (int i = idx; i < candidates.length; i++) {
                int num = candidates[i];
                if (num > target) {
                    break;
                }
                curr.add(num);
                rec(candidates, i, target - num);
                curr.remove(curr.size() - 1);
            }
        }
    };
}
```

# 40 组合总和 II(中)
    Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. 
    
    Each number in candidates may only be used once in the combination.

    Note: The solution set must not contain duplicate combinations.

* **约束**
  * `1 <= candidates.length <= 100`
  * `1 <= candidates[i] <= 50`
  * `1 <= target <= 30`

* **思路**
  * 对[39题](#39-组合总和中)的改进，增加去重逻辑
  * **先排序，后处理**
  * 从左向右开始循环
    * 若当前值等于结果，则代表找到一个结果，将结果加入结果集
    * 若当前值和前一个值相同，则代表会重复，跳过(**重点**，`if (i > idx && cur == candidates[i - 1]) continue;`)
    * 若大于结果，则结果减去当前值作为下一个递归的结果值
* **改进**
  * 返回自定义`AbstractList`实现类，并且只在获取数据时进行逻辑处理，避免耗时
```java
public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    List<List<Integer>> result = new ArrayList<>();
    Arrays.sort(candidates); // 对candidates排序，便于递归逻辑中终止
    combinationSum2(candidates,result,new ArrayList<>(),0,target);
    return result;
}
public void combinationSum2(int[] candidates,List<List<Integer>> result,List<Integer> curr,int idx, int target) {
    // if(target<0) return; // for循环中的if (cur>target) break;已经可以过滤小于0
    if (target == 0) { // 当余数为0，代表可以被整除，返回上一层
        result.add(new ArrayList<>(curr)); // 代表数组有效，可将数组加入结果集中
        return;
    }
    for (int i = idx; i < candidates.length; i++) { // 当起始位置溢出时，代表已经遍历完，返回上一层
        int cur = candidates[i];
        if (cur>target) break; // 因以排序，所以后续的数肯定大于target
        if (i > idx && cur == candidates[i - 1]) continue; // 去重，当当前值与上一个值相等时，跳过,
        curr.add(cur); // 将当前值加入当前数组中
        combinationSum2(candidates,result,curr,i+1,target-cur);// 递归余数
        curr.remove(curr.size()-1); // 移除当前值,继续下一轮循环
    }
}

// 改进版
public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    return new AbstractList<List<Integer>>() {
        List<List<Integer>> ret;
        ArrayList<Integer> curr;
        Set<String> set = new HashSet<>();
        void init() {
            if (ret != null) {
                return;
            }
            ret = new LinkedList<>();
            curr = new ArrayList<>();
            Arrays.sort(candidates);
            rec(candidates, 0, target);
        }
        @Override
        public List<Integer> get(int index) {
            init();
            return ret.get(index);
        }
        @Override
        public int size() {
            init();
            return ret.size();
        }
        void rec(int[] candidates, int idx, int target) {
            if (target == 0) {
                String key = curr.stream().map(String::valueOf).collect(Collectors.joining("-"));
                if (!set.contains(key)){
                    ret.add(new ArrayList<>(curr));
                    set.add(key);
                }
                return;
            }
            for (int i = idx; i < candidates.length; i++) {
                int num = candidates[i];
                if (num > target) break;
                if (i > idx && num == candidates[i - 1]) continue; // 去重，当当前值与上一个值相等时，跳过,重点
                curr.add(num);
                rec(candidates, i+1, target - num);
                curr.remove(curr.size() - 1);
            }
        }
    };
}
```
# 41 缺失的第一个正数(难)
    Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.

    You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.

* 约束
  * `1 <= nums.length <= 5 * 10^5`
  * `-2^31 <= nums[i] <= 2^31 - 1`
* 思路
  * 先排序，后处理
  * 非正整数统统过滤
  * 从1开始对比，向等继续+1对比，
    * 至大于对比数或至数组结束终止
```java
public int firstMissingPositive(int[] nums) {
    Arrays.sort(nums);
    int pos = 1;
    for(int i=0;i<nums.length;i++){
        if(nums[i]<=0) continue;
        if(nums[i]>pos) break;
        if(nums[i] == pos) pos++;
    }

    return pos;
}
```
* 官方最优解
  * 过滤非正整数
  * 理论情况应为连续正整数，将小于等于数组长度count的值置为负数，最后找到第一个正整数，返回其下标+1
  * 注意：不能直接将值置为负数，因为负数可能已经置为负数，所以需要取绝对值
```java
public int firstMissingPositive(int[] nums) {
    int size = nums.length;
    int count= 0;
    for(int i=0;i<size;i++){ // 过滤非正整数，有效正整数个数为count
        if(nums[i]>0){
            nums[count] = nums[i];
            count++;
        }
    }
    for(int i=0;i<count;i++){ // 将正整数小于count的值置为负数，理论情况下，count个数都转为负
        int val = Math.abs(nums[i]);
        if(val - 1 < count && nums[val - 1]>0){ 
            nums[val - 1] = -nums[val-1];
        }
    }
    for(int i=0;i<count;i++){
        if(nums[i]>0){ // 找到第一个正整数，返回其下标+1
            return i+1;
        }
    }
    return count + 1; 
}
```
# 42. Trapping Rain Water(困难)
    Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

* **约束**
  * `n == height.length`
  * `0 <= n <= 3 * 10^4`
  * `0 <= height[i] <= 10^5`
* **思路**： [参考11题](#11-最大水量中)
  * 从前后向中间遍历
  * 记录每一边的最大水量
  * 水增量为边最大值-当前值
    * 若左边最大值小于右边最大值，则水量增量为左边最大值-当前值
    * 若右边最大值小于左边最大值，则水量增量为右边最大值-当前值
```java
public int trap(int[] height) {
    int left = 0;
    int right = height.length - 1;
    int leftMax = height[left];
    int rightMax = height[right];
    int water = 0;

    while (left < right) {
        if (leftMax < rightMax) {
            left++;
            leftMax = Math.max(leftMax, height[left]);
            water += leftMax - height[left]; // 若当前为最大值，则水增量为0，若当前非最大值，则差值即为水增量
        } else {
            right--;
            rightMax = Math.max(rightMax, height[right]);
            water += rightMax - height[right];
        }
    }

    return water;        
}
```
# 43. Multiply Strings(中等)
    Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.

    Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.

* **约束**
  * `1 <= num1.length, num2.length <= 200`
  * `num1` and `num2` consist of digits only.
  * Both `num1` and `num2` do not contain any leading zero, except the number 0 itself.
* **思路**
  * 指定一个数字字符串为乘数
  * 循环乘数，从右侧开始
    * 将乘数与被乘数相乘，得到当前位的结果(需要以字符串为结果，**注意进位**)
    * 将当前位的积与前一位的进位相加，得到当前位的最终结果
    * 记录当前结果的余数，并重新计算进位
  * 当循环完成，若进位仍存在，则记录
  * 最终结果倒序
  * 提示：
    * 使用`StringBuilder`记录结果
    * 在算术运算结果记录时默认以**倒序**方式处理，
    * 最终结果使用`StringBuilder#reverse()`方法**倒序(变正序)**
* **改进**
  * 使用`int[]`**存储同位的积**，以两边长度和为总长度(**两数积最小长度为位数和-1，最大为位数和**)
  * 分别**从右向左**开始计算，**同位积相加**(**`i+j`结果等同的代表同位积**)
  * 同位积计算完后，遍历数组，从右向左`i=arr.length-1`
    * 当前位取余
    * 前一位`i-1`加当前位`i`的进位(取商)
  * **将数组读取为字符串**
    * 判断数组第一位是否为0，若为0，则从第二位开始(代表积为最小长度)
```java
private static String ZERO_STR = "0";
private static char ZERO_CHAR = '0';
public String multiply(String num1, String num2) {
    if(ZERO_STR.equals(num1) || ZERO_STR.equals(num2)) return ZERO_STR;
    StringBuilder sb = new StringBuilder();
    StringBuilder tmp = new StringBuilder();
    String carry = ZERO_STR; // 倒序
    for (int i = num2.length()-1; i >=0; i--) {
        String sum = sum(num1,num2.charAt(i)-ZERO_CHAR,tmp) ; //倒序
        sum = sum(sum,carry,tmp); // 最终当前位的乘积
        sb.append(sum.charAt(0)); // 取余
        carry = sum.substring(1,sum.length()); // 取进位 (number)sum/10
    }
    if (!ZERO_STR.equals(carry)) sb.append(carry);
    return sb.reverse().toString(); // 只在最后结果进行倒序转正序
}

public String sum(String num,String carryTmp,StringBuilder sb) { // 当前位的乘积 + 前一位的进位数
    if (ZERO_STR.equals(carryTmp)) return num; // 代表无需进位
    if (carryTmp.length()>num.length()) { // 置换，以最长的为加法循环次数
        String tmp = num;
        num = carryTmp;
        carryTmp = tmp;
    }
    sb.delete(0, sb.length());
    int carry = 0,j = 0;
    for (int i = 0; i <num.length(); i++) {
        int sum = num.charAt(i)-ZERO_CHAR + carry;
        if(j<carryTmp.length()) sum +=carryTmp.charAt(j++)-ZERO_CHAR;
        carry = sum/10;
        sb.append(sum%10);
    }
    if (carry >0) sb.append(carry);
    return sb.toString();
}
public String sum(String num1,int num2,StringBuilder sb) { // 当前位的乘积
    sb.delete(0, sb.length());
    int carry = 0;
    for (int i = num1.length()-1; i >=0; i--) {
        int sum = (num1.charAt(i)-ZERO_CHAR)*num2 + carry;
        carry = sum/10;
        sb.append(sum%10);
    }
    if (carry >0) sb.append(carry);
    return sb.toString();
}


// 改进版
private static String ZERO_STR = "0";
private static char ZERO_CHAR = '0';
public String multiply(String num1, String num2) {
    if(ZERO_STR.equals(num1)||ZERO_STR.equals(num2)) return ZERO_STR;

    int len1 = num1.length(),len2 = num2.length();
    int[] res = new int[len1+len2];
    for(int i = len1-1;i>=0;i--){
        int n1 = num1.charAt(i)- ZERO_CHAR;
        for(int j = len2-1;j>=0;j--){
            int n2 = num2.charAt(j)- ZERO_CHAR;
            res[i+j+1] += n1*n2;   // 同位计算结果，例如123，456 ，计算十位  2*6 + 3*5，计算百位 1*6 + 2*5 + 3*4
        }
    }

    for(int i = res.length-1;i>0;i--){
        res[i-1] += res[i]/10;
        res[i] %= 10;
    }
    int startIndex = res[0]==0?1:0;

    StringBuilder sb = new StringBuilder();
    for(int i = startIndex;i<res.length;i++){
        sb.append(res[i]);
    }
    return sb.toString();
}
```
# 44. Wildcard Matching(困难)
    Given an input string (s) and a pattern (p), implement wildcard matching with support for '?' and '*' where:

    '?' Matches any single character.
    '*' Matches any sequence of characters (including the empty sequence).
    The matching should cover the entire input string (not partial).

* **约束**
  * `0 <= s.length，p.length <= 2000`
  * `s` only contains lowercase English letters.
  * `p` contains only lowercase English letters, '?' or '*'.
* **思路**: [参考10题](#10-正则表达式匹配)
  * 由`.`改为`?`
  * `*`可匹配任意字符串，包括空字符串
  * 支持多个通配符相连，如`***`
* **改进**：类似**滑动窗口(匹配子串)**，但本例是**全局匹配**
  * 遇到`*`时，记录当前匹配的起始位置，并记录当前`*`的索引
  * 当后续匹配失败时，回退到`*`的下一个位置，继续匹配
```java
// 超时
public boolean isMatch(String s, String p) {
    p=p.replaceAll("[\\*]+", "*"); // 多个*合并为一个*
    return checkMatch(s,p,s.length()-1,p.length()-1);
}
private boolean checkMatch(String s,String p,int sidx,int pidx){
    if(sidx <0 && pidx <0) return true;
    else if(sidx <0 && pidx >=0){
        if(p.charAt(pidx) == '*') return checkMatch(s,p,sidx,pidx-1);
        else return false;
    }else if(pidx <0) return false;

    // sidx>=0 && pidx>=0
    if(p.charAt(pidx) == '*'){
        if(pidx==0) return true;
        if(p.charAt(pidx-1) == s.charAt(sidx) || p.charAt(pidx-1) == '?'|| p.charAt(pidx-1) == '*'){
            return checkMatch(s,p,sidx,pidx-1) || checkMatch(s,p,sidx-1,pidx);
        }else{
            return checkMatch(s,p,sidx-1,pidx);
        }
    }else if (p.charAt(pidx) == s.charAt(sidx) || p.charAt(pidx) == '?'){
        return checkMatch(s,p,sidx-1,pidx-1);
    }
    return false;
}

// 改进版
public boolean isMatch(String s, String p) {
    int sIdx = 0, pIdx = 0, starIdx = -1, match = 0;
    while (sIdx < s.length()) {
        if (pIdx < p.length() && (p.charAt(pIdx) == '?' || p.charAt(pIdx) == s.charAt(sIdx))) { // 正常单字母匹配
            sIdx++;
            pIdx++;
        }else if (pIdx < p.length() && p.charAt(pIdx) == '*') { // 字符串匹配任意字符
            starIdx = pIdx;
            match = sIdx;
            pIdx++;
        }else if (starIdx != -1) { // 当字母不匹配时，并且前一个字符是*，则回溯到*的位置，继续匹配
            pIdx = starIdx + 1;
            match++;
            sIdx = match;
        }else return false; // 字母不匹配，并且前一个字符不是*，则匹配失败
            
    }
    // 当p长度大于s时，p剩余的字符必须是*
    while (pIdx < p.length() && p.charAt(pIdx) == '*') pIdx++;
    return pIdx == p.length();
}
```
# 45. Jump Game II(中等)
    Given an array of non-negative integers nums, you are initially positioned at the first index of the array.

    Each element in the array represents your maximum jump length at that position.

    Your goal is to reach the last index in the minimum number of jumps.

    You can assume that you can always reach the last index.

* **约束**
  * `1 <= nums.length <= 3 * 10^4`
  * `0 <= nums[i] <= 10^5`
* **思路**
  * 在当前位置到当前最大跳跃位置之间寻找超过下一个超过当前最大跳跃位置的位置
  * 即，下一步都尽可能的跳超过当前最大跳跃位置
```java
public int jump(int[] nums) {
    int n = nums.length;
    if(n== 1 || nums[0] == 0) return 0; // 1个元素或0步
    int minSteps = 0,curPos = 0;
    while(curPos<n){
        int maxPos = curPos+nums[curPos];
        if(maxPos >= n-1) return minSteps+1; // over n ,return steps+1
        int nextPos = 0,nextMaxPos = maxPos;
        for(int i=curPos+1 ;i<=maxPos;i++){
            if( nums[i] + i > nextMaxPos){
                nextMaxPos = nums[i] + i;
                nextPos = i;
            }
        }
        if(nextPos>0){ // exsit next step jump max position more than current jump max position
            curPos = nextPos;
            minSteps++;
        }
    }
    return minSteps;
}
```

# 46. Permutations(中等)
    Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.

* **约束**
  * `1 <= nums.length <= 6`
  * `-10 <= nums[i] <= 10`
  * All the integers of nums are unique.
* **思路**:**回溯法**，寻找所有可能
  * 步骤：
    * 使用`Set`记录当前已使用过的元素
    * 每次递归循环都从`0`开始验证，若当前元素已使用过，跳过
    * 若当前元素未使用过，则添加到当前`Set`中，递归下一个位置搜索
    * 每次递归结束返回后，移除当前元素，继续匹配下一个元素为当前位置元素
    * 当搜索位置与数量一致，代表遍历结束，保存当前结果，并推出
  * **注意**：`Set`使用`LinkedHashSet`，保证结果顺序
    * 不能使用`HashSet`，底层使用`HashMap`会对key进行hash排序
* **改进**
  * 不追加过多集合属性，直接使用原生数组+一个新的值长数组
  * 将索引值进行交换(需判断是否交换过)，即可代表顺序变更
* **加速**：纯为了Leetcode调用加速，自定义实现`AbstractList`，将逻辑放到数据读取时处理
```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    Set<Integer> curr = new LinkedHashSet<>();
    permute(nums, 0, res, curr);
    return res;
}
public void permute(int[] nums, int index, List<List<Integer>> res,Set<Integer> curr) {
    if (index == nums.length) {
        res.add(new ArrayList<>(curr));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        int num = nums[i];
        if (curr.contains(num)) continue; // 待改进项，这一步会递归重复，可优化
        curr.add(num);
        permute(nums, index+1, res, curr);
        curr.remove(num);
    }
}

// 官方版
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    permute(nums, res, 0);
    return res;
}
public void permute(int[] nums, List<List<Integer>> res,int index ) {
    if (index == nums.length) {
        List<Integer> cur = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            cur.add(nums[i]);
        }
        res.add(cur);
        return;
    }
    boolean[] use = new boolean[21]; // 因值范围为-10-10，故最大长度为21
    for (int i = index; i < nums.length; i++) {
        if(!use[nums[i]+10]){
            use[nums[i]+10] = true;
            // 与交换index位置
            exch(nums,i,index);
            permute(nums, res, index+1);
            // 与index位置再交换回来
            exch(nums,i,index);
        }
    }
}
public void exch(int[] nums,int i,int j){
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

// 加速
public List<List<Integer>> permute(int[] nums) {
    return new AbstractList<List<Integer>>() {
        private List<List<Integer>> res;
        void init(){
            if(res != null) return;
            res = new ArrayList<>();
            permute(0);
        }
        @Override
        public List<Integer> get(int index) {
            init();
            return res.get(index);
        }

        @Override
        public int size() {
            init();
            return 0;
        }
        void permute(int index ) {
            if (index == nums.length) {
                List<Integer> cur = new ArrayList<>();
                for (int i = 0; i < nums.length; i++) {
                    cur.add(nums[i]);
                }
                res.add(cur);
                return;
            }
            boolean[] use = new boolean[21]; // 因值范围为-10-10，故最大长度为21
            for (int i = index; i < nums.length; i++) {
                if(!use[nums[i]+10]){
                    use[nums[i]+10] = true;
                    exch(nums,i,index); // 与交换index位置
                    permute(index+1);
                    exch(nums,i,index); // 与index位置再交换回来
                }
            }
        }
        void exch(int[] nums,int i,int j){
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    };
}
```

# 47. Permutations II(中等)
    Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.

* **约束**
  * `1 <= nums.length <= 8`
  * `-10 <= nums[i] <= 10`
* **思路**：**回溯法**，寻找所有可能,与[46题](#46-permutations中等)类似，只是需要处理重复元素
  * 验证是否已添加过值改为索引校验
  * 只在添加结果时，根据索引值取出值
  * 增加一个记录结果已被记录的`Set`，避免重复添加相同结果：根据结果值做`key`
  * 使用`StringBuilder`构建`key`
* **改进**：逻辑和[46题](#46-permutations中等)一致
* **加速**: 同理自定义实现`AbstractList`，逻辑和[46题](#46-permutations中等)一致
```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    Set<Integer> curr = new LinkedHashSet<>();
    permute(nums, 0, res, curr,new HashSet<>());
    return res;
}

public void permute(int[] nums, int index, List<List<Integer>> res,Set<Integer> curr,Set<String> keys) {
    if (index == nums.length) {
        List<Integer> cur = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        for(int i:curr){
            sb .append(nums[i]).append(",");
            cur.add(nums[i]);
        }
        String key = sb.toString();
        if (keys.contains(key))  return;
        keys.add(key);
        res.add(new ArrayList<>(cur));
        return;
    }
    
    for (int i = 0; i < nums.length; i++) { 
        if (curr.contains(i)) continue; // 此步骤允许重复
        curr.add(i);
        permute(nums, index+1, res, curr,keys);
        curr.remove(i);
    }
}

// 改进版
public List<List<Integer>> permuteUnique(int[] nums) {
    List<List<Integer>> ans = new ArrayList<>();
    permuteUnique(nums, ans, 0);
    return ans;
}
public void permuteUnique(int[] nums, List<List<Integer>> ans, int idx) {
    if (idx == nums.length) {
        ArrayList<Integer> row = new ArrayList<>();
        for (int num : nums) {
            row.add(num);
        }
        ans.add(row);
        return;
    }

    boolean[] use = new boolean[21];
    for (int i = idx; i < nums.length; i++) {
        // swap
        if (!use[nums[i] + 10]) {

            use[nums[i] + 10] = true;

            int temp = nums[i];
            nums[i] = nums[idx];
            nums[idx] = temp;
            permuteUnique(nums, ans, idx + 1);
            int temp2 = nums[i];
            nums[i] = nums[idx];
            nums[idx] = temp2;
        }
    }
}
```

# 48. Rotate Image(中等)
    You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).

    You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

* **约束**
* `1 <= matrix.length <= 5`
* `matrix[i].length == matrix.length`
* `-1000 <= matrix[i][j] <= 1000`
* **思路**：**矩阵旋转**，将矩阵分为四个象限，分别旋转
  * 算法规则：`(i,j)->(j,n--1-i)`
  * 方式一(基本实现)：提供辅助新数组，遍历赋值，然后将新数组值覆盖原数组
    * 提供辅助数组
    * 两次双循环
  * 方式二：提供辅助判断数组，直接在原数组上操作交换
    * 提供辅助数组
    * 单循环
* **官方其它解法**：对角线反转，再左右反转（**推荐**）
  * **容易理解**
  * 无辅助数组(**空间效率高**)
  * 两次双半循环(内部平均循环n/2次)(**性能差异不大**)
```java
// 基本实现
public void rorate(int[][] matrix){
    int n = matrix.length,idx=n-1;
    int[][] res = new int[n][n];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            res[j][idx-i] = matrix[i][j];
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++)
            matrix[i][j] = res[i][j];
    }
}
// 方式二
public void rotate(int[][] matrix){
    int n = matrix.length,idx=n-1; // 定义数组长度，数组索引最大值
    boolean[][] bs = new boolean[n][n]; // 判断位置是否已处理
    int i=0,j=0,cur = -1001; // 定义的默认值要超出值范围，否则容易冲突
    while(i<n && j<n){
        if(bs[i][j]){ // 若位置已处理，则处理下一个元素
            j = j==idx?++i:j+1; // 当j到达数组末位时，另起一行,由于是从外向内，故j=i
            cur = -1001; // 外层循环结束，cur重新赋值默认值
            continue;
        }
        if(cur == -1001) cur = matrix[i][j];// 若curr 为默认值，则赋值为当前元素
        bs[i][j] = true; // 标记位置已处理
        // 将i,j 按照规则(i,j)->(j,idx-i)进行索引转换
        int k = j; 
        j = idx-i;
        i = k;
        int tmp = matrix[i][j]; // 记录被替换的值
        matrix[i][j] = cur; // 将当前值赋值给被替换的位置
        cur = tmp; // 将当前值赋值给cur
    }
}

// 官方其他版
public void rotate(int[][] matrix) {
    int n = matrix.length;
    for(int i = 0;i<n;i++)
    {
        for(int j = i + 1;j<n;j++)
        {
            // 延左上到右下对角线翻转
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
    for(int i = 0;i<n;i++)
    {
        for(int j = 0;j<n/2;j++)
        {  
            // 延每一行中间位置翻转
            int temp = matrix[i][j];
            matrix[i][j] = matrix[i][n-1-j];
            matrix[i][n-1-j] = temp;
        }
    }
}
```

# 49. Group Anagrams(中等)
    Given an array of strings strs, group the anagrams together. You can return the answer in any order.

    An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

* **约束**
  * `1 <= strs.length <= 10^4`   
  * `0 <= strs[i].length <= 100`
  * `strs[i]` consists of lowercase English letters.
* **思路**
  * 循环数组
    * 获取当前字符，根据字符从小到大排序，并根据其次数组成`key`
    * 将当前字符存入map相同key的values中
  * 遍历map：将values存入ans中
* **改进**
  * 直接将`String`转`char[]`
  * 使用`Arrays.sort`对`char[]`排序
  * 使用`map.computeIfAbsent`，对**缺失key进行初始化**
  * 在**map初始化缺失key时**，将结果也同步加入结果集中(**引用类型**)
* **加速**：针对Leetcode加速，自定义实现`AbstractList`，将逻辑放入读取数据时
```java
public List<List<String>> groupAnagrams(String[] strs) {
    List<List<String>> ans = new ArrayList<>();
    Map<String, List<String>> map = new HashMap<>();
    for (int i = 0; i < strs.length; i++) {
        String cur = strs[i];
        int[] count = new int[26];
        for (int j = 0; j < cur.length(); j++) {
            count[cur.charAt(j) - 'a']++;
        }
        StringBuilder sb = new StringBuilder();
        for (int j = 0; j < 26; j++) {
            if (count[j] != 0) {
                sb.append((char)('a' + j));
                sb.append(count[j]);
            }
        }
        String key = sb.toString();
        List<String> list = map.getOrDefault(key, new ArrayList<>());
        list.add(cur);
        map.put(key, list);
    }
    for (List<String> list : map.values()) {
        ans.add(list);
    }
    return ans;
}

// 改进版
public List<List<String>> groupAnagrams(String[] strs) {
    List<List<String>> ans = new ArrayList<>();
    Map<String, List<String>> map = new HashMap<>();
    for(String str:strs){
        char[] chars = str.toCharArray();
        Arrays.sort(chars);
        map.computeIfAbsent(new String(chars), k->{
            List<String> list = new ArrayList<>();
            ans.add(list);
            return list;
        }).add(str);
    }
    return ans;
}


// 加速版
public List<List<String>> groupAnagrams(String[] strs) {
    return new AbstractList<List<String>>(){
        List<List<String>> ans;
        Map<String, List<String>> map;
        void init(){
            if(ans != null) return;
            ans = new ArrayList<>();
            map = new HashMap<>();
            groupAnagrams();
        }
        @Override
        public List<String> get(int index) {
            init();
            return ans.get(index);
        }

        @Override
        public int size() {
            init();
            return ans.size();
        }
        void groupAnagrams(){
            for(String str:strs){
                char[] chars = str.toCharArray();
                Arrays.sort(chars);
                map.computeIfAbsent(new String(chars), k->{
                    List<String> list = new ArrayList<>();
                    ans.add(list);
                    return list;
                }).add(str);
            }
        }
    };
}
```

# 50. Pow(x, n)(中等)
    Implement pow(x, n), which calculates x raised to the power n (i.e., xn).

* **约束**
  * `-100.0 < x < 100.0`
  * `-2^31 <= n <= 2^31 - 1`
  * `-10^4 <= xn <= 10^4`
* **思路**：没解除完整
* **改进**
  * `int*double`不等于`double*double`
  * `Integer.MIN_VALUE`取绝对值会导致溢出，需转换成double类型
```java
// 执行错误
public double myPow(double x, int n) {
    int nn = n;
    if(n<0){
        n = -n;
    }
    double xr = 1;
    for (int i = 0; i < n; i++) {
        xr *=x;
    }
    return nn<0?1/xr:xr;
}

// 改进
public double myPow(double x, int n) {
    double ans=1,nn = n;
    
    if(nn<0) nn=-1*nn; // 取绝对值，若为Integer.MIN_VALUE，会溢出
    
    while(nn>0){
        if(nn%2==0){ // 偶数，两数相乘
            x=x*x; // x^2 每次偶数都代表可以直接平方
            nn=nn/2;
        }else{ // 奇数，乘单次x
            ans= ans*x;
            nn--;
        }
    }
    return (n>=0)? ans: 1/ans; 
}
```

# 51. N-Queens(困难)
    The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.

    Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.

    Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.

* **约束**
  * `1 <= n <= 9`
* **思路**：使用递归方法处理
  * 定义计数器`count`
  * 定义`n*n boolean`数组，记录是否有皇后
  * 当`count==n`时，代表此解有效
  * 当`count<n`时，并且格子遍历完，则代表此解无效
  * 每行从第一列到最后一列依次尝试，若有效则继续下一行，无效则回溯
    * 校验**行，列，对角线**
      * 行不变，列变
      * 行变，列不变
      * 行列同减
      * 行减列加
* **优化**：使用`AbstractList`
* **改进**:
  * 使用默认`n*n`数组,赋值`.`
  * 使用位运算验证是否有效防止皇后
  * 处理下一行时，过滤掉当前列
```java
 public List<List<String>> solveNQueens(int n) {
    List<List<String>> res = new ArrayList<>();
    solveNQueens(n, 0, new boolean[n][n],res, 0);
    return res;
}
public void solveNQueens(int n, int row,boolean[][] flag, List<List<String>> res,int count) {
    if(count >= n){ // 满足条件
        List<String> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j < n; j++) {
                if(flag[i][j]) sb.append("Q");
                else sb.append(".");
            }
            list.add(sb.toString());
        }
        res.add(list);
        return;
    }
    if(row>=n) return; // 当行超出，无效
    int col = 0;
    while(col<n){
        if(!isValid(row,col++, flag)) continue;
        flag[row][col-1] = true; // 当前有效
        solveNQueens(n, row+1, flag, res, count+1); // 换行，继续
        flag[row][col-1] = false; //重置
    }
}
public boolean isValid(int i,int j, boolean[][] flag){
    for(int k 0;k<flag.length;k--){
        if(flag[k][j] || flag[i][k]) return false;
    }

    // 对角线验证
    for(int k1=i,k2=j;k1>=0&&k2>=0;k1--,k2--){
        if(flag[k1][k2]) return false;
    }
    for(int k1=i,k2=j;k1>=0&&k2<flag.length;k1--,k2++){
        if(flag[k1][k2]) return false;
    }
    return true;
}

// 优化版
public List<List<String>> solveNQueens(int n) {
    return new AbstractList<List<String>>() {
        List<List<String>> res;
        char[][] ctx;
        void init(){
            if(res != null) return;
            res = new ArrayList<>();
            ctx = new char[n][n];
            for (char[] r: ctx) Arrays.fill(r, '.');
            solveNQueens(n, 0, 0);
        }
        @Override
        public List<String> get(int index) {
            init();
            return res.get(index);
        }
        @Override
        public int size() {
            init();
            return res.size();
        }
        void solveNQueens(int n, int row,int count) {
            if(count >= n){ // 满足条件
                List<String> list = new ArrayList<>();
                for (char[] r:ctx) list.add(new String(r));
                res.add(list);
                return;
            }
            if(row>=n) return; // 当行超出，无效
            int col = 0;
            while(col<n){
                if(!isValid(row,col++)) continue;
                ctx[row][col-1] = 'Q'; // 当前有效
                solveNQueens(n, row+1, count+1); // 换行，继续
                ctx[row][col-1] = '.'; //重置
            }
        }
        boolean isValid(int i,int j){
            for(int k = i;k>=0;k--){
                if(ctx[k][j] == 'Q' || ctx[i][k] == 'Q') return false;
            }

            // 对角线验证: 左上右下
            for(int k1=i,k2=j;k1>=0&&k2>=0;k1--,k2--){
                if(ctx[k1][k2] == 'Q') return false;
            }
            // 左下右上
            for(int k1=i,k2=j;k1>=0&&k2<ctx.length;k1--,k2++){
                if(ctx[k1][k2] == 'Q') return false;
            }
            return true;
        }
    };
}

// 改进版
public List<List<String>> solveNQueens(int n) {
    List<List<String>> result = new ArrayList<>();
    char[][] board = new char[n][n];
    for (char[] r : board) Arrays.fill(r, '.');

    int mask = (1 << n) - 1; // Only n bits are relevant
    solve(n, 0, 0, 0, 0, mask, board,result);
    return result;
}
/**
 * cols 表示已被占用的列
 * d1 表示已被占用的左对角线
 * d2 表示已被占用的右对角线
 * ~(cols | d1 | d2) 结果取反，得到所有未被占用的位置
 * & mask 与掩码进行按位与操作，确保只考虑有效的位(即 n 位)，否则可能跟系统位数保持一致
 */
private void solve(int n, int row, int cols, int d1, int d2, int mask, char[][] board,List<List<String>> result) {
    if (row == n) {
        List<String> temp = new ArrayList<>();
        for (char[] r : board) temp.add(new String(r));
        result.add(temp);
        return;
    }

    // Get available positions: mask ensures only n bits are considered
    int available = ~(cols | d1 | d2) & mask;

    while (available != 0) {
        // Pick the rightmost available bit
        int pos = available & -available;
        int col = Integer.bitCount(pos - 1);

        // 有效，则放置皇后
        board[row][col] = 'Q';
        // Recurse to the next row
        solve(n, row + 1,cols | pos,(d1 | pos) << 1,(d2 | pos) >> 1,mask,board,result);
        // 回退
        board[row][col] = '.';
        // Remove the used bit
        available &= available - 1;
    }
}
```
# 52. N-Queens II(中等)
    The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.

    Given an integer n, return the number of distinct solutions to the n-queens puzzle.

* **约束**
  * `1 <= n <= 9`
* **思路**:[参考51题](#51-n-queens困难)
```java
public int totalNQueens(int n) {
    char[][] board = new char[n][n];
    for (int i = 0; i < n; i++) Arrays.fill(board[i], '.');
    return backtrack(board, 0, n);
}
private int backtrack(char[][] board, int row, int n) {
    if (row == n) return 1;
    int count = 0;
    for (int col = 0; col < n; col++) {
        if (isValid(board, row, col)) {
            board[row][col] = 'Q'; // 放置皇后
            count += backtrack(board, row + 1, n);
            board[row][col] = '.'; // 回溯
        }
    }
    return count;
}
private boolean isValid(char[][] board, int row, int col) {
    for (int i = 0; i < board.length; i++) {
        if (board[i][col] == 'Q' || board[row][i] == 'q') return false;
    }
    // 检查左上方
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 'Q') return false;
    }
    // 检查右上方
    for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {
        if (board[i][j] == 'Q') return false;
    }
    return true;
}

// 改进版
public int totalNQueens(int n) {
    char[][] board = new char[n][n];
    for (char[] r : board) Arrays.fill(r, '.');
    int mask = (1 << n) - 1; // Only n bits are relevant
    return backtrack(n, 0, 0, 0, 0, mask, board);
}
private int backtrack(int n, int row, int cols, int d1, int d2, int mask, char[][] board) {
    if (row == n) {
        return 1;
    }

    int available = ~(cols | d1 | d2) & mask;
    int count = 0;
    while (available != 0) {
        int pos = available & -available;
        int col = Integer.bitCount(pos - 1);

        // 有效，则放置皇后
        board[row][col] = 'Q';
        // Recurse to the next row
        count +=backtrack(n, row + 1,cols | pos,(d1 | pos) << 1,(d2 | pos) >> 1,mask,board);
        // 回退
        board[row][col] = '.';
        // Remove the used bit
        available &= available - 1;
    }
    return count;
}
```

# 53. Maximum Subarray(简单)
    Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

    A subarray is a contiguous part of an array.

* **约束**
  * `1 <= nums.length <= 3 * 10^4`
  * `-10^5 <= nums[i] <= 10^5`
  * `nums` contains at least one positive number.
* **思路**
  * 分别定义最大和，和当前和最大，当前对比位
  * 默认最大和，当前最大和为头元素
  * 循环数组`(idx<nums.length)`
    * 若`sum<0`
      * 则对比元素是否小于等于sum，则取下一位(没有对比性)
      * 否则取当前元素为当前sum
    * 否则`sum>=0`，进行累加
    * 每次循环，取max,sum最大值最为max
* **简化**
  * 只要sum<0,后面的和都没有必要再和后面的和合并
  * 每次都要对比sum,max取最大值
```java
public int maxSubArray(int[] nums) {
    int idx=0,sum=nums[0],max=nums[0];
    while (++idx<nums.length) {
        int num = nums[idx];
        if(sum<0){ // 若当前和小于0，则比较num，sum
            if(num<=sum){ // 若num比sum还小，后面和没必要再算到当前sum中
                if (idx<nums.length-1) sum = nums[++idx]; // 若下一个元素还存在，则从下一个元素作为新的和
            }else sum = num; // 若num比sum大，则当前sum最大为num
        }else sum+=num; // 若sum小于0，则继续累加
        max = Math.max(max, sum); // 每次处理一个数都要进行max与当前sum比较
    }
    return max;
}
// 简化：只要sum<0,后面的和都没有必要再与其合并；每次都要对比sum,max取最大值
public int maxSubArray(int[] nums) {
    int sum=0,max=nums[0];
    for (int i = 0; i < nums.length; i++) {
        sum+=nums[i];
        max = Math.max(sum, max); // 重点，每次都要对比sum,max取最大值
        if(sum<0) sum=0; // 若sum<0 则代表前面的和没有必要再和后面的和合并
    }
    return max;
}
```

# 54. Spiral Matrix(中等)
    Given an m x n matrix, return all elements of the matrix in spiral order.

* **约束**
  * `m == matrix.length`
  * `n == matrix[i].length`
  * `1 <= m, n <= 10`
  * `-100 <= matrix[i][j] <= 100`
* **思路**
  * 定义层数，及正负方向(正：左右，上下；负：右左，下上)
  * 当负转正时，层数+1
  * 每层位置索引范围`i:l-1,n-l`,`j:l-1,m-l`
  * **结束位点**(**重点**): 由外围大小先行决定
    * 当外围为奇数时，结束方向一定为正(左右)：`i==n/2 && j==m-l`
    * 当外围为偶数时，结束方向一定为负(下上)：`i==n/2 && j==m/2`
* **改进**：**边界限定法**
  * 尝试每处理一周将外围消减(虚拟，限定边界)，直到超出边界，**可读性高**
  * 时间复杂度`O(n/2+m/2)=O(N)` 空间复杂度`O(1)`
```java
public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> res = new ArrayList<>();
    int n = matrix.length,m = matrix[0].length;
    int l = 1; // 右外到内层数
    boolean flag = true; // true 正向 左右，上下；false代表反向 右左，下上
    for(int i=0,j=0;i>=l-1 && i<=n-l && j>=l-1 && j<=m-l;){
        res.add(matrix[i][j]);
        if (flag) {
            if(j<m-l) j++;
            else if(i<n-l) i++;
            else {
                if(n%2==1 && i==n/2 && j==m-l) break; // 外围是奇数时，方向一定是左右，右结束
                j--;
                flag = false;
            }
        }else{
            if(j>l-1) j--;
            else if(i>l) i--;
            else {
                if(n%2==0 && i==n/2 && j==m/2) break; // 外围是偶数时，结束位置一定是在下上，下结束
                j++;
                flag = true;
                l++;
            }
        }
    }
    return res;
}

// 改进版：每处理一周，将外围消减，直到外围为0
public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> res = new ArrayList<>();
    int n = matrix.length,m = matrix[0].length;
    int i = 0,j = 0;
    while(i<n-1 && j< m-1){ // 每次循环会退出外层，内层相当于全新的开始
        // top row
        for(int k = j;k<m;k++){
            res.add(matrix[i][k]);
        }
        i++; // 行数增加，因为最上边已经遍历过了
        // right col
        for(int k = i;k<n;k++){
            res.add(matrix[k][m-1]);
        }
        m--; // 列数消减 ，因为最右边已经遍历过了
        if(i<n){
            for(int k=m;k>=j;k--){ 
                res.add(matrix[n-1][k]);
            }
            n--; // 行数消减，因为最下边已经遍历过了
        }

        if(j<=m){
            for(int k = n;k>=i;k--){
                res.add(matrix[k][j]);
            }
            j++; // 列数增加，因为最左边已经遍历过了
        }
    }
    return res;
}
```
# 55. Jump Game(中等)
    You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.

    Return true if you can reach the last index, or false otherwise.

* **约束**
  * `1 <= nums.length <= 3 * 10^4`
  * `0 <= nums[i] <= 10^5`
  * `nums[0] != 0`
* **思路**
  * 求每走一步所能**剩余最大步数**
    * 若等于0，且未走完，则代表false
    * 否则继续下一步
  * 最终返回true
* **优化**：比较**最大跳跃位点(索引值)**
```java
public boolean canJump(int[] nums) {
    int max=0,n=nums.length;
    for (int i = 0; i < n; i++) {
        if ((max=Math.max(max,nums[i]))==0 && i<n-1)  return false;
        max--;
    }
    return true;
}

// 优化：对比最大位点
public static boolean canJump(int[] nums) 
{
    int maxjump = 0;
    for(int i=0; i<nums.length; i++){
        if(i > maxjump ) return false;
        maxjump = Math.max(maxjump , i+ nums[i]);
    }        
    return true;
}
```
# 56. Merge Intervals(中等)
    Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

* **约束**
  * `1 <= intervals.length <= 10^4`
  * `intervals[i].length == 2`
  * `0 <= starti <= endi <= 10^4`
* **思路**
  * 如数组无效，则原路返回
  * 先按头元素排序，再比较已处理的集合的尾元素与当前集合集合的头元素
    * 若尾元素小，则合并，取最大尾元素(当前集合尾元素)
    * 否则，添加当前集合，并更新当前集合为下一个集合
  * 由于存在合并情况，所以不能直接初始化为数组形式，应采用集合形式
* **优化**：
  * 以最大二维头元素+1做数组长度，关联头元素和尾元素
    * 当二维头元素相同时，取最大尾元素
  * 记录已处理区间索引，是否需要合并，合并区间头元素
  * 当存在尾元素不为0时
    * 若无区间头元素，则记录为区间头元素
    * 取最大尾元素
  * 若当前元素为尾元素时
    * 则对区间索引重置新的区间
    * 并重置下一轮尾元素，头元素
  * 若存在最后一个区间，则处理
  * 若区间数未变更，则直接返回
  * 否则，重新创建数组，按区间数处理赋值，并返回
* **注意**
  * 前一个区间尾元素和后一个区间头元素相差1时，应合并
```java
public int[][] merge(int[][] intervals) {
    if (intervals == null || intervals.length == 0 || intervals.length == 1)  return intervals;
    Arrays.sort(intervals, Comparator.comparingInt(o -> o[0]));
    List<int[]> list = new ArrayList<>();
    for (int[] interval : intervals) {
        if (list.isEmpty() || list.get(list.size() - 1)[1] < interval[0]) {
            list.add(interval);
        } else {
            list.get(list.size() - 1)[1] = Math.max(list.get(list.size() - 1)[1], interval[1]);
        }
    }
    return list.toArray(new int[list.size()][]);
}

// 优化
public int[][] merge(int[][] intervals) {
    int max = 0; // 记录二维数组首元素最大值
    for (int i = 0; i < intervals.length; i++) max = Math.max(intervals[i][0], max);

    int start,end;
    int[] mp = new int[max + 1];  // 以二维首元素最大值取得数组长度？
    for (int i = 0; i < intervals.length; i++) {
        start = intervals[i][0];
        end = intervals[i][1];
        // 重点 end+1避免出现与下一个区间相差1的区间，应该合并
        mp[start] = Math.max(end+1, mp[start]); // 当存在相同首元素时，取最大。
    }

    int idx = 0; // 记录已处理区间索引
    start = -1;end = -1; // 重置区间头元素，尾元素 为-1
    for (int i = 0; i < mp.length; i++) { // mp相当于已经对首元素排序
        if (mp[i] != 0) {
            if (start == -1) start = i;
            end = Math.max(mp[i]-1, end); // 取实际end值
        }
        if (end == i) { // 当匹配到end时，记录完整区间
            intervals[idx++] = new int[] { start, end };
            start = -1;end = -1; // 重置区间头尾
        }
    }

    if (start != -1) { // 补充最后一个区间
        intervals[idx++] = new int[] { start, end };
    }
    if (intervals.length == idx) { // 若区间数未发生变化，直接返回
        return intervals;
    }

    int[][] res = new int[idx][]; // 区间数变更，则重新创建数组
    for (int i = 0; i < idx; i++) {
        res[i] = intervals[i];
    }

    return res;
}
```
# 57. Insert Interval(中等)
    You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi], representing the start and the end of the ith interval and an integer newInterval where newInterval = [start, end]. Insert newInterval into intervals such that intervals is still sorted in ascending order and does not have any overlapping intervals (merge overlapping intervals if necessary).
    Insert newInterval into intervals such that intervals is still sorted in ascending order and does not have any overlapping intervals (merge overlapping intervals if necessary).

    Return an array of integers representing the new intervals that form the union of the original intervals and the new interval.

* **约束**
  * `1 <= intervals.length <= 10^4`
  * `intervals[i].length == 2`
  * `0 <= starti <= endi <= 10^4`
* **思路**: [参考56题](#56-merge-intervals中等)
  * 在获取二维数组最大头元素后，再与新区间头元素对比
  * 在映射二维数组的头尾元素后，再将新区间头尾映射
  * **缺陷**
    * 由于二维区间本身已经排序无重复，继续原来逻辑，会导致其它区间被重复处理，且没有变更
* **通用**
  * 分别找到新区间头尾元素在二维数组中的位置
  * 若头尾索引无效，则代表新增
  * 否则代表合并
* **改进**：不要想着同时处理，并且考虑合并情况
  * 主要思想：寻找头尾合适位置
  * 前面的无需处理
  * 当前的和后面小于新数组的头节点，合并到新区间
  * 结果循环加入前面的，当前的(合并后的新区间)，后面的
```java
public int[][] insert(int[][] intervals, int[] newInterval) {
    int max = 0;
    for (int[] interval : intervals) {
        max = Math.max(max, interval[0]);
    }
    max = Math.max(max, newInterval[0]);
    int[] mp = new int[max + 1];
    for (int[] interval : intervals) {
        mp[interval[0]] = Math.max(interval[1]+1, mp[interval[0]]);
    }
    mp[newInterval[0]] = Math.max(newInterval[1]+1, mp[newInterval[0]]);

    int start = -1,end =-1,r=0;
    int[][] res = new int[intervals.length+1][2];
    for (int i = 0; i < mp.length; i++) {
        if(mp[i]>0){
            if(start==-1) start = i;
            end = Math.max(mp[i]-1,end);
        }
        if(end == i){
            res[r++] = new int[]{start,end};
            start = -1;end =-1;
        }
    }
    if(start!=-1) res[r++] = new int[]{start,end};
    return Arrays.copyOf(res,r);
}

// 通用：耗时
public int[][] insert(int[][] intervals, int[] newInterval) {
    if (intervals.length == 0) {
        return new int[][]{newInterval};
    }

    int startIndex = binarySearch(intervals, newInterval[0], 0,true);
    int endIndex = binarySearch(intervals, newInterval[1],startIndex, false);

    List<int[]> result = new ArrayList<>();

    // No overlap; insert directly
    if (startIndex == -1 || endIndex == -1 || startIndex > endIndex) {
        int i = 0;
        while (i < intervals.length && intervals[i][0] < newInterval[0]) {
            result.add(intervals[i++]);
        }
        result.add(newInterval);
        while (i < intervals.length) {
            result.add(intervals[i++]);
        }
        return result.toArray(new int[0][]);
    }

    // Add intervals before merge
    for (int i = 0; i < startIndex; i++) {
        result.add(intervals[i]);
    }

    // Merge overlapping intervals
    int mergedStart = Math.min(intervals[startIndex][0], newInterval[0]);
    int mergedEnd = Math.max(intervals[endIndex][1], newInterval[1]);
    result.add(new int[]{mergedStart, mergedEnd});

    // Add intervals after merge
    for (int i = endIndex + 1; i < intervals.length; i++) {
        result.add(intervals[i]);
    }

    return result.toArray(new int[0][]);
}
private int binarySearch(int[][] arrs, int point, int start,boolean isLower) {
    int lo = 0,hi = arrs.length - 1,mid = lo + (hi - lo) / 2;
    int result = -1;
    if(start<0) start = 0;

    if (isLower) {
        while (lo <= hi) {
            if (arrs[mid][1] < point) {
                lo = mid + 1;
            } else {
                result = mid;
                hi = mid - 1;
            }
        }
    } else {
        while (lo <= hi) {
            if (arrs[mid][0] > point) {
                hi = mid - 1;
            } else {
                result = mid;
                lo = mid + 1;
            }
        }
    }
    return result;
}

// 改进版
public int[][] insert(int[][] intervals, int[] newInterval) {
    List<int[]> result = new ArrayList<>();
    int n = intervals.length;
    int i=0;
    while(i<n && intervals[i][1]<newInterval[0]){
        result.add(intervals[i++]);
    }
    while(i<n && intervals[i][0]<=newInterval[1]){
        newInterval[0]= Math.min(newInterval[0],intervals[i][0]);
        newInterval[1]= Math.max(newInterval[1],intervals[i][1]);
        i++;
    }
    result.add(newInterval);
    while(i<n){
        result.add(intervals[i++]);
    }
    // return result.toArray(new int[result.size()][]);
    int [][] new_result = new int[result.size()][2];
    for(int j=0;j<result.size();j++){
        new_result[j]=result.get(j);
    }
    return new_result;
}
```

# 58. Length of Last Word(简单)
    Given a string s consists of some words separated by spaces, return the length of the last word in the string. If the last word does not exist, return 0.

    A word is a maximal substring consisting of non-space characters only.

* **约束**
  * `1 <= s.length <= 10^4`
```java
public int lengthOfLastWord(String s) {
    int end = s.length()-1;
    while (end >= 0 && s.charAt(end) == ' ') end--;
    if (end < 0) return 0;
    return end - s.lastIndexOf(' ', end);
}
```
# 59. Spiral Matrix II(中等)
    Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.

* **约束**
  * `1 <= n <= 20`
* **思路**
  * 分别从上，右，下，左填充
  * 填充时，判断是否越界，越界则退出,并将越界修正
  * 每完整轮填充后，缩小边界
```java
public int[][] generateMatrix(int n) {
    int[][] res = new int[n][n];
    int num = 1;
    for(int k=0;k<n;k++,n--){  // k作为每轮起始位置，最小边界，n为最大边界
        int i = k,j = k;
        while(j<n){
            res[i][j++] = num++;
        }
        j--; // j==n => j==n-1 // 修正溢出位置

        // right
        while((++i)<n){
            res[i][j] = num++;
        }
        i--; // i==n => i==n-1

        // bottom
        while((--j)>=k){
            res[i][j] = num++;
        }
        j++; // j==k-1 > j==k

        // left
        while((--i)>k){
            res[i][j] = num++;
        } 
    }
    return res;
}
```
# 60. Permutation Sequence(中等)
    The set [1,2,3,...,n] contains a total of n! unique permutations.

    By listing and labeling all of the permutations in order, we get the following sequence for n = 3:

    "123"
    "132"
    "213"
    "231"
    "312"
    "321"

    Given n and k, return the kth permutation sequence.
* **约束**
  * `1 <= n <= 9`
  * `1 <= k <= n!`
* **思路**
  * 存储数字列表
  * 存储阶乘数(存在重复计算)
  * 当k与n-1的阶乘商为当前位数字索引，并移除该数字
    * 当整除时，索引应减一，即在对应数字范围内
  * 当n<=2时，根据k%2的余数对列表剩余数字是否进行反转
* **优化**
  * 由于n的**阶乘是固定的**，并且n有限制，故而可直接定义**静态变量**
  * 由于n有限制并且只有1位，可使用`char[]`代替`LinkedList，StringBuilder`
  * 以上优化**不适用**n不固定，并且数字不连续的情况
```java
public String getPermutation(int n, int k) {
    LinkedList<Integer> list = new LinkedList<>(); // 存储数字
    Map<Integer, Integer> map = new HashMap<>(); // 存储阶乘数
    for (int i = 1; i <= n; i++) {
        list.add(i);
        if(i!=n) map.put(i, i*map.getOrDefault(i-1, 1));
    }

    StringBuilder sb = new StringBuilder(); // 存储结果
    while(n>2 && k>0){ // 当n<=2或k=0时，后面的内容直接追加即可
        int tmp = map.get(--n);
        int index = k/tmp;
        if((k=k% tmp)==0) index--;
        sb.append(list.remove(index));
    }
    if(k%2==0){
        for (int i = list.size()-1; i >= 0; i--) {
            sb.append(list.get(i));
        }
    }else{
        for (int i = 0; i<list.size(); i++) {
            sb.append(list.get(i));
        }
    }
    return sb.toString();
}
```
# 61. Rotate List(中等)
    Given the head of a linked list, rotate the list to the right by k places.

* **约束**
  * `The number of nodes in the list is in the range [0, 500]`
  * `-100 <= Node.val <= 100`
  * `0 <= k <= 2 * 10^9`
* **思路**
  * 先遍历链表，计算链表长度
  * 计算实际需要旋转的次数`k = k % len`
  * 若`k == 0`，则无需旋转
  * 否则，将链表分为两部分，将后k个节点放到链表头部，将前`len-k`个节点放到链表尾部
  * **注意**：前面`len-k`的链表尾部要置空，否则会形成环
* **改进**
  * 计算长度之后，若`k!=0`，将链表首尾相连，形成环
  * 然后从链表头部开始，跳过`len-k`个节点，将链表断开，形成新的链表尾部
  * 将后面的作为链表头部(，由于前面已经做了首位相连，故无需额外处理头尾问题)
```java
public ListNode rotateRight(ListNode head, int k) {
        if(head == null || head.next == null || k == 0) return head;
        int len = 1;
        ListNode next = head;
        while(next.next != null){
            len++;
            next = next.next;
        }
        k = k % len;
        if(k == 0) return head;

        ListNode first = new ListNode(-1,head);
        next = head;

        int pos = 1; // 获取下一个即将旋转的next节点
        while (pos<len-k) {
            pos++;
            next = next.next;
        }

        ListNode temp = next.next; // 记录寻转节点
        next.next = null; // 将旋转节点从前一个节点断开
        next = temp; // 将next指向旋转节点

        temp = first.next; // 记录当前first.next
        first.next = next; // 将旋转节点放到first.next
        while(next.next != null){ // 遍历旋转节点到最后节点
            next = next.next;
        }
        next.next = temp; // 将旋转节点最后节点指向之前记录的first.next
        
        return first.next;
}
// 改进
public ListNode rotateRight(ListNode head, int k) {
    if(head == null || head.next == null || k == 0) return head;
    int len = 1;
    ListNode next = head;
    while(next.next != null){
        len++;
        next = next.next;
    }
    k = k % len;
    if(k == 0) return head;
    next.next = head; // 将链表首尾相连，避免后续处理

    int skip = len-k; // 获取跳跃个数
    ListNode newLast = head;
    for(int i = 1; i < skip; i++){
        newLast = newLast.next;
    }
    head = newLast.next;
    newLast.next = null;
    return head;
}
```
# 62. Unique Paths(中等)
    There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

    Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.


* **约束**
  * `1 <= m, n <= 100`
* **思路**：动态规划
  * 若**任一方向到达边界，则只有一种路径**
  * 否则，存在两种路径，分别从右和从下移动一步
  * **优化**：可使用记忆化搜索
    * 存在超时问题：当`i+1,j+1`和`j+1,i+1`对应同一个位置，会导致重复记录
    * 适用二维数组存储位置结果
* **其他**：从终点向起点合并计算
  * 循环法代替递归
  * 从后向前合并结果
  * 二维数组填充1
```java
public int uniquePaths(int m, int n) {
    return uniquePaths(m, n,1,1);
}
public int uniquePaths(int m,int n,int i,int j){
    if(i == m || j == n) return 1;
    return uniquePaths(m,n,i+1,j)+uniquePaths(m,n,i,j+1);
}

// 优化
public int uniquePaths(int m, int n) {
    return uniquePaths(m, n,new int[m][n],0,0);
}
public int uniquePaths(int m,int n,int[][] arr,int i,int j){ // 超时问题
    if(i == m-1 || j == n-1) return 1;
    if (arr[i][j] != 0) return arr[i][j];
    arr[i][j] = uniquePaths(m,n,arr,i+1,j) + uniquePaths(m,n,arr,i,j+1);
    return arr[i][j];
}

// 其他解法
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];
    dp[m-1][n-1] = 1;
    
    for (int i = m - 1; i >= 0; i--) {
        for (int j = n - 1; j >= 0; j--) {
            if (i + 1 < m)
                dp[i][j] += dp[i+1][j]; // move down
            if (j + 1 < n)
                dp[i][j] += dp[i][j+1]; // move right
        }
    }
    return dp[0][0];
}
```
# 63. Unique Paths II(中等)
    You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

    An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.

    Return the number of possible unique paths that the robot can take to reach the bottom-right corner.

* **约束**
  * `m == obstacleGrid.length`
  * `n == obstacleGrid[i].length`
  * `1 <= m, n <= 100`
  * `obstacleGrid[i][j]` is `0` or `1`.
* **思路**：动态规划,[参考62题](#62-unique-paths中等)
  * 若超出边界或遇到障碍，则返回0
  * 若能到达终点，则返回1
  * 若当前位置已被计算过，则返回计算值
  * 否则，返回向右向下的路径之和
```java
public int uniquePathsWithObstacles(int[][] grid) {
    int m = grid.length,n = grid[0].length;
    int[][] dp = new int[m][n];
    for (int i = 0; i < m; i++) Arrays.fill(dp[i],-1); // 由于存在阻塞非阻塞情况，用0代表阻塞，则用-1代表默认无效值
    return uniquePathsWithObstacles(grid,dp,m, n,0,0);
}
public int uniquePathsWithObstacles(int[][] grid,int[][] dp,int m,int n,int i,int j){ // 超时问题
    if(i==m || j == n || grid[i][j] == 1) return 0;
    if (i == m-1 && j == n-1) return 1;
    if (dp[i][j] != -1) return dp[i][j];
    dp[i][j] = uniquePathsWithObstacles(grid,dp,m,n,i+1,j) + uniquePathsWithObstacles(grid,dp,m,n,i,j+1);
    return dp[i][j];
}
```

# 64. Minimum Path Sum(中等)
    You are given a m x n grid filled with non-negative numbers. Let each element of the grid represent the cost of moving through that cell. Find a path from top-left to bottom-right which minimizes the sum of all numbers along its path.

    Note: You can only move either down or right at any point in time.
* **约束**
  * `m == grid.length`
  * `n == grid[i].length`
  * `1 <= m, n <= 200`
  * `0 <= grid[i][j] <= 100`
* **思路**：动态规划,[参考63题](#63-unique-paths-ii中等)
  * 到达终点，返回终点值(隐式一定存在最小值，而不会都越界)
  * 当前位置已被计算过，返回计算值（隐式处理越界问题）
  * 否则，返回向右向下的有效最小值
  * 可读性强，需要辅助数组，极端情况会栈溢出
  * **优化**：获取有效最小值时，后一位无效时则赋值为最大Integer(一定会存在最小值)，减少代码量
* **其他**：动态规划 + 斜向更新
  * 空间优化，不适用辅助数组
  * 可读性差
```java
public int minPathSum(int[][] grid) {
    int m = grid.length,n = grid[0].length;
    int[][] dp = new int[m][n];
    for (int i = 0; i < m; i++) Arrays.fill(dp[i],-1); // 由于存在阻塞非阻塞情况，用0代表阻塞，则用-1代表默认无效值
    return minPathSum(grid,dp,m, n,0,0);
}
private int minPathSum(int[][] grid,int[][] dp,int m,int n,int i,int j){ // 超时问题
    if (i == m-1 && j == n-1) return grid[i][j]; // 终点
    if (dp[i][j] != -1) return dp[i][j];
    // 获取有效最小值
    int min = 0;
    if(i+1 == m){
        min = minPathSum(grid,dp,m,n,i,j+1);
    }else if(j+1 == n){
        min = minPathSum(grid,dp,m,n,i+1,j);
    }else{
        min = Math.min(minPathSum(grid,dp,m,n,i+1,j), minPathSum(grid,dp,m,n,i,j+1));
    }

    dp[i][j] = grid[i][j] + min;
    return dp[i][j];
}

// 优化: 获取有效最小值时，若无效，则赋值为最大，不会存在i+1=m && j+1=n的情况，即肯定存在最小值
private int minPathSum(int[][] grid,int[][] dp,int m,int n,int i,int j){ // 超时问题
    if (i == m-1 && j == n-1) return grid[i][j]; // 终点
    if (dp[i][j] != -1) return dp[i][j];
    int down = (i + 1 < m) ? minPathSum(grid, dp, m, n, i + 1, j) : Integer.MAX_VALUE;
    int right = (j + 1 < n) ? minPathSum(grid, dp, m, n, i, j + 1) : Integer.MAX_VALUE;
    dp[i][j] = grid[i][j] + Math.min(down, right);
    return dp[i][j];
}

// 其他
public int minPathSum(int[][] grid) {
    int m = grid.length, n = grid[0].length;
    for (int i = m - 2; i > -1; i--)
        updategrid(grid, i, n - 1, m, n);
    for (int i = n - 2; i > -1; i--)
        updategrid(grid, 0, i, m, n);
    return grid[0][0];
}
private void updategrid(int[][] grid, int i, int j, int m, int n) {
    int mini;
    while (i > -1 && j > -1 && i < m && j < n) {
        mini = Integer.MAX_VALUE;
        if (i < m - 1) 
            mini = grid[i + 1][j];
        if (j < n - 1) 
            mini = Math.min(mini, grid[i][j + 1]);
        grid[i++][j--] += mini;
    }
}
```
# 65. Valid Number(中等)
    A valid number can be split up into these components (in order):

    * A decimal number or an integer.
    * (Optional) An 'e' or 'E', followed by an integer.
    * A decimal number can be split up into these components (in order):

    * (Optional) A sign character (either '+' or '-').
    * One of the following formats:
    * One or more digits, followed by a dot '.'.
* **约束**
  * `1 <= s.length <= 20`
  * `s` consists of English letters (lower-case and upper-case), digits (0-9), '+', '-', ' ', or '.'.
* **思路**：罗列所有无效情况，剩下的即有效
  * `+/-`只能出现在首位或`e/E`后
  * `e/E`只能出现一次
  * `.`只能出现一次且不能出现在`e/E`后(**不可忽略**)
  * 必需要有数字，且`e/E`后面要有数字
  * **提示**：`e/E`相当于10的次方，不能是小数，故后面不能有`.`
```java
public boolean isNumber(String s) {
    boolean hasNumber= false; 
    boolean hasDot = false; // 判断多余小数点
    boolean hasE = false; // 判断多余e
    boolean hasNumberAfterExp = true; // 判断e后是否有数字
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if(c>='0' && c<='9'){
            hasNumber = true;
            if(hasE) hasNumberAfterExp = true;
            continue;
        }
        if(i==s.length()-1 && !hasNumber) return false; // 最后一位仍无数字无效

        if (c == '+' || c == '-') { // 判断符号位
            if(i==0) continue; // 首位有效
            if (!hasE || !isE(s.charAt(i-1))) return false; // 非首位校验是否在e或E后面
        }else if(c == '.') { // 判断小数点,多余/E后无效
            if(hasDot || hasE) return false;
            hasDot = true;
        }else if (isE(c)) { // 判断科学计数法,多余/无数字/首位末尾无效
            if(!hasNumber||hasE) return false;
            hasE = true;
            hasNumberAfterExp = false;
        }else { // 判断非数字
            return false;
        }
    }
    return hasNumber && hasNumberAfterExp;
}
private boolean isE(char c) {
    return c == 'e' || c == 'E';
}
```

# 66. Plus One(简单)
    You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.

    Increment the large integer by one and return the resulting array of digits.

* 约束
  * `1 <= digits.length <= 100`
  * `0 <= digits[i] <= 9`
  * `digits does not contain any leading 0's`
* **思路**
  * 从后向前遍历，结果大于10，前进1位，当前位取余，
  * 若首位结果大于10，扩展新数组
* **改进**
  * 由于值为`0-9`，只有为`9`时才需要进位，故可简化为非9时直接+1退出
  * 等于9时，+1最终当前为结果为0
  * 由于**int默认值为0**，故**新数组扩展只需首位为1**即可
```java
// 初版
public int[] plusOne(int[] digits) {
    int tmp,n=digits.length,i=n-1;
    int[] result = digits;
    do {
        tmp = digits[i] + 1;
        digits[i--] = tmp % 10;
    } while (tmp / 10 == 1 && i >=0);
    if (i < 0 && tmp / 10 == 1) {
        // 扩展新数组
        result = new int[n + 1];
        result[0] = 1;
        for (int j = 0; j < n; j++)
            result[j + 1] = digits[j];
    }
    return result;
}

// 参考官方改进
public int[] plusOne(int[] digits) {
    int n = digits.length,i=n-1;
    do{
        if(digits[i]<9){
            digits[i]++;
            return digits; 
        }
        digits[i--] = 0;
    }while(i>=0);
    // 代表第一位结果=10，后续位置都为0，由于int默认0，故只需新增int[]首位1即可
    int[] ans = new int[digits.length+1]; 
    ans[0] = 1;
    return ans;
}
```
# 67. Add Binary(简单)
    Given two binary strings a and b, return their sum as a binary string.

* 约束
  * `1 <= a.length, b.length <= 10^4`
  * `a` and `b` consist only of '0' or '1' characters.
  * Each string does not contain leading zeros except for the zero itself.

* **思路**
  * **从后向前遍历**
  * **结果大于2，前进1位，当前位取余**
  * **若遍历完仍需进1，则新增首位为1**
  * `char`和`int`计算会被提权至`int`
  * 由于`char`中`0`转`int`非`0(48)`，故两个`char`相加相当于多加一次，需要减去一个
* **改进**
  * 以`char[]`接收结果，并定义最大可能长度的数组
  * 将各位运算都转为`int`类型计算
  * 通过**位并运算**计算当前位结果`(char)((sum & 1) + '0') or sum % 2`

```java
// 初版，通过StringBuilder.insert(offset, char)方法，从后向前插入
public static String addBinary(String a, String b) {
    StringBuilder sb = new StringBuilder();
    int i = a.length()-1,j= b.length()-1;
    char cur;int tmp = 0; // tmp 最大是1
    while(i>=0 || j>=0) {
        if(i<0) cur = b.charAt(j--); 
        else if(j<0) cur = a.charAt(i--);
        // 在ascii中，'0'的值为48, 双位相加相当于多加一次'0'，故需要减去一个
        else cur = (char)(a.charAt(i--) + b.charAt(j--) - '0');
        cur = (char)(cur + tmp);
        if (cur == '3') { // cur临时最大为3，即双位都为1，并且低位上进1
            cur = '1';
            tmp = 1;
        }else if(cur == '2') {
            cur = '0';
            tmp = 1;
        }else { //不足2时，cur不变，并且不足进1，tmp重置为0
            tmp = 0;
        }
        sb.insert(0,cur);

    }
    if (tmp == 1) sb.insert(0,'1');
    String result = sb.toString();
    return result;
}

// 改进版
public String addBinary(String a, String b) {
    if(a.length()<b.length()) return addBinary(b, a); // 统一 a为最长的字符串
    int i = a.length()-1, j = b.length()-1,carry = 0;
    char[] res = new char[a.length() + 1]; // 结果最大可能比最长长1位
    int k = res.length-1;
    while(i>=0){
        int digist = a.charAt(i--) - '0';
        int digistB = j>=0 ? b.charAt(j--) - '0' : 0;
        int sum = digist + digistB + carry;
        carry = sum>>1;
        res[k--] = (char)((sum & 1) + '0'); // == sum % 2
    }
    if (carry == 1) {
        res[k--] = '1';
    }
    return new String(res,k+1,res.length-k-1);
}
```
# 68. Text Justification(中等)
    Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.

    You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.
    Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

    For the last line of text, it should be left justified and no extra space is inserted between words.

    Note:

    A word is defined as a character sequence consisting of non-space characters only.
    Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.
    The input array words contains at least one word.

* 约束
  * `1 <= words.length <= 300`
  * `1 <= maxWidth <= 100`
  * `words[i].length <= maxWidth`
  * `words[i]` consists of English letters and ' '.
  * `words[i]` does not contain leading or trailing spaces.
  * `words` represents a single line of text, and there is at least one word in each line.
* **思路**
  * 遍历数组，每次遍历重置记录当前行开始位置，行内字符长度
  * 若当前行未超出，则循环遍历
  * 超出，则准备格式化当前行
  * 若是单个词(无空格，起始位和超出位相差1)或最后一行，则标准格式化，空格不均分，末尾补齐
  * 否则，空格均分，并且若有剩余，则左侧空格应多余右侧
```java
public List<String> fullJustify(String[] words, int maxWidth) {
    List<String> result = new ArrayList<>();
    int i = 0;
    while (i < words.length) {
        int j = i, len = 0;
        while (j < words.length && len + words[j].length() + (j - i) <= maxWidth) {
            len += words[j].length();
            j++;
        }
        int gaps = j - i - 1;
        int spaces = maxWidth - len;
        StringBuilder line = new StringBuilder();
        if (j == words.length || gaps == 0) { // 最后一行或单个单词
            for (int k = i; k < j; k++) {
                line.append(words[k]);
                if (k != j - 1) line.append(" ");
            }
            while (line.length() < maxWidth) line.append(" ");
        } else {
            int spaceEach = spaces / gaps, extra = spaces % gaps;
            for (int k = i; k < j; k++) {
                line.append(words[k]);
                if (k != j - 1) {
                    int toAdd = spaceEach + (extra-- > 0 ? 1 : 0);
                    while (toAdd-- > 0) line.append(" ");
                }
            }
        }
        result.add(line.toString());
        i = j;
    }
    return result;
}
```
# 69. Sqrt(x)(简单)
    Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.

    You must not use any built-in exponent function or operator.

* 约束
  * `0 <= x <= 2^31 - 1`
* **思路**
  * 4之前的数字，直接返回
  * 从中间值向下匹配：超过4的值，一般不会有比中间值大的开方值
  * **注意数据长度限制**，若为最大值Integer，则中间值会溢出
* 改进： 减少循环次数
  * **二分查找**
```java
// 思路： N*2 == num；最次一半内，一半后肯定没有符合条件的，开放要从2开始
public static int sqrt2(int num){
    if(num==0) return 0;
    if(num<4) return 1;
    int hk = num/2;
    long tmp=0;
    while(hk>=2){ // 如何跳步 缩短步骤
        tmp =(long) hk * hk;
        if(tmp == num){return hk;}
        if(tmp<num){break;}
        hk--;
    }
    return hk; // 向下取整
}

// 改进版(二分查找)
public static int sqrt(int num){
    if(num == 0) return 0;
    if(num < 4) return 1;
    return sqrt(num,2,num/2);
}

public static int sqrt(int num,int lo,int hi){
    if(hi<=lo || hi-1==lo) return lo;
    int mid =lo + ( hi -lo) /2;
    long tmp = (long)mid *mid ;
    if(tmp<num) return sqrt(num,mid,hi); 
    if(tmp>num) return sqrt(num,lo,mid);
    return mid;
}

// 官方改进版(二分查找)，不使用递归，从两侧向中间查找
public int mySqrt(int x) {
	if(x==0||x==1) return x;
	int start = 1,end=x,mid=-1;
	while(start<=end){
		mid = start + (end-start)/2;
		if((long)mid*mid>(long)x) end=mid-1;
		else if(mid*mid==x) return mid;
		else start = mid+1;
	}

	return end;
}
```

# 70. Climbing Stairs(简单)
    You are climbing a staircase. It takes n steps to reach the top.

    Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

* 约束
  * `1 <= n <= 45`
* **思路**： 从第三步开始，每一步都是前两步之和，即[**斐波那契数列**](/common/algorithm/algorithm.md#斐波那契数列)
  * **动态规划**: 大于2的使用**递归**方式，2之前的使用固定值
* **改进**
  * **保存前两个值**，每次计算后更新
```java
public static int climbStairs(int n ){
    if(n == 0 || n == 1) return 1;
    return climbStairs(n-1) + climbStairs(n-2); // 递归超时了
}

public static int climbStairs2(int n ){
    if(n <4) return n;
    int p1 = 2;
    int p2 = 3;
    int cur =0;
    for (int i = 4; i < n +1; i++) { //=> for (=> int i = 3; i < n; i++)
        cur = p1 + p2;
        p1 = p2;
        p2 = cur;
    }
    return cur;
}
```
# 71. Simplify Path(中等)
Given a string path, which is an **absolute path** (starting with a slash `/`) to a file or directory in a Unix-style file system, convert it to the simplified canonical path.

In a Unix-style file system, a period `.` refers to the current directory, a double period `..` refers to the directory up a level, and any multiple consecutive slashes (i.e. `//`) are treated as a single slash `/`. For this problem, any other format of periods such as `...` are treated as file/directory names.

* 约束
  * `1 <= path.length <= 3000`
  * `path` consists of English letters, digits, period '.', slash '/' or '_'.
  * `path` is a valid absolute Unix path.
* **思路**
  * **栈**：将路径按`/`拆分，遇到`.`忽略，遇到`..`则弹出栈顶，其他则入栈
  * **字符串操作**：将路径按`/`拆分，遇到`.`忽略，遇到`..`则删除前一个`/`，其他则拼接
```java
public String simplifyPath(String path) {
    StringBuilder sb = new StringBuilder();
    Stack<String> stack = new Stack<>();
    for (String str : path.split("/")) {
        if (str.equals(".")|| str.equals("")) continue;
        if (str.equals("..")) {
            if (!stack.isEmpty()){
                String pre = stack.pop();
                sb.delete(sb.length()-pre.length()-1, sb.length());
            }
        }
        else {
            stack.push(str);
            sb.append("/").append(str);
        }
    }
    return sb.length() == 0 ? "/":sb.toString();
}
```
# 72. Edit Distance(困难)
    Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.

    You have the following three operations permitted on a word:

    * Insert a character
    * Delete a character
    * Replace a character
* 约束
  * `1 <= word1.length, word2.length <= 500`
  * `word1` and `word2` consist of lowercase English letters.
* **思路**: **动态规划**
  * 使用辅助二维数组，行代表word1，列代表word2
  * 并初始化第一行和第一列分别对应其所对应的列数`dp[0][j]=j`和行数`dp[i][0]=i`
  * 相等时，`dp[i][j] = dp[i - 1][j - 1]`
  * 不等时，分别对比替换/删除/插入的最小值+1
* **改进**：从后向前匹配，使用记忆法递归方法,但可能存在栈溢出情况
  * 上一个方法需遍历所有情况，本方法只计算必要部分
  * 使用记忆法避免重复计算
```java
public int minDistance(String word1, String word2) {
    final int m = word1.length(),n = word2.length();
    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i <= m; ++i)
        dp[i][0] = i;

    for (int j = 1; j <= n; ++j)
        dp[0][j] = j;

    for (int i = 1; i <= m; ++i)
        for (int j = 1; j <= n; ++j)
        if (word1.charAt(i - 1) == word2.charAt(j - 1))//same characters
            dp[i][j] = dp[i - 1][j - 1];//no operation
        else
            dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;  //replace,delete,insert

    return dp[m][n];
}
// 改进版
public int minDistance(String word1, String word2) {
    int n1 = word1.length();
    int n2 = word2.length();
    int[][] dp = new int[n1][n2];
    for(int arr []: dp) Arrays.fill(arr,-1);
    return minDistance(word1,word2,n1-1,n2-1,dp);
}
private int minDistance(String w1, String w2,int i1,int i2,int[][] dp){
    if(i1<0) return i2+1;
    if(i2<0) return i1+1;
    if(dp[i1][i2]!=-1) return dp[i1][i2];

    int min = Integer.MAX_VALUE;
    if(w1.charAt(i1)==w2.charAt(i2)) return  dp[i1][i2]=minDistance(w1,w2,i1-1,i2-1,dp);
    // replace vs delete vs insert
    int insert = minDistance(w1,w2,i1,i2-1,dp);
    int delete = minDistance(w1,w2,i1-1,i2,dp);
    int  replace = minDistance(w1,w2,i1-1,i2-1,dp);
    min = Math.min(insert,delete);
    min = Math.min(min,replace);
    return dp[i1][i2] = min+1;
}
```
# 73. Set Matrix Zeroes(中等)
    Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's, and return the matrix.

    You must do it in place.
* 约束
  * `m == matrix.length`
  * `n == matrix[0].length`
  * `1 <= m, n <= 200`
  * `-2^31 <= matrix[i][j] <= 2^31 - 1`
* **思路**: 辅助数组判断是否时原生0
  * 初始化辅助数组，记录是否时原生0
  * 遍历辅助数组，遇到原生0，则将对应行和列置为0
* **优化**：将二维辅助数组优化为两个一维数组，减少重置0时的循环
```java
public void setZeroes(int[][] matrix) {
    //定义辅助数组，记录是否时原生0
    int n = matrix.length;
    int m = matrix[0].length;
    boolean[][] row = new boolean[n][m];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            row[i][j] = matrix[i][j] == 0;
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (row[i][j]) {
                for (int j2 = 0; j2 < n; j2++) {
                    matrix[j2][j] = 0;
                }
                for (int j2 = 0; j2 < m; j2++) {
                    matrix[i][j2] = 0;
                }
            }
        }
    }
}

// 优化版
public void setZeroes(int[][] matrix) {
    int n = matrix.length;
    int m = matrix[0].length;
    boolean[] row = new boolean[n];
    boolean[] col = new boolean[m];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if(matrix[i][j] == 0){
                row[i] = true;
                col[j] = true;
            }
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (row[i]||col[j]) {
                matrix[i][j] = 0;
            }
        }
    }
}
```
# 74. Search a 2D Matrix(中等)
    You are given an m x n integer matrix matrix with the following two properties:

    * Each row is sorted in non-decreasing order.
    * The first integer of each row is greater than the last integer of the previous row.
    Return true if target is in matrix or false otherwise.
* 约束
  * `m == matrix.length`
  * `n == matrix[0].length`
  * `1 <= m, n <= 100`
  * `-10^4 <= matrix[i][j], target <= 10^4`
* **思路**: **二分查找**
  * 首先判断收尾是否包含target
  * 若包含，则在当前数组中查找
  * 通过二分法查找相对较快
  * **基本实现**：双遍历，对比每一个元素
```java
public boolean searchMatrix(int[][] matrix, int target) {
    for (int[] arr : matrix) {
        if (arr[0] > target) return false;
        if (arr[arr.length-1] < target) continue;
            int left = 0, right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) return true;
            else if (arr[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
    }
    return false;
}
```
# 75. Sort Colors(中等)
    Given an array nums with n objects colored red, white, or blue, sort them **in-place** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

    We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
    You must solve this problem without using the library's sort function.
* 约束
  * `n == nums.length`
  * `1 <= n <= 300`
  * `nums[i]` is either `0`, `1`, or `2`.
* **思路**: **排序算法**，将0，1，2排序
```java
public void sortColors(int[] nums) {
    quick3Way(nums, 0, nums.length - 1);
}
private void quick3Way(int[] nums, int lo, int hi) {
    if (lo >= hi) return;
    int lt = lo, i = lo + 1, gt = hi;
    int v = nums[lo];
    while (i <= gt) {
        if (nums[i] < v) exch(nums, lt++, i++);
        else if (nums[i] > v) exch(nums, i, gt--);
        else i++;
    }
    quick3Way(nums, lo, lt - 1);
    quick3Way(nums, gt + 1, hi);
}
private static void exch(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```
# 76. Minimum Window Substring(困难)
    Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string "".

    The testcases will be generated such that the answer is unique.

    A substring is a contiguous sequence of characters in a string.
* 约束
  * `m == s.length`
  * `n == t.length`
  * `1 <= m, n <= 10^5`
  * `s` and t consist of uppercase and lowercase English letters.
* **思路**: **滑动窗口**
  * 定义两个指针，start和end，分别指向窗口的起始位置和当前位置
  * 定义两个数组，count和need，分别记录当前窗口的字符数量和t中字符的数量
  * 定义一个变量match，记录当前窗口中已经匹配的字符数量
  * 当match等于t的长度时，说明当前窗口已经包含了t中所有字符，此时可以尝试缩小窗口
* **改进**
  * 以int类型记录最小长度，当窗口长度小于最小长度时，更新最小长度
  * 以int类型记录所需数量，当所需数量为0时，说明当前窗口已经包含了t中所有字符，此时可以尝试缩小窗口
  * 将原字符串转char数组，避免重复通过字符串读取char
  * 根据char的int值，直接在数组中记录字符数量
  * 最后根据start索引和最小长度，直接获取子串
```java
public String minWindow(String s, String t) {
    String res = "";
    if(s.length()<t.length()) return res;

    int start = 0,cur = 0; // 活动窗口的起始位置和当前位置
    int[] count = new int[128],need = new int[128]; // count记录当前窗口的字符数量，need记录t中字符的数量
    for(char c : t.toCharArray()) need[c]++; // 将t中字符的数量记录到need中

    int match = 0; // 匹配数字，只有出现t中字符时才会+1，当match == t.length()时，说明当前窗口已经包含了t中所有字符
    int min = Integer.MAX_VALUE; // 最小长度
    while(cur < s.length()){
        char c = s.charAt(cur);
        if(need[c] > 0){ // 如果当前字符在t中出现过
            count[c]++;
            if(count[c] <= need[c]) match++;
        }
        cur++;
        while(match == t.length()){ // 当前窗口已经包含了t中所有字符
            if(cur - start < min){ // 更新最小长度和结果
                min = cur - start;
                res = s.substring(start,cur);
            }
            char c2 = s.charAt(start);
            if(need[c2] > 0){ // 如果当前字符在t中出现过,则count[c2]--，match--
                count[c2]--;
                if(count[c2]<need[c2]) match--; // 重点，因为可能存在重复字符较多时
            }
            start++;
        }
    }
    return res;
}

// 改进版
public String minWindow(String s, String t) {
    int[] need = new int[128];
    int count = t.length();
    int start = 0, end = 0, minLen = Integer.MAX_VALUE, startIndex = -1;
    for (char c : t.toCharArray()) need[c]++;
    char[] chs = s.toCharArray();
    while (end < chs.length) {
        if (need[chs[end++]]-- > 0) count--; // 找到目标字符，则所需计数器减一
        while (count == 0) { // 当计数器为0，代表已找到包含目标字符串字符的子串
            if (end - start < minLen) { // 更新最短子串长度
                startIndex = start;
                minLen = end - start;
            }
            if (need[chs[start++]]++ == 0) count++; // 移动左指针，若移除的字符是目标字符，则所需计数器加一
        }
    }

    return minLen == Integer.MAX_VALUE ? "" :s.substring(startIndex, startIndex + minLen);
}
```
# 77. Combinations(中等)
    Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].
    You may return the answer in any order.
* 约束
  * `1 <= n <= 20`
  * `1 <= k <= n`
* **思路**: **回溯算法**
* **优化**：自定义实现`java.util.AbstractList`，仅限于Leetcode加速
```java
public List<List<Integer>> combine(int n, int k) {
    List<List<Integer>> list = new ArrayList<>();
    combine(1, n,k, new ArrayList<>(),list);
    return list;
}
private void combine(int start,int n,int k,List<Integer> tmp,List<List<Integer>> result){
    if (tmp.size() == k) {
        result.add(new ArrayList<>(tmp));
        return;
    }
    for (int i = start; i <= n; i++) {
        tmp.add(i);
        combine(i+1,n,k,tmp,result);
        tmp.remove(tmp.size()-1);
    }
}
```
# 78. Subsets(中等)
    Given an integer array nums of unique elements, return all possible subsets (the power set).
    The solution set must not contain duplicate subsets. Return the solution in any order.
* 约束
  * `1 <= nums.length <= 10`
  * `1 <= nums[i] <= 10`
  * All the elements in nums are unique.
* **思路**: **回溯算法**，[参考77题](#77-combinations中等)
  * 由于是指定nums，则start要从0开始，并且不可等于或大于nums.length
* **优化**：自定义实现`java.util.AbstractList`，仅限于Leetcode加速
```java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> list = new ArrayList<>();
    list.add(new ArrayList<>());
    for (int i = 1; i <= nums.length; i++) {
        subsets(nums,0, i, new ArrayList<>(),list);
    }
    return list;
}
private void subsets(int[] nums,int start,int k,List<Integer> tmp,List<List<Integer>> result){
    if (tmp.size() == k) {
        result.add(new ArrayList<>(tmp));
        return;
    }
    for (int i = start; i < nums.length; i++) {
        tmp.add(nums[i]);
        subsets(nums,i+1,k,tmp,result);
        tmp.remove(tmp.size()-1);
    }
}
```
# 79. Word Search(中等)
    Given an m x n grid of characters board and a string word, return true if word exists in the grid.
    The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
* 约束
  * `m == board.length`
  * `n == board[i].length`
  * `1 <= m, n <= 6`
  * `1 <= word.length <= 15`
  * `board` and `word` consist of only lowercase and uppercase English letters.
* **思路**: **回溯算法**
  * 记录已访问过的节点，防止重复访问
  * 遍历board，找到与word第一个字符相同的节点，开始回溯
  * 回溯时，判断当前节点是否在board范围内，是否已访问过，是否与word当前字符相同
  * 若条件满足，则继续向四个方向回溯，如有匹配立即退出
  * 直至word匹配结束或条件不符
* **改进**
  * 先决边界：增加先决条件判断，超出边界，直接无效
  * 将word首位根据次数决定是否反转(次数少的在头部)
  * 减少回溯次数
    * 字符次数从小到大开始匹配，
    * 当无法与头字符匹配，直接跳过
    * 循环各方向，如有匹配立即退出
  * 通过将二维数组重置为**任意非字母**用于代表已访问过的节点，避免使用Set结构
    * 当不符合时，记得将其还原
```java
public boolean exist(char[][] board, String word) {
    int m = board.length,n = board[0].length;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if(board[i][j] != word.charAt(0)) continue;
            if(fs(board,word,new HashSet<>(),i,j,0)) return true;
        }
    }
    return false;
}
private boolean fs(char[][] board,String word,Set<String> visited,int i,int j,int k){
    if(k == word.length()) return true;
    if(i<0 || i>=board.length || j<0 || j>=board[0].length ||
        visited.contains(i+","+j) || board[i][j] != word.charAt(k)) return false;

    visited.add(i+","+j);
    int[] ds = {-1, 1, 0, 0};
    for (int l = 0; l < 4; l++) {
        if(fs(board,word,visited,i+ds[l],j+ds[3-l],k+1)) return true; // 更早结束
    }
    visited.remove(i+","+j);
    return false;
}

// 改进版
public boolean exist(char[][] board, String word) {
    int n = board.length, m = board[0].length;
    if (word.length() > n * m) return false; // Not enough chars on board
    int[] freq = new int[128]; // ASCII size
    for (char[] row : board)  for (char ch : row) freq[ch]++;
    for (char ch : word.toCharArray()) if (--freq[ch] < 0) return false; // Not enough chars on board
    // 从小量到大量，减少回溯次数
    if (freq[word.charAt(0)] > freq[word.charAt(word.length() - 1)]) word = new StringBuilder(word).reverse().toString();

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if(board[i][j] != word.charAt(0)) continue;
            if (dfs(board, word, i, j, 0)) return true;
        }
    }
    return false;
}
private boolean dfs(char[][] board, String word, int row, int col, int idx) {
    if (idx == word.length()) return true;
    if (row < 0 || col < 0 || row >= board.length || col >= board[0].length
        || board[row][col] != word.charAt(idx)) return false;
    // Mark visited
    char temp = board[row][col];
    board[row][col] = '#'; // 任意非字母字符都可
    // Move in 4 directions
    int[] ds = {-1, 1, 0, 0};
    for (int d = 0; d < 4; d++) {
        if(dfs(board,word,row+ds[d],col+ds[3-d],idx+1))  return true;
    }
    board[row][col] = temp;
    return false;
}
```
# 80. Remove Duplicates from Sorted Array II(中等)
    Given an integer array nums sorted in **non-decreasing order**, remove the duplicates **in-place** such that each unique element appears at most twice. The relative order of the elements should be kept the same.
    Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.
    Return k after placing the final result in the first k slots of nums.
    Do **not** allocate extra space for another array. You must do this by **modifying the input array** in-place with O(1) extra memory.
* 约束
  * `1 <= nums.length <= 3 * 10^4`
  * `-10^4 <= nums[i] <= 10^4`
  * `nums` is sorted in **non-decreasing** order.
* **思路**
  * 记录前一个，当前有效索引，重复数量
  * 由于数组时升序的，所以直接遍历处理即可
  * 若当前值和前值相等，且重复数量大于2，则跳过
  * 若当前值和前值不同，则重置前一个和重复数量
  * 赋值有效索引为当前值
* **优化**
  * 提前结束，当数组长度小于等于2时，直接返回数组长度
  * 从第三个元素开始对比，并且对比**有效**前面第二个元素
```java
public int removeDuplicates(int[] nums) {
    int pre=nums[0],cur=1,count=1;
    for (int i = 1; i < nums.length; i++) {
        int tmp = nums[i];
        if(tmp == pre){
            if(++count>2) continue; // 超过两次则跳过
        }else{ // 重置
            pre = tmp;
            count = 1;
        }
        nums[cur++] = tmp;
    }
    return cur;
}
// 优化
public int removeDuplicates(int[] nums) {
    if (nums.length <= 2) return nums.length;
    int k = 2;
    for (int i = 2; i < nums.length; i++) {
        if (nums[i] != nums[k - 2]) nums[k++] = nums[i];
    }
    return k;
}
```
# 81. Search in Rotated Sorted Array II(中等)
There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).

Before being passed to your function, nums is rotated at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,4,4,5,6,6,7]` might be rotated at pivot index `5` and become `[4,5,6,6,7,0,1,2,4,4]`.

* 约束
  * `1 <= nums.length <= 5000`
  * `-10^4 <= nums[i] <= 10^4`
  * `-10^4 <= target <= 10^4`
  * `nums` is guaranteed to be rotated at some pivot.
* **思路**: 双指针查找法
  * 若查找到，则返回true
  * 前半部分属于大于查找，若后一个小于当前，则终止false
  * 后半部分属于小于查找，如前一个大于当前，则终止false
  * 结束未查找到则返回false
```java
public boolean search(int[] nums, int target) {
    if(nums.length == 1) return nums[0] == target;
    int left = 0,right = nums.length-1;
    while (left<right) {
        if(nums[left] == target || nums[right] == target) return true;
        if(nums[left] < target) {
            if(nums[left] > nums[left+1]) return false;
            left++;
        }else if(nums[right] > target) {
            if(nums[right] < nums[right-1]) return false;
            right--;
        }else return false;
    }
    return false;
}
```
# 82. Remove Duplicates from Sorted List II(中等)
    Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.
* 约束
  * The number of nodes in the list is in the range [0, 300].
  * -100 <= Node.val <= 100
  * The list is guaranteed to be sorted in ascending order.
* **思路**
  * 定义前值，当前值，下一个值（前值一定是唯一值）
  * 遍历下一个值，若下一个值和下下个值不为null时处理
  * 若当前值和下一个值相等
    * 则将下一个值指向下一个的下一个，直到不相等
      * 将前值的下一个值定义为不等于当前值的下一个值
    * 若当前值和下一个值不等，则将前值指向当前值，当前值指向下一个值
```java
public ListNode deleteDuplicates(ListNode head) {
    if(head == null) return null;
    ListNode first = new ListNode(0,head);
    ListNode pre = first,cur = head,next = head;
    while(next!=null && (next = next.next)!= null){
        if(cur.val == next.val){
            while((next = next.next) != null && cur.val == next.val){}; // 找到下一个不重复的节点
            pre.next = next;
        }else pre = cur;
        cur = next;
    }
    return first.next;
}
```
# 83. Remove Duplicates from Sorted List(简单)
    Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.

* 约束
  * The number of nodes in the list is in the range [0, 300].
  * -100 <= Node.val <= 100
  * The list is guaranteed to be **sorted** in ascending order.
* **思路**
  * 通过当前和next对比，
    * 等值，则将`next.next`指向`next.next.next`
    * 否则将`next`设置为`next.next`
* **反思**
  * 开始的以为给的是随意的链表，需要对去重加排序呢
```java
public static  ListNode deleteDuplicates(ListNode head){
    if(head == null) return head;
    ListNode next = head;
    while(next!=null && next.next!=null){
        if(next.val == next.next.val){
            next.next = next.next.next;
        }else{
            next = next.next;
        }
    }
    return head;
}

// 以下是随机链表：去重+排序
public static  LineNode deleteDuplicates(LineNode head){
    if(head == null) return head; // 头节点为空，则直接返回
    // 定义first头节点，tail已排序的尾节点，next已排序尾节点的下一个节点
    LineNode first = new LineNode(-101,head),tail = first.next,next;
    
    while((next=tail.next)!=null){
        LineNode pre = first,cur = pre .next; // 定义前一个节点pre初始为first，当前比较节点，初始为first的下一个
        tail.next = next.next; // 无论next定位与否，都先将next.next交给tail.next

        while(true){  // pre<cur<tail !=null,next!=null
            if(cur.val <next.val){ //  cur.val<next.val	
                if (cur != tail) { // cur != tail，则pre绑定cur，cur转cur.next 继续
                    pre = cur;
                    cur = cur.next;
                    continue;
                }
                tail.next = next; // 还原，将next还原会tail.next 并将next设置为tail，最后退出
                tail = next;
                // break;
            }
            else if(cur.val>next.val){ // cur.val>next.val，cur大，则由pre绑定next，next绑定cur，退出
                next.next = cur;
                pre.next = next;
                // break;
            }
            // else (cur.val == next.val) break; // 等值忽略退出内循环
            break;
        }
    }
    return first.next;
}

// 将双层循环变为两个外层循环，利用map存储每个值对应的节点
public static ListNode deleteDuplicates2(ListNode head){
    if(head == null) return head;
    Map<Integer,ListNode> maps = new HashMap<>();
    ListNode first = new ListNode(-101,head),cur = first;
    while ((cur=cur.next)!=null) maps.put(cur.val,cur);
    first.next = null;cur = first;
    for(Integer key:maps.keySet().stream().sorted().toArray(Integer[]::new)){
        cur.next = maps.get(key);
        cur = cur.next;
    }
    cur.next = null; // 避免最大值有next
    return first.next;
}
```
# 84. Largest Rectangle in Histogram(困难)
    Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return the area of the largest rectangle in the histogram.

* **约束**
  * `1 <= heights.length <=105`
  * `0 <= heights[i] <= 104`
* **思路**
  * 暴力法：遍历每个节点，向左向右遍历，找到左右边界，计算面积
* **改进**
  * 栈处理：遍历数组
    * 若栈内有数据，并且当前值小于栈顶元素对应值，
      * 则取出栈顶并和当前索引之间的面积
    * 将当前值索引入栈
    * 判断最后栈内数据，并计算最后面积
  * **优化**：使用数组替代栈
```java
public int largestRectangleArea(int[] heights) { // 超时 O(n^2)
    int n = heights.length,start=0,max = 0;
    while(start < n){
        int low = 0;
        for (int i = start; i < n; i++) {
            if(heights[i] == 0) break;
            low = low == 0 ? heights[i] : Math.min(low,heights[i]);
            max = Math.max(max,low*(i-start+1));
        }
        start++;
    }
    return max;
}
// 改进版：使用栈获取面积
public int largestRectangleArea(int[] heights) { // 超时 O(nlogn)
    Stack<Integer> stack = new Stack<>();
    stack.push(-1);
    int maxArea = 0;

    for (int i = 0; i < heights.length; i++) {
        while (stack.peek() != -1 && heights[i] <= heights[stack.peek()]) {
            int height = heights[stack.pop()];
            int width = i - stack.peek() - 1;
            maxArea = Math.max(maxArea, height * width);
        }
        stack.push(i);
    }

    while (stack.peek() != -1) {
        int height = heights[stack.pop()];
        int width = heights.length - stack.peek() - 1;
        maxArea = Math.max(maxArea, height * width);
    }

    return maxArea;
}
// 改进优化版：适用数组替代stack
public int largestRectangleArea(int[] heights) {
    int n = heights.length,top = -1,max = -1;
    int[] stack = new int[n];
    for (int i = 0; i < n; i++) {
        while (top > -1 && heights[stack[top]] > heights[i]) {
            max = Math.max(max, heights[stack[top]] * (i - (top == 0 ? -1 : stack[top - 1]) - 1));
            top--;
        }
        stack[++top] = i; //push curr element
    }
    int nextIdx = n;
    while (top >= 0) {
        max = Math.max(max, heights[stack[top]] * (nextIdx - (top > 0 ? stack[top - 1] : -1) - 1));
        top--;
    }
    return max;
}
```
# 85. Maximal Rectangle(困难)
    Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.

* **约束**
  * `m == matrix.length`
  * `n == matrix[i].length`
  * `1 <= m, n <= 200`
  * `matrix[i][j]` is '0' or '1'.
* **思路**
  * 基本思路
    * 求最大列连续有效值和最大行连续有效值
    * 循环left/right
      * 遇0，则right重置为0的列索引
      * 每次内循环，求最大矩形面积
    * 分别向左和向右，位移，重复操作，求最大
    * 限制：O(n^3),超时,存在重复计算情况
* **改进**: **一维数组计算每列有效行数(索引为列，值为有效行数)**
  * 方式一：栈处理：遍历数组
  * 方式二：数组替代栈
  * 方式三：分别处理左右边界，减少循环次数
```java
// 基本思路: 超时
public int maximalRectangle(char[][] matrix) {
    return maximalRectangle(matrix,matrix.length,matrix[0].length,0,0);
}
private int maximalRectangle(char[][] matrix,int n,int m,int i,int j) {
    if(i == n || j == m) return 0;
    int max = 0,left=i,right=j;
    if(matrix[i][j] == '1'){
        while (left<n && matrix[left][j] == '1') left++;
        max = Math.max(max,left-i); // 单列连续有效最大值
        while (right<m && matrix[i][right] == '1') right++;
        max = Math.max(max,right-j); // 单行连续有效最大值
        // 计算多行多列矩形最大值
        for (int k = i; k < left; k++) {
            for (int k2 = j; k2 < right; k2++) {
                if(matrix[k][k2] == '0') {
                    right = k2;
                    break;
                }
            }
            int sum = (k-i+1) * (right-j);
            max = Math.max(max,sum);
        }
    }
    max = Math.max(max,maximalRectangle(matrix,n,m, i+1, j));
    max = Math.max(max,maximalRectangle(matrix,n,m, i, j+1));
    return max;
}
// 改进一：利用列数组存储每列有效行数
public int maximalRectangle(char[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;
    int maxArea = 0,cols = matrix[0].length;
    int[] heights = new int[cols];
    for (char[] row : matrix) {
        for (int i = 0; i < cols; i++) heights[i] = (row[i] == '1') ? heights[i] + 1 : 0;
        maxArea = Math.max(maxArea, largestRectangleArea(heights));
    }
    return maxArea;
}
private int largestRectangleArea(int[] heights) {
    int n = heights.length;
    int[] left = new int[n],right = new int[n];
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < n; i++) { // Nearest Smaller to Left
        while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) stack.pop();
        left[i] = (stack.isEmpty()) ? -1 : stack.peek();
        stack.push(i);
    }
    stack.clear(); // Reuse stack
    for (int i = n - 1; i >= 0; i--) { // Nearest Smaller to Right
        while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) stack.pop();
        right[i] = (stack.isEmpty()) ? n : stack.peek();
        stack.push(i);
    }
    int maxArea = 0;// Compute max area
    for (int i = 0; i < n; i++) {
        int width = right[i] - left[i] - 1;
        maxArea = Math.max(maxArea, heights[i] * width);
    }
    return maxArea;
}
// 改进二：使用栈结构改为一维数组替代
public int maximalRectangle(char[][] matrix) {
    int[] heights = new int[matrix[0].length];
    int maxArea = 0;
    for (char[] row : matrix) {
        for (int i = 0; i < row.length; i++) heights[i] = row[i] == '1' ? heights[i] + 1 : 0;
        maxArea = Math.max(maxArea, largestRectangleArea(heights));
    }
    return maxArea;
}
private int largestRectangleArea(int[] heights) {
    int n = heights.length;
    int[] stack = new int[n];
    int top = -1,maxArea = 0;
    for (int i = 0; i < n; i++) {
        while (top >= 0 && heights[stack[top]] > heights[i]) {
            int height = heights[stack[top--]];
            int width = top < 0 ? i : i - stack[top] - 1;
            maxArea = Math.max(maxArea, height * width);
        }
        stack[++top] = i;
    }
    while (top >= 0) {
        int height = heights[stack[top--]];
        int width = top < 0 ? n : n - stack[top] - 1;
        maxArea = Math.max(maxArea, height * width);
    }
    return maxArea;
}
// 改进三：
public int maximalRectangle(char[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;
    int m = matrix.length,n = matrix[0].length;
    int[] heights = new int[n],leftEdge = new int[n],rightEdge = new int[n];
    Arrays.fill(rightEdge, n); // 重点
    int maxArea = 0;
    for (int i = 0; i < m; i++) {
        int left = 0,right = n;
        updateHeightsAndLeftBoundaries(matrix[i], heights, leftEdge, left);
        updateRightBoundaries(matrix[i], rightEdge, right);
        maxArea = calculateMaxRectangle(heights, leftEdge, rightEdge, maxArea);
    }
    return maxArea;
}
private void updateHeightsAndLeftBoundaries(char[] row, int[] heights, int[] leftEdge, int left) {
    for (int j = 0; j < heights.length; j++) {
        if (row[j] == '1') {
            heights[j]++;
            leftEdge[j] = Math.max(leftEdge[j], left);
        } else {
            heights[j] = 0;
            leftEdge[j] = 0;
            left = j + 1;
        }
    }
}
private void updateRightBoundaries(char[] row, int[] rightEdge, int right) {
    for (int j = rightEdge.length - 1; j >= 0; j--) {
        if (row[j] == '1') {
            rightEdge[j] = Math.min(rightEdge[j], right);
        } else {
            rightEdge[j] = right;
            right = j;
        }
    }
}
private int calculateMaxRectangle(int[] heights, int[] leftEdge, int[] rightEdge, int maxArea) {
    for (int j = 0; j < heights.length; j++) {
        int width = rightEdge[j] - leftEdge[j];
        int area = heights[j] * width;
        maxArea = Math.max(maxArea, area);
    }
    return maxArea;
}
```
# 86. Partition List(中等)
Given the `head` of a linked list and a value `x`, partition it such that all nodes **less than** `x` come before nodes **greater than or equal** to `x`.

You should **preserve** the original relative order of the nodes in each of the two partitions.

* **约束**
  * The number of nodes in the list is in the range `[0, 200]`.
  * `-100 <= Node.val <= 100`
  * `-200 <= x <= 200`
* **思路**: 双指针法
  * 三指针:一个指针指向小于x的链表最后节点pre，一个指针指向大于x的链表最后节点last，一个指针遍历链表next
  * 遍历链表
    * 若不小于目标值，则置换last,next
    * 若前一个小于目标值pre.next为next，则置换pre,next
    * 否则，置换pre,last,next
```java
public ListNode partition(ListNode head, int x) {
    ListNode first = new ListNode(-1,head);
    ListNode pre = first,next = head,last = next;
    while(next!=null){
        if(next.val>=x){ // 大于等于x的节点，放到last后面
            last = next;
            next = next.next;
            continue;
        }
        if(pre.next == next){ // 若next是pre的下一个节点，则直接移动pre和next
            pre = next;
            next = next.next;
            continue;
        } // 否则置换pre,next,last
        ListNode tmp = pre.next; // 临时记录pre的下一个节点
        pre.next = next;  // pre的下一个节点指向next
        last.next = (next = next.next); // next前一个节点指向next的下一个节点
        (pre=pre.next).next = tmp; // pre的下一个节点指向临时记录的节点
    }
    return first.next;
}
```
# 87. Scramble String(困难)
We can scramble a string s to get a string t using the following algorithm:
1. If the length of the string is 1, stop.
2. If the length of the string is > 1, do the following:
   - Split the string into two non-empty substrings at a random index, i.e., if the string is `s`, divide it to `x` and y where `s = x + y`.
   - **Randomly** decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `s = x + y` or `s = y + x`.
   - Apply step 1 recursively on each of the two substrings `x` and `y`.

Given two strings `s1` and `s2` of **the same length**, return `true` if `s2` is a scrambled string of `s1`, otherwise, return `false`.

* **思路**：递归
  * 判断是否等值，若等值，则返回true
  * 循环长度，每一种索引都尝试
    * 根据索引切分两个字符串
    * 判断两半是否等长，等长交换递归(错位左右)，满足结果(并)，返回true
    * 不交换递归(同半部分)，满足结果(并)，返回true
  * 不满足结果，返回false
* **改进**：使用二维boolean数组记录匹配结果
```java
public boolean isScramble(String s1, String s2) { // 栈溢出
    if(s1.equals(s2)) return true;
    for (int i = 0; i < s1.length(); i++) {// 改进，筛选出更合适的索引位置
        // 先根据索引分割
        String[] s1s = {s1.substring(0, i), s1.substring(i)};
        String[] s2s = {s2.substring(0, i), s2.substring(i)};
        // 若两半长度等，可以交换判断
        if(s1s[0].length()==s1s[1].length()) {
            if((isScramble(s1s[0], s2s[1]) && isScramble(s1s[1], s2s[0]))) return true;
        }
        if((isScramble(s1s[0], s2s[0]) && isScramble(s1s[1], s2s[1]))) return true;
    }
    
    return false;
}
// 改进一：多次循环
public boolean isScramble(String s1, String s2) {
    int n = s1.length();
    boolean dp[][][] = new boolean[n + 1][n][n];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) dp[1][i][j] = s1.charAt(i) == s2.charAt(j);
    }
    for (int length = 2; length <= n; length++) {
        for (int i = 0; i < n + 1 - length; i++) {
            for (int j = 0; j < n + 1 - length; j++) {
                for (int newLength = 1; newLength < length; newLength++) {
                    boolean dp1[] = dp[newLength][i];
                    boolean dp2[] = dp[length - newLength][i + newLength];
                    dp[length][i][j] |= dp1[j] && dp2[j + newLength];
                    dp[length][i][j] | dp1[j + length - newLength] && dp2[j];
                }
            }
        }
    }
    return dp[n][0][0];
}
// 改进二：递归+记忆化
public boolean isScramble(String s1, String s2) {
    int n = s1.length();
    if (s1.equals(s2)) return true;
    char[] c1 = s1.toCharArray();
    char[] c2 = s2.toCharArray();
    int[][][] memo = new int[n][n][n + 1];  // 0: unvisited, 1: false, 2: true
    return dfs(0, 0, n,c1,c2,memo);
}

private boolean dfs(int i, int j, int len,char[] c1,char[] c2,int[][][] memo) {
    if (memo[i][j][len] != 0) return memo[i][j][len] == 2;
    // Check for direct equality
    boolean equal = true;
    for (int k = 0; k < len; k++) {
        if (c1[i + k] != c2[j + k]) {
            equal = false;
            break;
        }
    }
    if (equal) {
        memo[i][j][len] = 2;
        return true;
    }

    // Char frequency pruning
    int[] chs = new int[26];
    for (int k = 0; k < len; k++) {
        chs[c1[i + k] - 'a']++;
        chs[c2[j + k] - 'a']--;
    }
    for (int c : chs) {
        if (c != 0) {
            memo[i][j][len] = 1;
            return false;
        }
    }
    // Try all split points
    for (int k = 1; k < len; k++) {
        // No swap
        if (dfs(i, j, k,c1,c2,memo) && dfs(i + k, j + k, len - k,c1,c2,memo)) {
            memo[i][j][len] = 2;
            return true;
        }
        // With swap
        if (dfs(i, j + len - k, k,c1,c2,memo) && dfs(i + k, j, len - k,c1,c2,memo)) {
            memo[i][j][len] = 2;
            return true;
        }
    }
    memo[i][j][len] = 1;
    return false;
}
```
# 88. Merge Sorted Array(简单)
    You are given two integer arrays nums1 and nums2, sorted in **non-decreasing order**, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

    Merge nums1 and nums2 into a single array sorted in **non-decreasing order**.
    The final sorted array should not be returned by the function, but instead be **stored inside the array nums1**. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

* **约束**
  * `nums1.length == m + n`
  * `nums2.length == n`
  * `0 <= m, n <= 200`
  * `1 <= m + n <= 200`
  * `-10^9 <= nums1[i], nums2[j] <= 10^9`
* **思路**：归并排序的归并函数
```java
public void merge(int[] nums1, int m, int[] nums2, int n) { // 归并排序的合并方法
    if(n == 0) return;
    int[] tmp = new int[m]; 
    for(int i = 0;i<m;i++){
        tmp[i] = nums1[i];
    }
    int i = 0,j=0;
    for(int k = 0;k<nums1.length;k++){
        if(i==m) nums1[k] = nums2[j++];
        else if(j==n) nums1[k] = tmp[i++];
        else if(nums2[j]-tmp[i]<0) nums1[k] = nums2[j++];
        else nums1[k] = tmp[i++];
    }
}
```

# 94. Binary Tree Inorder Traversal(简单)
    Given the root of a binary tree, return the **inorder** traversal of its nodes' values.

* **约束**
  * The number of nodes in the tree is in the range `[0, 100]`.
  * `-100 <= Node.val <= 100`
* **思路**: 深度优先(左中右)
  * **递归**
```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    if(root == null ) return list;
    if(root.left !=null){
        list.addAll(inorderTraversal(root.left));
    }
    list.add(root.val);
    if(root.right !=null){
        list.addAll(inorderTraversal(root.right));
    }
    return list;
}
```

# 100. Same Tree(简单)
    Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

    Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

* **约束**
  * The number of nodes in both trees is in the range `[0, 100]`.
  * `-104 <= Node.val <= 104`
  * `p` and `q` are both binary trees.
* **思路**: 递归
```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    if(p == null && q == null) return true;
    if ((p==null && q !=null)||(p!=null && q ==null)) return false;
    if(p.val != q.val) return false;
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
```

# 101. Symmetric Tree(简单)
    Given the `root` of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

* **约束**
  * The number of nodes in the tree is in the range `[1, 1000]`.
  * `-100 <= Node.val <= 100`
* **思路**: 递归,分治法
```java
public boolean isSymmetric(TreeNode root) {
    if(root==null) return true;
    return isSymmetric(root.left,root.right);
}
public boolean isSymmetric(TreeNode left,TreeNode right) {
    if(left==null && right==null) return true;
    if(left==null || right==null) return false;
    if(left.val!=right.val) return false;
    return isSymmetric(left.left,right.right) && isSymmetric(left.right,right.left);
}
```

# 104. Maximum Depth of Binary Tree(简单)
    Given the root of a binary tree, return its maximum depth.

    A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

* **约束**
  * The number of nodes in the tree is in the range `[0, 104]`.
  * `-100 <= Node.val <= 100`
```java
public int maxDepth(TreeNode root) {
    if(root == null) return 0;
    if(root.left == null && root.right == null) return 1;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) +1;
}
```

# 108. Convert Sorted Array to Binary Search Tree(简单)
    Given an integer array `nums` where the elements are sorted in **non-decreasing order**, convert `it` into a **height-balanced** binary search tree.

    A **height-balanced** binary tree is a binary tree in which the depth of the two subtrees of every node **never differs by more than one**.

* **约束**
  * `1 <= nums.length <= 10^4`
  * `-10^4 <= nums[i] <= 10^4`
* **思路**: 递归,分治
  * 对半分,左半部分为左子树,右半部分为右子树
  * 即中间节点为父节点`lo+(hi-lo)/2`
  * **注意**：要判断`lo,hi`是否越界和有效
```java
public TreeNode sortedArrayToBST(int[] nums) {
    if(nums.length==0) return null;
    if(nums.length==1) return new TreeNode(nums[0]);
    return buildTree(nums,0,nums.length-1);
}

public TreeNode buildTree(int[] nums,int lo,int hi) {
    if(hi<lo) return null;
    int mid = lo+(hi-lo)/2;
    TreeNode root = new TreeNode(nums[mid]);
    root.left = buildTree(nums,lo,mid-1);
    root.right = buildTree(nums,mid+1,hi);
    return root;
}
```

# 110. Balanced Binary Tree(简单)
    Given a binary tree, determine if it is height-balanced.

    A binary tree is **height-balanced** if the depth of the two subtrees of every node never differs by more than one.

* **约束**
  * The number of nodes in the tree is in the range `[0, 5000]`.
  * `-10^4 <= Node.val <= 10^4`
* **思路**：递归，分治法
  * 平衡二叉树：左右子树高度差不超过1
  * 既判断当前节点是否平衡，也要判断左右子树是否平衡
* **改进**：由于存在height重复计算问题，可以使用动态规划
  * 在计算左右子树高度时，判断左右子树是否平衡
```java
// 平衡二叉树：左右子树高度差不超过1
public boolean isBalanced(TreeNode root) {
    if(root == null) return true;
    return Math.abs(height(root.left) - height(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
}
public int height(TreeNode node){
    if(node == null) return 0;
    return Math.max(height(node.left),height(node.right))+1;
}


// 改进版：使用动态规划，在计算左右子树高度时，判断左右子树是否平衡
public boolean isBalanced(TreeNode root) {
    return checkHeight(root) != -1; // -1表示不平衡
}
private int checkHeight(TreeNode node) {
    if (node == null) return 0;
    
    int leftHeight = checkHeight(node.left);
    if (leftHeight == -1) return -1; // 左子树不平衡
    
    int rightHeight = checkHeight(node.right);
    if (rightHeight == -1) return -1; // 右子树不平衡
    
    if (Math.abs(leftHeight - rightHeight) > 1) return -1; // 当前节点不平衡
    
    return Math.max(leftHeight, rightHeight) + 1; // 返回当前节点高度
}
```
# 111. Minimum Depth of Binary Tree(简单)
    Given a binary tree, find its minimum depth.

    The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

* **约束**
  * The number of nodes in the tree is in the range `[0, 10^5]`.
  * `-1000 <= Node.val <= 1000`
* **思路**：递归，分治法
  * 若节点一支为空，则以另一支结果为结果
* **改进**
  * 记忆最小值，用于叶子节点高度对比
  * 增加叶子节点判断，细化左右子树为空的情况
```java
// 叶子节点：没有左右子节点
public int minDepth(TreeNode root) {
    if(root == null) return 0;
    if(root.left == null && root.right == null) return 1;
    if(root.left == null) return minDepth(root.right)+1;
    if(root.right == null) return minDepth(root.left)+1;
    return Math.min(minDepth(root.left),minDepth(root.right))+1;
}

// 改进版：增加叶子节点判断，细化左右子树为空的情况
private int minHeight = Integer.MAX_VALUE;
public int minDepth(TreeNode root) {
    if(root == null) return 0;
    dfs(root,0);
    return minHeight;
}
public void dfs(TreeNode node,int height){
    height++;
    if (height == minHeight) 
        return;
    
    if(isLeaf(node)){
        minHeight = Math.min(minHeight,height); // 更新最小值
        return;
    }
    if (node.left != null && (node.right==null || !isLeaf(node.right))) // 确定另一支非叶子节点
        dfs(node.left,height);
    
    if(node.right!=null)
        dfs(node.right,height);
}
public boolean isLeaf(TreeNode node){
    return node.left == null && node.right == null;
}
```

# 112. Path Sum(简单)
    Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a root-to-leaf path such that adding up all the values along the path equals `targetSum`.

    A **leaf** is a node with no children.

* **约束**
* The number of nodes in the tree is in the range `[0, 5000]`.
  * `-1000 <= Node.val <= 1000`
  * `-1000 <= targetSum <= 1000`
* **思路**：递归,回溯法
  * **注意**：`targetSum,val`可能为负数，不要直接判断`sum>targetSum`就返回false
```java
/**
 * 1. root == null return false
 * 2. sum == targetSum and root is leaf return true
 * 3. targetSum may be negative
 * 4. val may be negative
 */
public boolean hasPathSum(TreeNode root, int targetSum) {
    return hasPathSum(root, targetSum,0);
}

public boolean hasPathSum(TreeNode root, int targetSum, int sum) {
    if(root == null) return false;
    sum += root.val;

    if(isLeaf(root)) return sum == targetSum;

    // sum <=targetSum and root is not leaf
    if(hasPathSum(root.left,targetSum,sum)) return true;
    else if(hasPathSum(root.right,targetSum,sum)) return true;

    // (root.left!=null || root.right!=null) and hashPathSum = false
    return false;
}
public boolean isLeaf(TreeNode root){
    return root.left==null && root.right==null;
}
```

# 118. Pascal's Triangle(简单,帕斯卡三角形)
    Given an integer `numRows`, return the first numRows of Pascal's triangle.

    In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

```txt
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1
..........
```

* **约束**
  * `1 <= numRows <= 30`
* **思路**：动态规划
  * 了解帕斯卡三角形规律
    * 每行元素数等于行数
    * 每一行的首尾数字都是1
    * 每一行中间的数字等于上一行中相邻两个数字的和
      * 上一行同索引和前一个索引对应值和，除1，2外
      * 每行元素从中间开始对称
* **改进**：**优化空间复杂度**
  * 当前行中，初始数为1
  * 同一行中，每一个索引数值是前一个数值的倍数(`行数-行内索引值`)，除以`行内索引`
```java
public List<List<Integer>> generate(int numRows) {
    if(numRows==0) return null;
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> pre=null;
    int cur = 0;
    while (cur<numRows) {
        List<Integer> curList = new ArrayList<>(cur+1);
        if(cur < 2){
            for(int i = 0;i<= cur;i++){
                curList.add(1);
            }
        }
        else {
            curList.add(1);
            for(int j = 1;j<cur;j++){
                curList.add(pre.get(j-1)+pre.get(j));
            }
            
            curList.add(1);
        }
        pre = curList;
        cur++;
        res.add(curList);
    }
    return res;
}
// 递归版实现
public List<List<Integer>> generate(int numRows) {
    List<List<Integer>> res = new ArrayList<>();
    generate(numRows,res);
    return res;
}
public void generate(int row,List<List<Integer>> res) {
    List<Integer> curList = new ArrayList<>();
    if(row < 2){
        for(int i = 0;i< row;i++) curList.add(1);
        res.add(curList);
        return;
    }
    int preRow = row-1;
    generate(preRow,res);
    List<Integer> pre = res.get(preRow-1);
    curList.add(1);
    for(int j = 1;j<preRow;j++) curList.add(pre.get(j-1)+pre.get(j));
    curList.add(1);
    res.add(curList);
}

// 优化版：自定义是实现AbstractList
public List<List<Integer>> generate(int numRows) {
    return new AbstractList<List<Integer>>() {
        List<List<Integer>> res;
        void init(){
            if(res!=null) return;
            res = new ArrayList<>();
            generate(numRows);
        }
        void generate(int row){
            List<Integer> curList = new ArrayList<>();
            if(row < 2){
                for(int i = 0;i< row;i++) curList.add(1);
                res.add(curList);
                return;
            }
            int preRow = row-1;
            generate(preRow);
            List<Integer> pre = res.get(preRow-1);
            curList.add(1);
            for(int j = 1;j<preRow;j++) curList.add(pre.get(j-1)+pre.get(j));
            curList.add(1);
            res.add(curList);
        }
        @Override
        public List<Integer> get(int index) {
            init();
            return res.get(index);
        }
        @Override
        public int size() {
            init();
            return numRows;
        }
    };
}

// 改进版：优化空间复杂度
public List<List<Integer>> generate(int numRows) {
    List<List<Integer>> res = new ArrayList<>();
    for (int i = 0; i < numRows; i++) {
        List<Integer> curList = new ArrayList<>();
        int num = 1;
        for (int j = 0; j <= i; j++) {
            if (j == 0 || j == i) curList.add(1);
            else {
                num = num*(i-j+1)/j;
                curList.add(num);
            }
        }
        res.add(curList);
    }
    return res;
}
```

# 119. Pascal's Triangle II(简单,帕斯卡三角形)
    Given an integer `rowIndex`, return the `rowIndex`-th row of the Pascal's triangle.

    In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

* **约束**
  * `0<= rowIndex <= 33`
* **思路**：[参考118题的当前行生成方法](#118-pascals-triangle简单帕斯卡三角形))
  * 注意：
    * `rowIndex`从`0`开始
    * `num`可能会超出`int`范围
```java
public List<Integer> getRow(int rowIndex) {
    List<Integer> res = new ArrayList<>();
    long num = 1;
    for (int j = 0; j <= rowIndex; j++) {
        if (j == 0 || j == rowIndex) {
            res.add(1);
        } else {
            num = (int)(num*(rowIndex-j+1)/j);
            res.add(num);
        }
    }
    return res;
}
```

# 121. Best Time to Buy and Sell Stock(简单)
    You are given an array prices where prices[i] is the price of a given stock on the ith day.

    You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
    Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.

* **约束**
  * `1 <= prices.length <= 10^5`
  * `0 <= prices[i] <= 10^4`
* **思路**：**暴力枚举**
  * 规则
    * 先买后卖，不能是同一天
    * 负收入则不买卖
  * 算法逻辑：
    * 前一天买价，与后边所有天卖价差值取最大
    * 将前一天后移一天，重复取差值最大
    * 知道最后一天，无法取差值，终止
    * 返回最大差值
  * **循环过多，容易超时**
* **改进**: **双指针法**
  * 分别记录，前一天买价和后一天卖价
  * 若卖价高于买价，则计算最大差值
  * 否则，更新买价为当前卖价，卖价后移一天
```java
// 普通版
public int maxProfit(int[] prices) {
    int max = 0;
    for(int i = 0;i<prices.length-1;i++){
        for (int j = i+1; j < prices.length; j++) {
            max = Math.max(max,prices[j]-prices[i]);
        }
    }
    return max<0?0:max;
}

// 改进版
public int maxProfit(int[] prices) {
    int min = prices[0],max = 0;
    for(int i = 1;i<prices.length;i++){
        if(prices[i]>min) max = Math.max(max,prices[i]-min);
        else  min = prices[i];
    } 
    return max<0?0:max;
}
```

# 125. Valid Palindrome(简单)
    A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

    Given a string s, return true if it is a palindrome, or false otherwise.

* **约束**
  * `1 <= s.length <= 2*10^5`
  * `s` consists only of printable `ASCII` characters.
* **思路**：**双指针法**
  * 字符统一大小写
  * 前后指针过滤**非字母/数字**字符
  * 比较前后指针指向的字符是否相等，不等直接返回false
  * 最后返回true
```java
public boolean isPalindrome(String s) {
    s = s.toUpperCase();
    int lo=0,hi = s.length()-1;
    char lc,hc;
    while(lo<hi){
        for(lc = s.charAt(lo);!isVaild(lc);lo++,lc = s.charAt(lo)) if(lo == hi) break;
        for(hc = s.charAt(hi);!isVaild(hc);hi--,hc = s.charAt(hi)) if(hi == lo) break;
        if (lc != hc) return false;
        lo++;hi--;
    }
    return true;
}
public boolean isVaild(char c){
    return (c>=65 && c<=90) || (c>=48 && c<=57);
}
```

# 136. Single Number(简单)
    Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

    You must implement a solution with a linear runtime complexity and use only constant extra space.

* **约束**
  * `1 <= nums.length <= 3 * 10^4`
  * `-3 * 10^4 <= nums[i] <= 3 * 10^4`
  * Each element in the array appears twice except for one element which appears only once.
* **思路**：
  * 只有一个数字是单独的，其它的都是成双的
  * 可以将所有非记录的数字记录，已记录的移除，剩余的就是单独的数字
  * 选用利于查询的数据结构，如`HashSet`
* **改进**
  * 通过**异或**运算，相同的数字异或结果为`0`，`0`与任何数字异或结果为该数字
```java
public int singleNumber(int[] nums) {
    List<Integer> list = new ArrayList<>();
    for(int i:nums){
        if(list.contains(i)){
            list.remove(Integer.valueOf(i));
        }else{
            list.add(i);
        }
    }
    return list.get(0);
}

// 改进版
public int singleNumber(int[] nums) {
    int index=0;
    for(int i=0;i<nums.length;i++){
        index=index^nums[i];
    }
    
    return index;
}
```

# 141. Linked List Cycle(简单)
    Given head, the head of a linked list, determine if the linked list has a cycle in it.

* **约束**
  * The number of the nodes in the list is in the range [0, 10^4].
  * `-10^5 <= Node.val <= 10^5`
  * pos is `-1` or a **valid index** in the linked-list.
* **思路**：记忆法，通过额外数据结构(如`Set`)存储已筛选过的节点，若后面(`next`)包含，则说明有环
* **改进**: **快慢指针法**
```java
public boolean hasCycle(ListNode head) {
    Set<ListNode> set = new HashSet<>();
    while(head!=null){
        if(set.contains(head)) return true;
        set.add(head);
        head = head.next;
    }
    return false;
}

// 改进版
public boolean hasCycle(ListNode head) {
    ListNode slow = head,fast = head;
    while(fast!=null && fast.next!=null){
        slow = slow.next;
        fast = fast.next.next;
        if(slow == fast) return true;
    }
    return false;
}
```
# 144. Binary Tree Preorder Traversal(简单)
    Given the root of a binary tree, return the preorder traversal of its nodes' values.

* **约束**
  * The number of nodes in the tree is in the range `[0, 100]`.
  * `-100 <= Node.val <= 100`
* **思路**：**深度优先算法，先处理根节点，后递归遍历左右子树**
```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    dfs(root,list);
    return list;
}

public void dfs(TreeNode root,List<Integer> list) {
    if(root == null) return;
    list.add(root.val);
    dfs(root.left,list);
    dfs(root.right,list);
}
```

# 145. Binary Tree Postorder Traversal(简单)
    Given the root of a binary tree, return the postorder traversal of its nodes' values.

* **约束**
  * The number of nodes in the tree is in the range `[0, 100]`.
  * `-100 <= Node.val <= 100`
* **思路**：**深度优先算法，先递归遍历左右子树,后处理根节点**(与144题的区别)
```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<>();
    dfs(root,list);
    return list;
}


public void dfs(TreeNode root,List<Integer> list) {
    if(root == null) return;
    dfs(root.left,list);
    dfs(root.right,list);
    list.add(root.val);
}
```

# 157. Read N Characters Given Read4(中等)
    Given a file and assume that you can only read the file using a given method `read4`, implement a method to read n characters.

    Method `read4`: The API read4 reads 4 consecutive characters from the file, then returns the number of actual characters read. The return value is equal to the number of characters read.

    By using the read4 API, implement the function read:

    The function `read` should return the next `n` characters read from the file. The return value is the actual number of characters read. If the number is less than `n`, an end-of-file marker, represented by `EOF`, is returned instead. If the end of the file is reached, return `EOF`.

    The read function may be called multiple times.

* **约束**
  * `1 <= read4(char[]) <= 4`
  * `0 <= n <= 100`
  * `Position for next read is kept by the system`
  * You may assume that the destination buffer array, `buf`, is guaranteed to have enough space for storing `n` characters.
  * It is guaranteed that in a given test case the size of the output will always be at least `n`.
* **思路**
  * 从`read4`中读取数据(每次最多4个字符)，数据存入临时`char[] tmp`
  * 有数据并且实际读取长度`len`不足`n`时，继续读取，否则直接退出
  * 若没有数据，则退出循环
```java
public int read(char[] buf, int n) {
    int len = 0;
    int count = 0;
    char[] temp = new char[4];
    while((count = read4(temp))!=0){
        for(int i = 0;i<count;i++){
            if (len<n) buf[len++] = temp[i];
            // else return len; // 存在 n%4=0，当数据读取后 len=n 还会继续读取一次
            if(len==n) return len; // 满了立即退出
        } 
    }
    return len;
}
```

# 160. Intersection of Two Linked Lists(简单)
Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.

For example, the following two linked lists begin to intersect at node c1:

![image](https://assets.leetcode.com/uploads/2021/03/05/160_statement.png)
    
The test cases are generated such that there are no cycles anywhere in the entire linked structure.

Note that the linked lists must retain their original structure after the function returns. You must not modify the lists.

* **约束**
  * The number of nodes of `listA` is in the `m`.
  * The number of nodes of `listB` is in the `n`.
  * `1 <= m, n <= 3 * 10^4`
  * `1 <= Node.val <= 10^5`
  * `0 <= skipA <= m`
  * `0 <= skipB <= n`
  * `intersectVal` is `0` if `listA` and `listB` do not intersect.
  * `intersectVal == listA[skipA] == listB[skipB]` if `listA` and `listB` intersect.
* **思路**: 
  * 先分别获取链表长度
  * 长链表跳过多余节点，使两链表长度一致
  * 循环对比节点是否等同(**注意：是节点相等，不是节点值**)
```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    int m=0,n=0;
    ListNode nodeA = headA,nodeB = headB;
    // 获取链表长度
    while (nodeA!=null) {
        nodeA = nodeA.next;
        m++;
    }
    while (nodeB!=null) {
        nodeB = nodeB.next;
        n++;
    }
    // 处理为同等长度链表
    if(m>n){
        for(int skipa = m-n;skipa>0;skipa--){
            headA = headA.next;
        }
    }else if(n>m){
        for(int skipb = n-m;skipb>0;skipb--){
            headB = headB.next;
        }
    }
    // 循环对比节点值是否等同
    boolean flag = false;
    ListNode next = null;
    while (headA!=null && headB!=null) {
        if (headA == headB) {
            if (!flag){ // 第一次找到，则记录
                flag = true;
                next = headA;
            }
        }else{ // 不等重新置为空
            next = null;
        }
        headA = headA.next;
        headB = headB.next;
    }
    return next;
}
```

# 163. Missing Ranges(中等)
You are given an inclusive range [lower, upper] and a sorted unique integer array `nums` (0-indexed) where `nums` is the subset of the range `[lower, upper]`.

Return the smallest sorted list of ranges that cover every number in the range `[lower, upper]` that is not present in `nums`.

A valid range will be represented as a string in the form `"lower->upper"`, where `lower <= upper`. If there is only one number in the range, it will be represented as `"lower"` without the double hyphen. Also, two adjacent ranges `num1->num2` and `num3->num4` should be combined into one range `"num1->num4"` if they overlap.

* **约束**
  * `-10^9 <= lower <= upper <= 10^9`
  * `0 <= nums.length <= 100`
  * `lower <= nums[i] <= upper`.
  * `nums` contains no duplicate elements.
  * `nums` is sorted in ascending order.
* **思路**
```java
public List<String> FindMissingRanges(int[] nums, int lower, int upper) {
    List<String> res = new ArrayList<>();
    int pre = lower;
    for(int num:nums){
        if(num>pre) { // 不等，则判断是否在区间内，只可能时num>pre，不存在num<pre
            format(res,pre,num-1);
        }
        pre= num+1;// 无论上面如何处理，pre都前移至num+1
    }
    format(res,pre,upper); // nums[length-1] < upper
    return res;
}
public void format(List<String> res,int start,int end){
    if(start==end) res.add(String.valueOf(start)); // 单个元素
    else res.add(start+"->"+end); // 区间
}
```

# 168. Excel Sheet Column Title(简单)
Given an integer `columnNumber`, return its corresponding column title as it appears in an Excel sheet.

```txt
For example:
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
```

* **约束**
  * `1 <= columnNumber <= 2^31 - 1`
* **思路**: 
  * 实质为26进制数
  * 先计算余数，倍数`余数=倍数%26，倍数=倍数/26`
  * 余数为0，则追加`Z`，倍数减1
  * 余数不为0，则追加`余数+64`
  * 倍数不为0，则继续循环
  * 使用`StringBuilder`追加字符，最后反转
  * **注意**：`do...while,while,for`的执行逻辑区别
```java
public String convertToTitle(int columnNumber) {
    StringBuilder sb = new StringBuilder();
    int m =columnNumber,n=0;
    do{
        n = m%26;
        m = m/26;
        if (n == 0) m--;
        sb.append(n>0? (char)(n+64):'Z');
    }while(m>0);
    sb.reverse();
    return sb.toString();
}
```

# 169. Majority Element(简单)
Given an array `nums` of size `n`, return the majority element.

The majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.

* **约束**
  * `n == nums.length`
  * `1 <= n <= 5 * 10^4`
  * `-10^9 <= nums[i] <= 10^9`
  * The majority element is in `nums`.
* **思路**
  * 多数元素大于n/2
  * 找一个数据结构(**Map结构**)存储元素+计数，当计数大于n/2时，返回该元素
```java
public int majorityElement(int[] nums) {
    Map<Integer,Integer> map = new HashMap<>();
    int mid = nums.length/2;
    for(int num:nums){
        map.put(num,map.getOrDefault(num,0)+1);
        if(map.get(num)>mid) return num;
    }
    return -1;
}
```

# 170. Two Sum III - Data Structure Design(简单)
Design a data structure that accepts a stream of integers and checks if it has a pair of integers that sum up to a given value.

Implement the `TwoSum` class:
```markdown
* `TwoSum()` Initializes the `TwoSum` object, with an empty array initially.
* `void add(int number)` Adds the number to the data structure.
* `boolean find(int value)` Returns `true` if there exists any pair of numbers which sum is equal to the value, otherwise, return `false`.
```

* **约束**
  * `-10^5 <= number, value <= 10^5`
  * At most `5000` calls will be made to `add` and `find`.
* **思路**
  * 找一个数据结构存储`add`添加的元素
  * 从这个数据结构中双层循环，查找**两两之和**是否给定值
* **改进**:
  * 数据结构的选择改进：利于查询，如Map
  * 可以先排序，二分查找法，差值法
```java
static class TwoSum {
    private List<Integer> list = new ArrayList<>();
    public TwoSum(){}
    public void add(int number) {
        list.add(number);
    }
    public boolean find(int value) {
        for(int i = 0;i<list.size();i++){
            for(int j = i+1;j<list.size();j++){
                if(list.get(i)+list.get(j)==value) return true;
            }
        }
        return false;
    }
}

// 改进版：List+Sort+BinarySearch
public boolean find(int value) {
    Collections.sort(list);
    int left = 0,right = list.size()-1;
    while(left<right){
        int twoSum = list.get(left)+list.get(right);
        if(twoSum==value) return true;
        if(twoSum<value) left++;
        else right--;
    }
    return false;
}

// 改进版：Map + 差值法
public boolean find(int value) {
    for(int num:map.keySet()){
        int target = value - num;
        if(map.containsKey(target)){
            if(num == target && map.get(num) > 1) return true;
            if(num != target) return true;
        }
    }
    return false;
}
```

# 171. Excel Sheet Column Number(简单)
Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.

```txt
For example:
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
```

* **约束**
  * `1 <= columnTitle.length <= 7`
  * `columnTitle` consists only of uppercase English letters.
  * `columnTitle` is in the range `["A", "FXSHRXW"]`.
* **思路**: 与十进制转26进制逻辑相反，[参考168题](#168-excel-sheet-column-title简单)
  * 从左向后循环，每循环依次，前一个和*26+当前数
* **改进**
  * 每个运算表达式，数据类型尽量保持一致，并且复杂运算独立成变量
```java
public int titleToNumber(String columnTitle) {
    int sum = 0;
    for(int i = 0;i<columnTitle.length();i++){
        char c = columnTitle.charAt(i);
        int val = c-'A'+1;
        sum = sum*26 + val;
        // sum = sum*26 + (columnTitle.charAt(i)-'A'+1);
    }
    return sum;
}
```

# 175. Combine Two Tables(简单)
```txt
`Person` table:
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId is the primary key column for this table.

`Address` table:
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| addressId   | int     |
| personId    | int     |
| city        | varchar |
| state       | varchar |
+-------------+---------+
```

**Write an SQL query to report the first name, last name, city, and state of each person in the `Person` table. If the address of a person is not present in the `Address` table, report null instead.**

Return the result table in **any order**.

* **思路** : 左连接`LEFT JOIN`
```sql
-- 不清楚为啥相同的逻辑，leetcode执行时间来回跳动
-- select `FirstName`,`LastName`,`city`,`state` from Person p left join Address a on p.PersonId = a.personId;

SELECT FirstName,LastName,city,state
FROM Person
LEFT JOIN Address
ON Person.PersonId = Address.personId;
```

# 181. Employees Earning More Than Their Managers(简单)
```txt
`Employee` table:
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| name        | varchar |
| salary      | int     |
| managerId   | int     |
+-------------+---------+
```

**Write a solution to find the employees who earn more than their managers.**

Return the result table in **any order**.

* **思路** : `salary`超过经理的员工
  * **注意**：`JOIN`方式适合扩展属性，`WHERE`适合筛选数据
```sql
select e1.`name` as `Employee` from Employee e1 ,Employee e2 where  e1.managerId = e2.id AND e1.salary > e2.salary
```

# 182. Duplicate Emails(简单)
```txt
`Person` table:
+----+---------+
| id | email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
```

**Write an SQL query to report all the duplicate emails.** 
Return the result table in **any order**.

* **思路**: `GROUP BY ... HAVING`分组查询
```sql
select email as Email from person group by email having count(email) > 1;
```

# 183. Customers Who Never Order(简单)
```txt
Table: Customers
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| name        | varchar |
+-------------+---------+

Table: Orders
+-------------+------+
| Column Name | Type |
+-------------+------+
| id          | int  |
| customerId  | int  |
+-------------+------+
```
**Write a solution to find all customers who never order anything.**
* **思路**: `NOT IN`
```sql
select name as Customers from Customers where id not in (select customerId from Orders)
```

# 190. Reverse Bits(简单)
Reverse bits of a given 32 bits unsigned integer.

Note:
```markdown
* Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.  
* In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.
```

* **约束**：The input must be a binary string of length `32`
* **思路**: 字符反转
  * 通过`StringBuilder`将`int`类型转为二进制字符串，然后反转`reverse()`
  * **根据高位符号位判断是否为负数**，若是负数，则去掉符号位，转为正数
  * 将二进制字符串转为`int`类型，并根据符号位返回结果
* **改进**
  * 每次两次(**按位或**)通过与特定bits进行(**按位与**)，并右移指定位数
    * 按位或：`|`，只要两个位有一个为1，结果就为1
    * 按位与：`&`，两个位都为1，结果才为1
  * 分别交换**16，8，4，2，1**位
```java
// you need treat n as an unsigned value
public int reverseBits(int n) {
    StringBuilder sb = new StringBuilder(32);
    sb.append(n < 0 ? '1' : '0');
    for (int i = 30; i >= 0; i--) {
        sb.append((n & (1 << i)) != 0 ? '1' : '0');
    }
    sb.reverse();
    String bitString = sb.toString();
    boolean isNegative = false;
    if (bitString.charAt(0) == '1') {
        bitString = bitString.substring(1, bitString.length());
        isNegative = true;
    }
    int num = Integer.valueOf(bitString,2);
    return isNegative?-num:num;
}

public int reverseBits(int num) {
    num = ((num & 0xffff0000) >>> 16) | ((num & 0x0000ffff) << 16);
    num = ((num & 0xff00ff00) >>> 8) | ((num & 0x00ff00ff) << 8);
    num = ((num & 0xf0f0f0f0) >>> 4) | ((num & 0x0f0f0f0f) << 4);
    num = ((num & 0xcccccccc) >>> 2) | ((num & 0x33333333) << 2);
    num = ((num & 0xaaaaaaaa) >>> 1) | ((num & 0x55555555) << 1);
    return num;
}
```

# 191. Number of 1 Bits(简单)
Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).

Note:
* Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.  
* In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.

* **约束**：`1 <= n <= 2^31 - 1`
* **思路**: **与位运算**
  * 每位bit与`1`进行**按位与**运算，若结果为`1`，则计数器加一
```java
public int hammingWeight(int n) {
    int count = 0;
    for (int i = 31; i >= 0; i--) {
        count += (n & (1 << i)) != 0 ? 1 : 0;
    }
    return count;
}
```
# 193. Valid Phone Numbers(简单)

    Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers.

    You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)

    You may also assume each line in the text file must not contain leading or trailing white spaces.

* **思路**: `grep`正则表达式
  * 纯数字可使用`\d`表示(**注意**：`\d`代表所有Unicode的数字，`0-9`代表ASCII的数字,使用时要**注意编码环境**)
  * `\s`匹配空白字符` ,\t,\n`(也需要注意编码环境，如果仅空格，推荐直接使用空格` `)
  * `^`表示字符串开始，`$`表示字符串结束
  * `()`表示分组，`|`表示或
  * `[]`表示范围，`-`表示范围中的连接符
  * `{n}`表示重复n次
  * `\`进行转义
* **改进**：只是为了更快
  * 通过`shell`语法
```bash
grep -P '^(\(\d{3}\) |\d{3}-)\d{3}[-]\d{4}$' file.txt

# 改进版
p=\([0-9][0-9][0-9]\)\ [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]
p1=[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]

while read -r line 
 do
  case "$line" in
  $p)
  echo $line
  ;;
  $p1)
  echo $line
  ;;
  esac
 done < file.txt
```

# 195. Tenth Line(简单)
Given a text file file.txt, print just the 10th line of the file.

* **思路**: 
  * `sed`命令
  * `shell`语法
```bash
sed -n '10p' file.txt

# 改进版
n=1
while read -r line; do
    if [ $n -eq 10 ]; then
        echo "$line"
        break
    fi
    ((n++))

done < file.txt
```
# 196. Delete Duplicate Emails(简单)
Write a solution to delete all duplicate emails, keeping only one unique email with the smallest id.

For SQL users, please note that you are supposed to write a DELETE statement and not a SELECT one.

For Pandas users, please note that you are supposed to modify Person in place.

After running your script, the answer shown is the Person table. The driver will first compile and run your piece of code and then show the Person table. The final order of the Person table does not matter.
```txt
Table: Person

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| email       | varchar |
+-------------+---------+
```

* **思路**:
  * 分组寻找最小id
  * 删除非最小id的行数据
* **注意**
  * mysql5.7后，`group by`与`select`存在关联限制
  * `delete`与`where`子查询不能是同一个表
```sql
-- 使用group by时，select的内容必需在group by中或使用聚合函数
-- delete from和where子查询不能是同一个表，可以将子查询命令为临时表
delete from Person where id not in(select a.id from (select MIN(p1.id) as id from Person p1 GROUP BY p1.email) as a)
```

# 197. Rising Temperature(简单)
Given a Weather table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.

```txt
Table: Weather

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| recordDate    | date    |
| temperature   | int     |
+---------------+---------+
```
Write a solution to find all dates' id with higher temperatures compared to its previous dates (yesterday).

* **思路**:
  * 同一个表代表两个表数据，分别是当天和前一天
  * 判断当天是前一天+1的日期(日期函数`date_add`)
  * 判断当天温度大于前一天
```sql
-- 隐式连接，更符合SQL语法，支持主流SQL数据(兼容性好)
select w1.id from Weather w1, Weather w2 where
w1.recordDate = date_add(w2.recordDate, interval 1 day) and w1.temperature > w2.temperature

-- JOIN + ON 可读性好，现代SQL，
SELECT W1.id as Id
FROM Weather W1
INNER JOIN Weather W2
    ON W1.recordDate = DATE_ADD(W2.recordDate, INTERVAL 1 DAY)
WHERE W1.temperature > W2.temperature;
```

# 202. Happy Number(简单)
Write an algorithm to determine if a number n is happy.

```markdown
A happy number is a number defined by the following process:
* Starting with any positive integer, replace the number by the sum of the squares of its digits.
* Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
* Those numbers for which this process ends in 1 are happy.

Return True if n is a happy number, and False if not.
```
* **约束**
  * `1 <= n <= 2^31 - 1`
* **思路**:
  * 数字转字符
  * 字符对每一位进行平方求和
  * 结果为1，退出返回true，
  * 增加所有校验数字的集合，如果存在，代表陷入循环，则返回false
* **改进**
  * 求开方：以10为底，循环求余数平方和，数赋值为商，直至数等于0，返回结果
  * 使用快慢双指针法，当快慢指针相遇时，代表陷入循环
```java
public boolean isHappy(int n) {
    return isHappy(n,new HashSet<Integer>());
}
public boolean isHappy(int n,Set<Integer> set) {
    if (set.contains(n)) return false; // 当数字重复的时候，代表进入循环，返回false
    set.add(n);
    String str = String.valueOf(n);
    int sum = 0;
    for(int i = 0;i<str.length();i++){
        sum += Math.pow(str.charAt(i)-'0',2);
    }
    if(sum == 1) return true;
    return isHappy(sum,set);
}

// 改进版：快慢指针
public boolean isHappy(int n) {
    int slow = n,fast = n;
    do{
        slow = findSqr(slow);
        fast = findSqr(findSqr(fast));
    }while(slow != fast);
    return slow == 1;
}
private int findSqr (int number){ // 重点
    int ans=0;
    while(number>0){
        int rem = number %10;
        ans += rem *rem;
        number/=10;
    }
    return ans;
}
```

# 203. Remove Linked List Elements(简单)
Given the head of a linked list and an integer `val`, remove all the nodes of the linked list that has `Node.val == val`, and return the new head.


* **思路**: **双指针法或递归法**
  * 增加辅助节点`first,pre,next`
  * 循环遍历`next=next.next!=null`
  * 判断`next.val == val`，删除节点`pre.next = next.next`
  * 否则`pre=next`
* **改进**
```java
// 双指针法
public ListNode removeElements(ListNode head, int val) {
    ListNode first = new ListNode(-1,head),next = first,pre = first;
    while((next = next.next)!=null){
        if(next.val == val) pre.next = next.next;
        else  pre = next;
    }
    return first.next;
}

// 递归法
public ListNode removeElements(ListNode head, int val) {
    if(head == null) return null;
    if (head.val == val) {
        return removeElements(head.next, val);
    }
    head.next = removeElements(head.next, val);
    return head;
}
```

# 205. Isomorphic Strings(简单)
Given two strings `s` and `t`, determine if they are isomorphic.

Two strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

* **约束**:
  * `1 <= s.length <= 5 * 10^4`
  * `s.length == t.length`
  * `s` and `t` consist of any valid ascii character.
* **思路**
  * 使用两个map，分别存储两个字符串的映射关系
  * 遍历字符串，判断两个map的映射关系是否与比较内容一致
  * **注意**：需要`s,t`两边都是一一映射
* **改进**：
  * **由于ASCII只有256位**，可以考虑使用`int存储char`的映射关系，减少空间复杂度
```java
public boolean isIsomorphic(String s, String t) {
    Map<Character,Character> map = new HashMap<>();
    Map<Character,Character> map2 = new HashMap<>();
    for (int i = 0; i < s.length(); i++) {
        map.putIfAbsent(s.charAt(i),t.charAt(i));
        map2.putIfAbsent(t.charAt(i), s.charAt(i));
        if(map.get(s.charAt(i))!=t.charAt(i) || map2.get(t.charAt(i))!=s.charAt(i)) return false;
    }
    return true;
}

// 改进版
public boolean isIsomorphic(String s, String t) {
    int[] map1 = new int[256];
    int[] map2 = new int[256];
    for (int i = 0; i < s.length(); i++) {
        char c1 = s.charAt(i);
        char c2 = t.charAt(i);
        if (map1[c1] != map2[c2]) return false;
        map1[c1] = i + 1;
        map2[c2] = i + 1;
    }
    return true;
}
```

# 206. Reverse Linked List(简单)
Given the head of a singly linked list, reverse the list, and return the reversed list.

* **约束**
  * The number of nodes in the list is the range [0, 5000].
  * -5000 <= Node.val <= 5000
* **思路**: **双指针法**
  * 准备辅助节点`first,next`
  * 循环遍历`head!=null`
  * 处理节点置换
    * 将`next=head`，并立即将`head=head.next`
    * 将`next.next=first.next`
    * 最后将`first.next=next`
```java
public ListNode reverseList(ListNode head) {
    ListNode first = new ListNode(-1),next;
    while(head!=null){
        next = head;
        head = head.next;
        next.next = first.next;
        first.next = next;
    }
    return first.next;
}
```
# 217. Contains Duplicate(简单)
Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

* **约束**
  * `1 <= nums.length <= 10^5`
  * `-10^9 <= nums[i] <= 10^9`
* **思路**
  * 使用`set`存储元素，判断`set.contains(num)`
  * 只要存储过元素，即代表有重复元素
* **改进**
  * 不借助`set`，使用**插入排序**逻辑，在中间判断是否重复
  * **注意**：考虑当前面所有数字都大于当前key情况时，要将key插入到最前面`nums[0]`
```java
public boolean containsDuplicate(int[] nums) {
    Set<Integer> set = new HashSet<>();
    for(int num:nums){
        if(set.contains(num)) return true;
        set.add(num);
    }
    return false;
}

// 改进
public boolean containsDuplicate(int[] nums) {
    for(int i = 1; i<nums.length; i++){
        int key = nums[i];
        int j = i - 1;
        while(j>=0 && nums[j] > key){
            nums[j+1] = nums[j];
            j--;
        }
        if(j>=0 && nums[j] == key)
            return true;
        nums[j+1] = key;
    }
    return false;
}
```

# 219. Contains Duplicate II(简单)
Given an integer array `nums` and an integer `k`, return `true` if there are two distinct indices `i` and `j` in the array such that `nums[i] == nums[j]` and `abs(i - j) <= k`.

* **约束**
  * `1 <= nums.length <= 10^5`
  * `-10^9 <= nums[i] <= 10^9`
  * `0 <= k <= 10^5`
* **思路**
  * 当前位置与前面所有对比，存在相同并且差距为k返回true
* **改进**
  * 使用Map存储元素索引，通过快速查询，减少内循环次数
```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    for(int i = 1; i<nums.length; i++){
        for(int j = i-1;j>=j+1;j--){
            if (nums[j] == nums[i] && i - j <= k) return true;
        }
    }
    return false;
}

// 改进版
public boolean containsNearbyDuplicate(int[] nums, int k) {
    Map<Integer,Integer> map = new HashMap<>();
    for(int i = 0;i<nums.length;i++){
        if(map.containsKey(nums[i]) && i-map.get(nums[i])<=k){
            return true;
        }
        map.put(nums[i],i);
    }
    return false;
}
```

# 222. Count Complete Tree Nodes(中等)
Given the `root` of a complete binary tree, return the number of the nodes in the tree.

According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.
Design an algorithm that runs in less than `O(n)` time complexity.

* **约束**
  * The number of nodes in the tree is in the range `[1, 10^4]`.
  * `0 <= Node.val <= 4000`
  * The tree is guaranteed to be complete.
* **思路**: 宽度优先搜索
```java
public int countNodes(TreeNode root) {
    if (root == null) return 0;
    return countNodes(root.left)+countNodes(root.right)+1;
}
```

# 225. Implement Stack using Queues(简单)
Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (`push`, `top`, `pop`, and `empty`).

```txt
Implement the `MyStack` class:
* `void push(int x)` Pushes element x to the top of the stack.
* `int pop()` Removes the element on the top of the stack and returns it.
* `int top()` Returns the element on the top of the stack.
* `boolean empty()` Returns `true` if the stack is empty, `false` otherwise.

Notes:
* You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.
* Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.
```

* **约束**
  * `1 <= x <= 9`
  * At most `100` calls will be made to `push`, `pop`, `top`, and `empty`.
  * All the calls `pop`, `top`, and `empty` are valid.
* **思路**：双向队列
  * **注意**：队列只能存储包装类，返回基本类型时需要验证
```java
class MyStack {
    Deque<Integer> queue;
    public MyStack() {
        this.queue  = new LinkedList<>();
    }
    
    public void push(int x) {
        queue.addLast(x);
    }
    
    public int pop() {
        return empty()?0:queue.pollLast();
    }
    
    public int top() {
        return empty()?0:queue.peekLast();
    }
    
    public boolean empty() {
        return queue.isEmpty();
    }
}
```
# 226. Invert Binary Tree(简单)
Given the `root` of a binary tree, invert the tree, and return its root.

* **约束**
  * The number of nodes in the tree is in the range `[0, 100]`.
  * `-100 <= Node.val <= 100`
* **思路**：递归,分治法
```java
public TreeNode invertTree(TreeNode root) {
    if(root == null) return null;
    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);
    root.left = right;
    root.right = left;
    return root;
}
```
# 228. Summary Ranges(简单)
You are given a sorted unique integer array `nums`.

A range `[a,b]` is the set of all integers from `a` to `b` (inclusive).

Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.
```markdown
Each range [a,b] in the list should be output as:
* `"a->b"` if `a != b`
* `"a"` if `a == b`
```

* **约束**
  * `0 <= nums.length <= 20`
  * `-2^31 <= nums[i] <= 2^31 - 1`
  * All the values of nums are unique.
  * `nums` is sorted in non-decreasing order.
* **思路**：双指针
  * 分别记录`start,end`
  * 每次重置`start=end=nums[i]`
* **改进**
  * 改用一个辅助变量`a`递增,减少变量
  * 用`StringBuilder`减少字符串拼接
```java
public List<String> summaryRanges(int[] nums) {
    List<String> res = new ArrayList<>();
    if(nums.length == 0) return res;
    int start = nums[0],end = start;
    for(int i = 1;i<nums.length;i++){
        if (end + 1 == nums[i]) {
            end = nums[i];
            continue;
        }else{
            format(res,start,end);
            // 重置
            start = nums[i];
            end = start;
        }
    }
    format(res,start,end);// recode last one
    return res;
}
public void format(List<String> list,int start,int end){
    list.add(end == start? start+"":start + "->" + end);
}

// 改进版
public List<String> summaryRanges(int[] nums) {
    List<String> res = new ArrayList<>();
    if(nums.length == 0) return res;
    StringBuilder sb = new StringBuilder();
    int a = 0,n = nums.length;
    for(int i = 0;i<n-1;i++){
        if (nums[i]+1== nums[i+1]) {
            a++;
        }else{
            format(res,sb,nums[i]-a,nums[i]);
            // 重置
            a=0;
        }
    }
    format(res,sb,nums[n-1]-a,nums[n-1]);// recode last one
    return res;
}
public void format(List<String> list,StringBuilder sb,int start,int end){
    if (end == start) {
        sb.append(start);
    }else{
        sb.append(start).append("->").append(end);
    }
    list.add(sb.toString());
    sb.delete(0, sb.length());
}
```
# 231. Power of Two(简单)
Given an integer `n`, return `true` if it is a power of two. Otherwise, return `false`.

An integer `n` is a power of two, if there exists an integer `x` such that `n == 2x`.

* **约束**
  * `-2^31 <= n <= 2^31 - 1`
* **思路**：**位运算**
  * 小于等于0的都不是**2的次幂**结果
  * `n & (n - 1)`为0的数是2的幂
  * **注意**：**求是否是2的次幂**
```java
public boolean isPowerOfTwo(int n) {
        if (n <= 0) return false;
        return (n & (n - 1)) == 0;
}
```

# 232. Implement Queue using Stacks(简单)
Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).
```markdown
Implement the `MyQueue` class:
* `void push(int x)` Pushes element x to the back of the queue.
* `int pop()` Removes the element from the front of the queue and returns it.
* `int peek()` Returns the element at the front of the queue.
* `boolean empty()` Returns `true` if the queue is empty, `false` otherwise.
```

* **约束**
  * `1 <= x <= 9`
  * At most `100` calls will be made to `push`, `pop`, `peek`, and `empty`.
  * All the calls to `pop` and `peek` are valid.
* **思路**：**双栈**
  * 一个用于入栈，一个用于出栈
  * 出栈为空时，将入栈的元素全部压入出栈
```java
class MyQueue {

    Stack<Integer> stack,tmp;
    public MyQueue() {
        stack = new Stack<>();
        tmp = new Stack<>();
    }
    
    public void push(int x) {
        stack.push(x);
    }
    
    public int pop() {
        return getFirst(true);
    }
    
    public int peek() {
        return getFirst(false);
    }
    private int getFirst(boolean isDelete){
        if (tmp.isEmpty()) {
            while(!stack.isEmpty()){
                tmp.push(stack.pop());
            }
        }
        return isDelete?tmp.pop():tmp.peek();
    }
    
    public boolean empty() {
        return stack.isEmpty() && tmp.isEmpty();
    }
}
```
# 234. Palindrome Linked List(简单)
Given the `head` of a singly linked list, return `true` if it is a palindrome.

* **约束**
  * The number of nodes in the list is in the range `[1, 10^5]`.
  * `0 <= Node.val <= 9`
* **思路**：
  * 将`ListNode`转换为List
  * 用双指针判断是否是回文
* **改进**：**快慢指针**
  * 慢走一步，快走两步，当快走完时，慢到中间
  * 反转后半段链表
  * 用反转前半段的链表与慢走后的链表(后半段)比较
```java
public boolean isPalindrome(ListNode head) {
    List<Integer> list = new ArrayList<>();
    while (head != null) {
        list.add(head.val);
        head = head.next;
    }
    int left = 0, right = list.size() - 1;
    while (left < right) {
        if (!list.get(left).equals(list.get(right))) {
            return false;
        }
        left++;
        right--;
    }

    return true;
}

// 改进版：快慢指针
public boolean isPalindrome(ListNode head) {
    ListNode slow = head,fast = head,reverse=null;
    while(fast!=null && fast.next!=null){
        ListNode tmp = slow;
        slow = slow.next;
        fast = fast.next.next;
        tmp.next = reverse;
        reverse = tmp;
    }

    if(fast!=null) slow = slow.next;
    while(slow!=null && reverse.val==slow.val){
        slow = slow.next;
        reverse = reverse.next;
    }
    return slow == null;
}
```

# 242. Valid Anagram(简单)
Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

* **约束**
  * `1 <= s.length, t.length <= 5 * 10^4`
  * `s` and `t` consist of lowercase English letters.
* **思路**：
  * 题意：两个字符串是否是字母异位词
  * 由于明确时应为小写字母(26位)，定义两个长度为26的数组，分别记录两个字符串中每个字母出现的次数
  * 比较两个数组值是否相等，若相等则返回true，否则返回false
* **改进**
  * 使用一个数组即可，一个`+1`，一个`-1`
  * 当都为0，代表true，否则false
```java
public boolean isAnagram(String s, String t) {
    if(s.length() != t.length()) return false;
    int[] sa = new int[26],ta = new int[26];
    for(int i = 0;i<s.length();i++){
        sa[s.charAt(i)-97]++;
        ta[t.charAt(i)-97]++;
    }
    for(int i = 0;i<26;i++){
        if(sa[i]!=ta[i]) return false;
    }
    return true;
}

// 改进版
public boolean isAnagram(String s, String t) {
    if(s.length() != t.length()) return false;
    int[] sa = new int[26];
    for(int i = 0;i<s.length();i++){
        sa[s.charAt(i)-97]++;
        sa[t.charAt(i)-97]--;
    }
    for(int i = 0;i<26;i++){
        if(sa[i]!=0) return false;
    }
    return true;
}
```
# 326. Power of Three(简单)
Given an integer `n`, return `true` if it is a power of three. Otherwise, return `false`.

An integer `n` is a power of three, if there exists an integer `x` such that `n == 3x`.

* **约束**
  * `-2^31 <= n <= 2^31 - 1`
* **思路**：
  * 首先应该是3的倍数，其次3的倍数，再除以3，结果还是3的倍数，直到结果为非3的余数
  * 判断是否=1(3的倍数循环除3，一定是1)
```java
public boolean isPowerOfThree(int n) {
    if(n<= 0) return false;
    while(n % 3 == 0) n /= 3;
    return n == 1;
}
```
# 342. Power of Four(简单)
Given an integer `n`, return `true` if it is a power of four. Otherwise, return `false`.

An integer `n` is a power of four, if there exists an integer `x` such that `n == 4x`.

* **约束**
  * `-2^31 <= n <= 2^31 - 1`
  * `n` is an integer.
* **思路**：
  * 首先应该是4的倍数，其次4的倍数，再除以4，结果还是4的倍数，直到结果为非4的余数
  * 判断是否=1(4的倍数循环除4，一定是1)
```java
public boolean isPowerOfFour(int n) {
    if(n<=0) return false;
    while(n%4==0) n/=4;
    return n == 1;
}
```
# 498. Diagonal Traverse(中等)
Given an `m x n` matrix `mat`, return an array of all the elements of the matrix in diagonals in spiral order.

* **约束**
  * `m == mat.length`
  * `n == mat[i].length`
  * `1 <= m, n <= 10^4`
  * `1 <= m * n <= 10^4`
* **思路**：确定转向边界
  * 向上转向边界：首行或尾列
  * 向下转向边界：尾行或首列
```java
public static findDiagonalOrder(int[][] mat) {
    int m = mat.length,n = mat[0].length;
    int i = 0,j = 0,index = 0;
    boolean flag = true;
    int[] ans = new int[m*n];
    while(true){
        ans[index++]= mat[i][j];
        if(i==m-1 && j==n-1) return ans;
        if (flag) {
            if(i==0 || j==n-1){
                if(j<n-1) j++;
                else i++;
                flag = false;
                continue;
            }
            i--;j++;
            continue;
        }
        // flag = false => down
        if(j==0 || i==m-1){
            if(i<m-1) i++;
            else j++;
            flag = true;
            continue;
        }
        i++;j--;
    }
}
```
# 679. 24 Game(困难)
You are given an integer array cards of length 4. You have four cards, each containing a number in the range [1, 9]. You should arrange the numbers on these cards in a mathematical expression using the operators ['+', '-', '*', '/'] and the parentheses '(' and ')' to get the value 24.

You are restricted with the following rules:

The division operator '/' represents real division, not integer division.
For example, 4 / (1 - 2 / 3) = 4 / (1 / 3) = 12.
Every operation done is between two numbers. In particular, we cannot use '-' as a unary operator.
For example, if cards = [1, 1, 1, 1], the expression "-1 - 1 - 1 - 1" is not allowed.
You cannot concatenate numbers together
For example, if cards = [1, 2, 1, 2], the expression "12 + 12" is not valid.
Return true if you can get such expression that evaluates to 24, and false otherwise.

* **约束**
  * `cards.length == 4`
  * `1 <= cards[i] <= 9`
* **思路**
```java
private static final double EPS = 1e-6;
private boolean backtrack(double[] A, int n) {
    if(n == 1) return Math.abs(A[0] - 24) < EPS;
    for(int i = 0; i < n; i++) {
        for(int j = i + 1; j < n; j++) {
            double a = A[i], b = A[j];
            A[j] = A[n-1];
            A[i] = a + b;
            if(backtrack(A, n - 1)) return true;
            A[i] = a - b;
            if(backtrack(A, n - 1)) return true;
            A[i] = b - a;
            if(backtrack(A, n - 1)) return true;
            A[i] = a * b;
            if(backtrack(A, n - 1)) return true;
            if(Math.abs(b) > EPS) {
                A[i] = a / b;
                if(backtrack(A, n - 1)) return true;
            }
            if(Math.abs(a) > EPS) {
                A[i] = b / a;
                if(backtrack(A, n - 1)) return true;
            }
            A[i] = a; A[j] = b;
        }
    }
    return false;
}
public boolean judgePoint24(int[] nums) {
    double[] A = new double[nums.length];
    for(int i = 0; i < nums.length; i++) A[i] = nums[i];
    return backtrack(A, A.length);
}
```

# 808. Soup Servings(中等)
There are two types of soup: type `A` and type `B`. Initially we have `n` ml of each type of soup. There are four kinds of operations:
  * Serve `100` ml of soup `A` and `0` ml of soup B
  * Serve `75` ml of soup A and `25` ml of soup B
  * Serve `50` ml of soup A and `50` ml of soup B
  * Serve `25` ml of soup A and `75` ml of soup B

Note:
* There is no operation that pours 0 mL from A and 100 mL from B.
* The amounts from A and B are poured simultaneously during the turn.
* If an operation asks you to pour more than you have left of a soup, pour all that remains of that soup.

The process stops immediately after any turn in which one of the soups is used up.

Return the probability that A is used up before B, plus half the probability that both soups are used up in the same turn. Answers within 10-5 of the actual answer will be accepted.

* **约束**
  * `0 <= n <= 10^9`
* **思路**：**递归思路**
  * 分别计算每一步满足结果的条件
  * 使用递归思路，每一步概率求下一个概率的和
  * 当A或B为0时，返回结果
    * 若都为0，则返回0.5
    * 若A为0，则返回1
    * 否则B先倒完，则返回0
* **改进**：**记忆化递归**
  * 一：使用Map存储，注意HashMap冲突时，若链表/树过大，会造成栈溢出
  * 二：使用Double二维数组存储，查询/修改数据快，也不会造成栈溢出
```java
public double soupServings(int n) {
    return soupServings(n,n);
}
private double soupServings(int A,int B) {
    if(A <= 0 && B <= 0) return 0.5;
    if(A <= 0) return 1;
    if(B <= 0) return 0;

    return 0.25 * (soupServings(A-100,B) + 
        soupServings(A-75,B-25) + 
        soupServings(A-50,B-50) + 
        soupServings(A-25,B-75));
}
// 改进版： 使用map存储
public double soupServings(int n) {
    int units = (int)Math.ceil(n / 25.0);
    Map<Integer,Map<Integer,Double>> cache = new HashMap<>();
    for (int k = 1; k <= units; k++) { // 避免 cache hash冲突时 栈溢出
        if (calcProb(k, k, cache) > 1 - 1e-5) return 1.0;
    }
    return calcProb(units, units,cache);
}
private double calcProb(int a, int b,Map<Integer,Map<Integer,Double>> cache) {
    if (a <= 0 && b <= 0) return 0.5; // Both soups empty → half probability
    if (a <= 0) return 1.0; // A empty first
    if (b <= 0) return 0.0; // B empty first
    // If already computed, return cached result
    if (cache.containsKey(a) && cache.get(a).containsKey(b)) return cache.get(a).get(b);
    double res = 0.25 * ( calcProb(a - 4, b,cache) + calcProb(a - 3, b - 1,cache) +
        calcProb(a - 2, b - 2,cache) + calcProb(a-1, b - 3,cache));
    cache.computeIfAbsent(a, k-> new HashMap<>()).put(b, res);
    return res;
}
// 改进版二：使用Double二维数组替代HashMap，避免hash冲突
public double soupServings(int n) {
    // Optimization: for large n, probability approaches 1
    if (n > 5000) return 1.0;
    int units = (int)Math.ceil(n / 25.0);
    Double[][] cache = new Double[units+1][units+1];
    return calcProb(units, units,cache);
}
private double calcProb(int a, int b,Double[][] cache) {
    if (a <= 0 && b <= 0) return 0.5; // Both soups empty → half probability
    if (a <= 0) return 1.0; // A empty first
    if (b <= 0) return 0.0; // B empty first
    // If already computed, return cached result
    if (cache[a][b] != null) return cache[a][b];
    cache[a][b] = 0.25 * ( calcProb(a - 4, b,cache) + calcProb(a - 3, b - 1,cache) +
        calcProb(a - 2, b - 2,cache) + calcProb(a-1, b - 3,cache));
    return cache[a][b];
}
```
# 837. New 21 Game(中等)
Alice plays the following game, loosely based on the card game "21".

Alice starts with 0 points and draws numbers while she has less than k points. During each draw, she gains an integer number of points randomly from the range [1, maxPts], where maxPts is an integer. Each draw is independent and the outcomes have equal probabilities.

Alice stops drawing numbers when she gets k or more points.

Return the probability that Alice has n or fewer points.

Answers within 10^-5 of the actual answer are considered accepted.

* **约束**
  * `0 <= k <= n <= 10^4`
  * `1 <= maxPts <= 10^4`
* **思路**：**动态规划**
```java
public double new21Game(int n, int k, int maxPts) {
    double dp[] = new double[n + 1];
    dp[0] = 1;
    double s = k > 0 ? 1 : 0;
    for (int i = 1; i <= n; i++) {
        dp[i] = s / maxPts;
        if (i < k) s += dp[i];
        if (i - maxPts >= 0 && i - maxPts < k) s -= dp[i - maxPts];
    }
    double ans = 0;
    for (int i = k; i <= n; i++) ans += dp[i];
    return ans;
}

public double new21Game(int N, int K, int maxPts) {
    if(K==0) 
    return 1.0;
    if(N>=K-1+maxPts) 
    return 1.0;
    double[] dp=new double[N+1];
    Arrays.fill(dp,0.0);
    double probability=0.0; 
    double windowSum=1.0; 
    dp[0]=1.0;
    for(int i=1;i<=N;i++) {
        dp[i]=windowSum/maxPts;
        if(i<K) 
        windowSum+=dp[i];
        else 
        probability+=dp[i];
        if(i>=maxPts) 
        windowSum-=dp[i-maxPts];
    }
    return probability;
}
```
# 869. Reordered Power of 2(中等)
You are given an integer n. We reorder the digits in any order (including the original order) such that the leading digit is not zero.

Return `true` if and only if we can do this so that the resulting number is a power of two.

* **约束**
  * `1 <= n <= 10^9`
* **思路**：**数字排序**
  * 数字每位做余数数组并排序
  * 遍历2的次幂，每位做余数数组并排序
  * 判断两个数组是否相等
* **优化**：
  * 数字的每一位x10并相加得到新数字
  * 遍历有效2的次幂，同样对数字每一位x10
  * 判断两个数字是否相等
```java
public boolean reorderedPowerOf2(int n) {
    if (n == 1) return true;
    int[] cnt = new int[10];
    while (n > 0) {
        cnt[n % 10]++;
        n /= 10;
    }
    for (int i = 0; i < 31; i++) {
        int[] cnt2 = new int[10];
        int x = 1 << i;
        while (x > 0) {
            cnt2[x % 10]++;
            x /= 10;
        }
        if (java.util.Arrays.equals(cnt, cnt2)) return true;
    }
    return false;
}
// 优化 提取公共方法
public boolean reorderedPowerOf2(int n) {
    int count = counter(n);
    for (int i = 0; i < 30; ++i)
        if (counter(1 << i) == count) return true;
    return false;
}
private int counter(int n) {
    int count = 0;
    for (; n > 0; n /= 10) count += Math.pow(10, n % 10);
    return count;
}
```
# 898. Bitwise ORs of Subarrays(中等)
Given an integer array `nums`, return *the number of non-empty **subarrays** such that the bitwise OR of the subarray elements is equal to `nums[i]` for all `i` where `0 <= i < nums.length`*.

* **约束**
  * `1 <= nums.length <= 10^5`
  * `1 <= nums[i] <= 10^9`
* **思路**：
  * 适用Set结构存储结果，用于去重
  * 遍历数组
    * 将当前值加入结果集
    * 将当前值分别从前值分别及遍历数组元素(0<=j<=i)进行异或，并加入结果集
* **优化**
  * 记录前结果集，避免内部重复与前值进行异或
  * 记录当前结果集，加入当前值和当前值与前结果集分别异或结果
  * 将当前结果集加入最终结果集，并赋值给前结果集
* **改进**：**用前元素存储与当前值的异或值结果**
```java
// 基础实现
public int subarrayBitwiseORs(int[] arr) {
    Set<Integer> res = new HashSet<>();
    for (int i = 0; i < arr.length; i++) { // 遍历数组
        int tmp = arr[i];
        if(!res.contains(tmp)) res.add(tmp); // 判断当前值
        int start = i-1;
        while(start>=0){ // 每次异或开始位置
            for (int j = start; j >=0; j--) { // 异或结果判断
                tmp |= arr[j];
                if(!res.contains(tmp)) res.add(tmp); // 判断当前值和前面的异或值
            }
            start--;
        }
    }
    return res.size();
}
// 优化版
public int subarrayBitwiseORs(int[] arr) {
    Set<Integer> res = new HashSet<>(); // 结果集
    Set<Integer> pres = new HashSet<>(); // 前面异或结果集
    for (int x : arr) {
        Set<Integer> curs = new HashSet<>(); // 当前异或结果集
        curs.add(x); // 当前值
        for (int y : pres) curs.add(x | y); // 当前值与前面异或结果集异或
        res.addAll(curs);
        pres = curs;
    }
    return res.size();
}

// 改进版
public int subarrayBitwiseORs(int[] arr) {
    Set<Integer> res=new HashSet<>();
    //不借助额外辅助，直接将当前位或结果赋值给前一位
    for(int i=0;i<arr.length;i++){
        res.add(arr[i]);
        for(int j=i-1;j>=0;j--){
            if(arr[j]==(arr[j] | arr[i])) break; 
            arr[j]|=arr[i];
            res.add(arr[j]);
        }
    }
    return res.size();
}
```
# 904. Fruit Into Baskets(中等)
You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array `fruits` where `fruits[i]` is the type of fruit the `i`th tree produces.

You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:
* You only have **two** baskets, and each basket can only hold a **single type** of fruit. There is no limit on the amount of fruit each basket can hold.
* Starting from any tree of your choice, you must pick **exactly one fruit** from **every** tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.
* Once you reach a tree with fruit that cannot fit in your baskets, you must stop.

Given the integer array fruits, return the **maximum** number of fruits you can pick.

* **约束**
  * `1 <= fruits.length <= 10^5`
  * `0 <= fruits[i] < fruits.length`
* **思路**：双指针法
  * 由于只有两个包，故而只需通过两个索引即可判定两个包中水果类型
  * 遍历数组，
    * 当前水果类型与两个索引类型相同时，跳过
    * 若两个索引等值，则将当前值赋值给第二个索引
    * 两索引不等值及两个水果类型
      * 取最大值
      * 并将第一个索引赋值为第二个索引，并将当前索引重置为第一个索引(重点，避免漏检)
```java
public int totalFruit(int[] fruits) {
    int max = 0,start = 0,next=0,cur = -1;
    while((++cur) < fruits.length){
        int fruit = fruits[cur];
        if(fruits[start] == fruit || fruits[next] == fruit) continue;
        if(start==next) next = cur;
        else{
            max = Math.max(max, cur-start);
            start = next;cur = start;
        }
    }
    max = Math.max(max, fruits.length-start);
    return max;
}
```
# 1277. Count Square Submatrices with All Ones(中等)
Given a `m * n` matrix of ones and zeros, return how many **square** submatrices have all ones.

* **约束**
  * `1 <= arr.length <= 300`
  * `1 <= arr[0].length <= 300`
  * `arr[i][j] == 0` or `arr[i][j] == 1`
* **思路**：
```java
public int countSquares(int[][] matrix) {
    int m = matrix.length, n = matrix[0].length,count =0;
    for (int i=1;i<m;i++) {
        for (int j=1;j<n;j++) {
            if (matrix[i][j] != 1) continue;
            matrix[i][j] += Math.min(matrix[i-1][j], Math.min(matrix[i][j-1], matrix[i-1][j-1]));
            count += matrix[i][j];
        }
    }
    for (int i=0;i<m;i++) count+=matrix[i][0];
    for (int i=1;i<n;i++) count+=matrix[0][i];
    return count;
}
```
# 1304. Find N Unique Integers Sum up to Zero(简单)
Given an integer n, return any array containing n unique integers such that they add up to 0.

* **约束**
  * `1 <= n <= 1000`
* **思路**：
  * 方式一：生成对半正负数组
  * 方式二：数组保留一位负，其余皆为正
```java
public int[] sumZero(int n) {
    int left = 0,right=0,count = n/2;
    int[] arr = new int[n];
    int idx = 0;
    if(n%2 == 0){
        while(idx<n){
            arr[idx++] = -count;
            arr[idx++] = count--;
        }
    }else{
        while(idx<n){
            if(count==0){
                arr[idx] = count;
                break;
            }
            arr[idx++] = -count;
            arr[idx++] = count--;
        }
    }
    return arr;
}

public int[] sumZero(int n) {
    int[] arr=new int[n];
    if(n==1) return arr;
    int sum=0;
    for(int i=0;i<n-1;i++){
        arr[i]=i+1;
        sum+=arr[i];
    }
    arr[n-1]=-sum;
    return arr;
}
```
# 1317. Convert Integer to the Sum of Two No-Zero Integers(简单)
**No-Zero integer** is a positive integer that **does not contain any** `0` in its decimal representation.

Given an integer `n`, return a list of two integers `[a, b]` where:
* `a and `b` are **No-Zero integers**.
* `a + b = n`

The test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them.

* **约束**
  * `1 <= n <= 10^4`
* **思路**：
  * 不能被`10`整除
  * 内部不能包含`0`
```java
public int[] getNoZeroIntegers(int n) {
    for(int i=1;i<=n;i++){
        int a = i;
        int b = n-i;
        if(a>0 && b>0 && iscontainsZero(a) == false && iscontainsZero(b) == false){
            return new int[]{a,b};
        }
    }
    return new int[] {-1,-1};
}
private boolean iscontainsZero(int n){
    while(n > 0){
        int digits = n % 10;
        if(digits == 0) return true;
        n /= 10;
    }
    return false;
}
```
# 1323. Maximum 69 Number(简单)
You are given a positive integer `num` consisting only of digits 6 and 9.
Return the maximum number you can get by changing **at most** one digit (6 becomes 9, and 9 becomes 6).

* **约束**
  * `1 <= num <= 10^4`
* **思路**：
  * 方式一：将数字转为字符串
  * 方式二：利用余数差值判断，若为6，则增加`3*digit`
```java
// 方式一：转字符串，第一个遇到6的替换为9，并退出
public int maximum69Number (int num) {
    char[] numStr = String.valueOf(num).toCharArray();
    for (int i = 0; i < numStr.length; i++) {
        if(numStr[i] == '6'){
            numStr[i] = '9';
            break;
        }
    }
    return Integer.parseInt(String.valueOf(numStr));
}
// 方式二：利用余数差值判断，若为6，则增加`3*digit`
// 追求机制也可将(tmpDigit=1 , tmpDigit = digit/10)定义为变量，避免重复计算，不过会增加变量开销
public int maximum69Number (int num) {
    int max = num, digit = 10;
    while(true) {
        int gap = (num % digit) / (digit/10); // 直接提取当前位的数字
        if(gap == 6) max = num + digit/10 * 3; // 替换当前位的6为9
        if((num % digit) == num) break; // 检查是否到达最高位
        digit *= 10;
    }
    return max;
}
```
# 1493. Longest Subarray of 1's After Deleting One Element(中等)
Given a binary array `nums`, you can delete one element from it.
Return the size of the longest non-empty subarray containing only 1's **in the resulting array**.
Return `0` if there is no such subarray.

* **约束**
  * `1 <= nums.length <= 10^5`
  * `nums[i]` is either `0` or `1`.
* **思路**：
```java
public int longestSubarray(int[] nums) {
    int i=0,j=0,n=nums.length,max=0,count=0;
    while(j<n){
        if(nums[j]==0) count++;
        while(count>1){
            if(nums[i]==0) count--;
            i++;
        }
        max=Math.max(max,j-i);
        j++;
    }
    return max;
}
public int longestSubarray(int[] nums) {
    int l = 0, r = 0, d = -1, max = 0, len = nums.length;
    while (r < len) {
        if (nums[r] == 0) {
            if (d == -1) {
                d = r;
                r++;
            } else {
                max = Math.max(max, r - l - 1);
                l = d + 1;
                d = -1;
            }
        } else r++;
    }
    return Math.max(max, r - l - 1);
}
```
# 1504. Count Submatrices With All Ones(中等)
Given an `m x n` binary matrix `mat`, return the number of **submatrices** that have all ones.

* **约束**
  * `1 <= m,n <= 10^5`
  * `arr[i][j] == 0` or `arr[i][j] == 1`
* **思路**：
```java
public int numSubmat(int[][] mat) {
    int n = mat.length,m = mat[0].length,ans = 0;
    int[] height = new int[m];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) height[j] = (mat[i][j] == 0) ? 0 : height[j] + 1;// Update histogram heights
        ans += countRectangles(height);// Count rectangles in current histogram
    }
    return ans;
}
private int countRectangles(int[] height) {
    int m = height.length,count = 0,top = -1;
    int[] stack = new int[m],sum = new int[m];
    for (int j = 0; j < m; j++) {
        while (top >= 0 && height[stack[top]] >= height[j]) top--;
        if (top == -1) sum[j] = height[j] * (j + 1);
        else sum[j] = sum[stack[top]] + height[j] * (j - stack[top]);
        count += sum[j];
        stack[++top] = j;
    }
    return count;
}
```
# 1717. Maximum Score From Removing Substrings(中等)
You are given a 0-indexed string `s` that consists of only lowercase English letters, where each letter the string has an associated score. You are also given an integer array `nums` where `nums[i]` is the score of the `i`th character of `s`.
You are allowed to remove any substring of `s` in one operation. The score of a string is the sum of the scores of its characters.
Return the maximum score you can obtain after removing exactly one substring from `s`.
A substring is a contiguous sequence of characters in a string.

* **约束**
  * `1 <= s.length <= 10^5`
  * `s.length == nums.length`
  * `1 <= nums[i] <= 10^5`
* **思路**：
  * 根据最大值，一次递归移除一个有效值
  * 可能存在栈溢出或超时问题
* **改进**
  * 默认x为最大，若x<y，则将x，y交换
  * 定义最大值次数和次值次数
    * 当遇到次值时，若有最大值次数，则加最大值一次
    * 否则次值次数+1
  * 若遇到非两个字符，则取最大值次数和次值次数的最小值，乘以最小值计算结果
  * 若最值次数有效，则计算最后剩余有效值
```java
public int maximumGain(String s, int x, int y) {
    if(!(s.contains("ab") || s.contains("ba"))) return 0;
    if(x > y){
        return s.contains("ab")
        ?maximumGain(s.replaceFirst("ab",""), x, y) + x
        :maximumGain(s.replaceFirst("ba",""), x, y) + y;
    }
    return s.contains("ba")
    ?maximumGain(s.replaceFirst("ba",""), x, y) + y
    :maximumGain(s.replaceFirst("ab",""), x, y) + x;
}
// 递归版
private final String AB = "ab";
private final String BA = "ba";
public int maximumGain(String s, int x, int y){
    if(s.indexOf(AB) == -1 && s.indexOf(BA) == -1) return 0;
    if(x > y && s.contains(AB)){
        return maximumGain(s, AB, x) + maximumGain(s.replaceAll(AB, ""), x, y);
    }
    if(s.contains(BA)){
        return maximumGain(s, BA, y) + maximumGain(s.replaceAll(BA, ""), x, y);
    }
    return maximumGain(s, AB, x) + maximumGain(s.replaceAll(AB, ""), x, y);
}
private int maximumGain(String s,String regex,int x){
    int max = 0,index = 0;
    while((index=s.indexOf(regex,index))!=-1){
        max += x;
        index += regex.length();
    }
    return max;
}
// 改进版
public int maximumGain(String s, int x, int y) {
    int score = 0;
    char[] chars = s.toCharArray();
    int len = chars.length;
    char ch1 = 'a', ch2 = 'b';
    int cnt1 = 0, cnt2 = 0;

    if (x < y) { // 默认x为最大得分
        int temp = x;x = y;y = temp;
        ch1 = 'b';ch2 = 'a';
    }
    for (int i = 0; i < len; i++) {
        if (chars[i] == ch1) cnt1++;
        else if (chars[i] == ch2) {
            if (cnt1 > 0) { // 存在最大值得分
                cnt1--;
                score += x;
            } else cnt2++;
        } else { // 遇到其他字符
            score += Math.min(cnt1, cnt2) * y; // 次值得分计算
            cnt1 = 0;
            cnt2 = 0;
        }
    }
    if (cnt1 != 0) score += Math.min(cnt1, cnt2) * y; // 最后剩余的
    return score;
}
```
# 1733. Minimum Number of People to Teach(中等)
On a social network consisting of `m` users and some friendships between users, two users can communicate with each other if they know a common language.

You are given an integer `n`, an array `languages`, and an array `friendships` where:
* There are `n` languages numbered `1` through `n`,
* `languages[i]` is the set of languages the `i^​​​​​​th​​​​` user knows, and
* `friendships[i] = [u_​​​​​​i​​​, v​​​​​​_i]` denotes a friendship between the users `u_​​​​​​​​​​​i​​​​​` and `v_i`.

You can choose **one** language and teach it to some users so that all friends can communicate with each other. Return the **minimum** number of users you need to teach.

Note that friendships are not transitive, meaning if `x` is a friend of `y` and `y` is a friend of `z`, this doesn't guarantee that `x` is a friend of `z`.

* **约束**:
* `2 <= n <= 500`
* `languages.length == m`
* `1 <= m <= 500`
* `1 <= languages[i].length <= n`
* `1 <= languages[i][j] <= n`
* `1 <= u​​​​​​i < v​​​​​​i <= languages.length`
* `1 <= friendships.length <= 500`
* All tuples `(u​​​​​i, v​​​​​​i)` are unique
* `languages[i]` contains only unique values
* **思路**：
```java
public int minimumTeachings(int n, int[][] languages, int[][] friendships) {
    BitSet[] bit = new BitSet[languages.length];
    Arrays.setAll(bit, o -> new BitSet(n + 1));
    for (int i = 0; i < languages.length; i++){
        for (int l : languages[i]) bit[i].set(l);
    }
    Set<Integer> teach = new HashSet<>();
    for (int[] f : friendships){
        BitSet t = (BitSet)bit[f[0] - 1].clone();
        t.and(bit[f[1] - 1]);
        if (t.isEmpty()){
            teach.add(f[0] - 1);
            teach.add(f[1] - 1);
        }
    }
    int[] count = new int[n + 1];
    for (int person : teach){
        for (int l : languages[person]) count[l]++;
    }
    return teach.size() - Arrays.stream(count).max().getAsInt();
}
```
# 1792. Maximum Average Pass Ratio(中等)
There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam.

You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes.

The pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes.

Return the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.

* **约束**
  * `1 <= classes.length <= 10^5`
  * `classes[i].length == 2`
  * `1 <= pass_i <= total_i <= 10^5`
  * `1 <= extraStudents <= 10^5`
* **思路**：
```java
// 基础版
public double maxAverageRatio(int[][] classes, int extraStudents) {
    List<Double> passRatios = new ArrayList<>();

    // Calculate initial pass ratios
    for (int classIndex = 0; classIndex < classes.length; classIndex++) {
        double initialRatio =
            (double) classes[classIndex][0] / classes[classIndex][1];
        passRatios.add(initialRatio);
    }

    while (extraStudents > 0) {
        List<Double> updatedRatios = new ArrayList<>();

        // Calculate updated pass ratios if an extra student is added
        for (
            int classIndex = 0;
            classIndex < classes.length;
            classIndex++
        ) {
            double newRatio =
                (double) (classes[classIndex][0] + 1) /
                (classes[classIndex][1] + 1);
            updatedRatios.add(newRatio);
        }

        int bestClassIndex = 0;
        double maximumGain = 0;

        // Find the class that gains the most from an extra student
        for (
            int classIndex = 0;
            classIndex < updatedRatios.size();
            classIndex++
        ) {
            double gain =
                updatedRatios.get(classIndex) - passRatios.get(classIndex);
            if (gain > maximumGain) {
                bestClassIndex = classIndex;
                maximumGain = gain;
            }
        }

        // Update the selected class
        passRatios.set(bestClassIndex, updatedRatios.get(bestClassIndex));
        classes[bestClassIndex][0]++;
        classes[bestClassIndex][1]++;

        extraStudents--;
    }

    // Calculate the total average pass ratio
    double totalPassRatio = 0;
    for (double passRatio : passRatios) {
        totalPassRatio += passRatio;
    }

    return totalPassRatio / classes.length;
}
// 改进版
public double maxAverageRatio(int[][] classes, int extraStudents) {
    PriorityQueue<double[]> pq = new PriorityQueue<>(new Comparator<double[]>() {
        public int compare(double[] a, double[] b) {
            if (a[0] < b[0]) return 1;
            if (a[0] > b[0]) return -1;
            return 0;
        }
    });
    for (int i = 0; i < classes.length; i++) {
        double pass = classes[i][0];
        double total = classes[i][1];
        double inc = (pass + 1.0) / (total + 1.0) - pass / total;
        pq.offer(new double[]{inc, pass, total});
    }
    while (extraStudents > 0) {
        double[] top = pq.poll();
        double pass = top[1] + 1;
        double total = top[2] + 1;
        double inc = (pass + 1.0) / (total + 1.0) - pass / total;
        pq.offer(new double[]{inc, pass, total});
        extraStudents--;
    }
    double sum = 0.0;
    Object[] arr = pq.toArray();
    for (int i = 0; i < arr.length; i++) {
        double[] c = (double[]) arr[i];
        sum += c[1] / c[2];
    }
    return sum / classes.length;
}
```
# 2044. Count Number of Maximum Bitwise OR Subsets(中等)
Given an integer array `nums`, find the maximum possible bitwise OR of a subset of `nums` and return the number of different non-empty subsets with the maximum bitwise OR.

An array `a` is a subset of an array `b` if `a` can be obtained from `b` by deleting some (possibly zero) elements of `b`.

The bitwise OR of an array is the bitwise OR of all the numbers in the array.

* **约束**
  * `1 <= nums.length <= 16`
  * `1 <= nums[i] <= 10^8`
* **思路**：回溯
  * 求最大异或值
  * 从开始位置深度递归对比异或值
    * 当索引超出，终止
    * 当OR等值，则返回剩余个数的排列组合数
    * 否则，递归对比OR值(选择当前值+不选择当前值)
```java
public int countMaxOrSubsets(int[] nums) {
    int maxOR = 0;
    for (int num : nums) maxOR |= num; // 求最大异或值
    return backtrack(nums, maxOR, 0, 0);
}
private int backtrack(int[] nums, int maxOR, int index, int currentOR) {
    if (index == nums.length) return currentOR == maxOR ? 1 : 0; // 终止条件
    if (currentOR == maxOR) return 1 << (nums.length - index); // 当结果等于，则取剩余元素数的排列组合数
    // 选择当前元素 + 不选择当前元素
    return backtrack(nums, maxOR, index + 1, currentOR | nums[index]) + 
        backtrack(nums, maxOR, index + 1, currentOR);
}
```
# 2106. Maximum Fruits Harvested After at Most K Steps(困难)
Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array `fruits` where `fruits[i] = [positioni, amounti]` depicts amounti fruits at the position positioni. `fruits` is already sorted by positioni in ascending order, and each positioni is unique.

You are also given an integer `startPos` and an integer `k`. Initially, you are at the position `startPos`. From any position, you can either walk to the **left or right**. It takes **one step** to move **one unit** on the x-axis, and you can walk **at most** `k` steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.

Return the **maximum total number** of fruits you can harvest.
* **约束**
  * `1 <= fruits.length <= 10^5`
  * `fruits[i].length == 2`
  * `0 <= startPos, positioni<= 2*10^5`
  * `positioni-1<positioni` for any `i>0`(**0-indexed**).
  * `1 <= amounti <= 10^4`
  * `0 <= k <= 2*10^5`
* **思路**：滑动窗口
  * 将当前索引对应水果信息作为窗口的右边界
  * 将右边界水果数加入窗口结果
  * 判断左边界，右边界与`startPos`的距离是否超过`k`
    * 超过则减去左边界对应的水果数，并且左边界右移一位
  * 取最大窗口结果
```java
public int maxTotalFruits(int[][] fruits, int startPos, int k) {
    int left = 0, sum = 0, max = 0;
    for (int right = 0; right < fruits.length; right++) {
        sum += fruits[right][1];
        // 计算与startpos，若最小距离大于k，则窗口左边界右移一位
        while (left <= right && minSteps(fruits[left][0], fruits[right][0], startPos) > k) {
            sum -= fruits[left][1];
            left++;
        }
        max = Math.max(max, sum);
    }
    return max;
}
private int minSteps(int left, int right, int start) {
    // Two paths: left first or right first
    // == return Math.min(Math.abs(start-left),Math.abs(start-right))+(right-left);
    int goLeft = Math.abs(start - left) + (right - left);
    int goRight = Math.abs(start - right) + (right - left);
    return Math.min(goLeft, goRight);
}
```
# 2210. Count Hills and Valleys in an Array(简单)
You are given a **0-indexed** integer array nums. An index i is part of a **hill** in nums if the closest non-equal neighbors of i are smaller than `nums[i]`. Similarly, an index `i` is part of a **valley** in nums if the closest non-equal neighbors of `i` are larger than `nums[i]`. Adjacent indices `i` and `j` are part of the same hill or valley if `nums[i] == nums[j]`.

Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on **both** the left and right of the index.

Return the number of hills and valleys in nums.

* **约束**
  * `3 <= nums.length <= 10^5`
  * `1 <= nums[i] <= 100`
* **思路**：
  * 两边小于`nums[i]` ,`i`为山峰
  * 两边大于`nums[i]` ,`i`为山谷
  * 允许山峰或山谷存在相同值
  * 返回山峰或山谷的数量
```java
public int countHillValley(int[] nums) {
    int count = 0;
    for (int i = 1; i < nums.length-1; i++) {
        for (int j = i+1; j < nums.length; j++) {
            if(nums[j] == nums[i]) continue;
            if(nums[i-1]<nums[i]) if(nums[j]<nums[i]) count++;
            else if(nums[i-1]>nums[i]) if(nums[j]>nums[i]) count++;
            i = j-1;
            break;
        }
    }
    return count;    
}
```
# 2264. Largest 3-Same-Digit Number in String(简单)
You are given a string num representing a large integer. An integer is **good** if it meets the following conditions:
* It is a **substring** of `num` with length `3`.
* It consists of only one unique digit.
Return the **maximum good** integer as a **string** or an empty string `""` if no such integer exists.

* **约束**
  * `3 <= num.length <= 1000`
  * `num` only consists of digits from `0-9`
* **思路**：由于数字是有限的，可以直接有限定匹配
```java
public String largestGoodInteger(String num) {
    String[] numbers={"999","888","777","666","555","444","333","222","111","000"};
    for(String i:numbers){
        if(num.contains(i)) return i;
    }
    return "";
}
```
# 2322. Minimum Score After Removals on a Tree(困难)
There is an undirected connected tree with `n` nodes labeled from 0 to `n - 1` and `n - 1` edges.

You are given a **0-indexed** integer array nums of length `n` where `nums[i]` represents the value of the `i^th` node. You are also given a 2D integer array edges of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.

Remove two distinct edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:
* Get the XOR of all the values of the nodes for **each** of the three components respectively.
* The **difference** between the **largest** XOR value and the **smallest** XOR value is the score of the pair.
* For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = 6`, `1 ^ 9 = 8`, and `3 ^ 3 ^ 3 = 3`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`.

Return the **minimum** score of any possible pair of edge removals on the given tree.

* **约束**
  * `n == nums.length`
  * `3 <= n <= 10^5`
  * `1 <= nums[i] <= 10^9`
  * `edges.length == n-1`
  * `edges[i].length == 2`
  * `0 <= ai, bi < n`
  * `ai != bi`
  * `edges` represents a valid tree.
* **思路**：
  * 构建邻接表，子树异或组，节点相邻集(`Set`)
  * 递归遍历子树，计算子树异或和，相邻节点数统计
  * 遍历数组，根据子树节点集是否包含情况，计算最小异或值
* **改进**：以当前节点的上层连接数和相邻节点数代替节点集
  * 定义节点上层连接数，节点相邻连接数(含上下层)
  * 递归处理时，计算节点异或，上层节点连接数，相邻节点连接数
  * 遍历数组时
    * 根据上层连接数大小和相邻节点连接数大小，判断节点是否在子树中
    * 若在子树中，对比子节点/两节点/与根节点的XOR值，取最小
    * 若不在相互子树中，对比两节点分别XOR/根节点与两值的XOR值，取最小
```java
// 易理解版
public int minimumScore(int[] nums, int[][] edges) {
    int n = nums.length;
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    for (int[] edge : edges) { // 邻接表
        graph.get(edge[0]).add(edge[1]);
        graph.get(edge[1]).add(edge[0]);
    }
    int[] subtreeXor = new int[n]; // 每个节点和相邻节点的异或
    List<Set<Integer>> descendants = new ArrayList<>(); // 每个节点所能到达的所有节点
    for (int i = 0; i < n; i++) descendants.add(new HashSet<>());
    // 递归计算每个节点的异或，相邻节点集
    dfs(subtreeXor,descendants,graph,0, -1, nums); 

    int rootXor = subtreeXor[0]; // 根节点的异或和
    int minScore = Integer.MAX_VALUE;
    for (int i = 1; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int xorI = subtreeXor[i]; // 相邻异或节点的异或值
            int xorJ = subtreeXor[j];
            int val1, val2, val3; // 三边的异或值

            if (descendants.get(i).contains(j)) { // j is in i's subtree，j在i的子树中
                val1 = xorJ;val2 = xorI ^ xorJ;val3 = rootXor ^ xorI;
            } else if (descendants.get(j).contains(i)) { // i is in j's subtree，i在j的子树中
                val1 = xorI;val2 = xorJ ^ xorI;val3 = rootXor ^ xorJ;
            } else { // Independent subtrees
                val1 = xorI;val2 = xorJ;val3 = rootXor ^ xorI ^ xorJ;
            }
            
            int maxVal = Math.max(val1, Math.max(val2, val3));
            int minVal = Math.min(val1, Math.min(val2, val3));
            minScore = Math.min(minScore, maxVal - minVal);
        }
    }
    return minScore;
}
private void dfs(int[] subtreeXor,List<Set<Integer>> descendants,List<List<Integer>> graph,int node, int parent, int[] nums) {
    subtreeXor[node] = nums[node];
    descendants.get(node).add(node);
    for (int neighbor : graph.get(node)) { // 邻接表，遍历邻接点，总会有父节点
        if (neighbor == parent) continue;
        dfs(subtreeXor,descendants,graph,neighbor, node, nums);
        subtreeXor[node] ^= subtreeXor[neighbor]; // 当前节点和相邻节点的异或
        descendants.get(node).addAll(descendants.get(neighbor)); // 当前节点所能到达的所有节点
    }
}

// 改进版
public int minimumScore(int[] nums, int[][] edges) {
    int n = nums.length;
    List<List<Integer>> graph = new ArrayList<>(); // 定义邻接表
    for (int i = 0; i < n; i++)  graph.add(new ArrayList<>());
    for (int[] e : edges) { // 转换为邻接表
        graph.get(e[0]).add(e[1]);
        graph.get(e[1]).add(e[0]);
    }
    // xor 记录子树异或和，in记录节点上层(父级以上)连接数，out记录节点相邻节点(含父级和子级)连接数
    int[] xor = new int[n],in = new int[n],out = new int[n],cnt = { 0 };

    dfs(0, -1, nums, graph, xor, in, out, cnt);
    int rootXor = xor[0]; // 根节点的异或和
    int res = Integer.MAX_VALUE;
    for (int i = 1; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (in[j] > in[i] && in[j] < out[i])  // j is in i's subtree
                res = Math.min(res,calc(rootXor ^ xor[i], xor[i] ^ xor[j], xor[j]));
            else if (in[i] > in[j] && in[i] < out[j])  // i is in j's subtree
                res = Math.min(res,calc(rootXor ^ xor[j], xor[j] ^ xor[i], xor[i]));
            else  // Independent subtrees
                res = Math.min(res,calc(rootXor ^ xor[i] ^ xor[j], xor[i], xor[j]));
        }
    }
    return res;
}
private int calc(int part1, int part2, int part3) {
    return (Math.max(part1, Math.max(part2, part3)) -Math.min(part1, Math.min(part2, part3)));
}
private void dfs(int cur,int parent,int[] nums,List<List<Integer>> graph,int[] xor,int[] in,int[] out,int[] cnt) {
    in[cur] = cnt[0]++;
    xor[cur] = nums[cur];
    for (int neighbor : graph.get(cur)) {
        if (neighbor == parent) continue;
        dfs(neighbor, cur, nums, graph, xor, in, out, cnt); // 递归相邻节点
        xor[cur] ^= xor[neighbor]; // 当前节点和相邻节点的异或
    }
    out[cur] = cnt[0];
}
```
# 2327. Number of People Aware of a Secret(中等)
On day `1`, one person discovers a secret.

You are given an integer `delay`, which means that each person will **share** the secret with a new person **every day**, starting from `delay` days after discovering the secret. You are also given an integer `forget`, which means that each person will **forget** the secret `forget` days after discovering it. A person **cannot** share the secret on the same day they forgot it, or on any day afterwards.

Given an integer `n`, return the number of people who know the secret at the end of day `n`. Since the answer may be very large, return it **modulo** `10^9 + 7`.

* **约束**
  * `2 <= n <= 1000`
  * `1 <= delay < forget <= n`
* **思路**：
```java
public int peopleAwareOfSecret(int n, int delay, int forget) {
    long[] dp = new long[n + 1];
    dp[1] = 1;
    long share = 0, MOD = (long)1e9 + 7;
    for (int t = 2; t <= n; t++) {
        if (t - delay > 0) share = (share + dp[t - delay] + MOD) % MOD;
        if (t - forget > 0) share = (share - dp[t - forget] + MOD) % MOD;
        dp[t] = share;
    }
    long res = 0;
    for (int i = n - forget + 1; i <= n; i++) res = (res + dp[i]) % MOD;
    return (int)res;
}
```
# 2348. Number of Zero-Filled Subarrays(中等)
Given an integer array `nums`, return *the number of subarrays filled with **0**.*

* **约束**
  * `1 <= nums.length <= 10^5`
  * `-10^9 <= nums[i] <= 10^9`
* **思路**：
```java
public long zeroFilledSubarray(int[] nums) {
    long cnt = 0, streak = 0;
    for (int num : nums) {
        streak = (num == 0) ? streak + 1 : 0;
        cnt += streak;
    }
    return cnt;
}
```
# 2411. Smallest Subarrays With Maximum Bitwise OR(中等)
You are given a **0-indexed** array `nums` of length `n`, consisting of non-negative integers. For each index `i` from `0` to `n - 1`, you must determine the size of the **minimum sized** non-empty subarray of `nums` starting at `i` (**inclusive**) that has the **maximum** possible **bitwise OR**.

In other words, let `B_ij` be the bitwise OR of the subarray `nums[i...j]`. You need to find the smallest subarray starting at `i`, such that bitwise OR of this subarray is equal to `max(Bik)` where `i <= k <= n - 1`.

The bitwise OR of an array is the bitwise OR of all the numbers in it.

Return an integer array `answer` of size n where `answer[i]` is the length of the **minimum** sized subarray starting at `i` with **maximum** bitwise OR.

* **约束**
  * `1 <= nums.length <= 10^5`
  * `0 <= nums[i] <= 10^9`
* **思路**：
  * 定义结果数组，长度与nums相同
  * 循环nums
    * 获取当前位置到最后的最大或值
    * 从当前位置开始，循环获取符合最大或的最小子数组长度
* **改进**
  * 每次遍历，以当前值和前面的值做异或处理，
  * 若不等于前面的值，则重置前面的值，改为异或结果(最大maxOR)
  * 若等于，则跳过内循环(每次结果前面的值都会统一更新为最大maxOR)
```java
public int[] smallestSubarrays(int[] nums) { // 会超时
    int n = nums.length;
    int[] res = new int[n];
    Arrays.fill(res, 1); // 没人最少一个数组长度
    for (int i = 0; i < n; i++) {
        int tmp = nums[i],maxOR = tmp;
        for (int j = i+1; j <n; j++) { // 求最大或
            maxOR |= nums[j];
        }
        for (int j = i+1; j < n; j++) { // 求符合最大或的最小子数长度
            res[i]++;
            if((tmp|= nums[j]) == maxOR) {
                break;
            }
        }
    }
}

// 改进版
public int[] smallestSubarrays(int[] nums) {
    int n = nums.length;
    int[] res = new int[n];
    Arrays.fill(res, 1);
    for (int i = 0; i < n; i++){
        int tmp = nums[i];
        // 只有后续存在更大maxOR时才会更新前面的值，并且将前面的值重置为最大maxOR，否则不更新
        for (int j = i - 1; j >= 0 && (nums[j] | tmp) != nums[j]; j--){
            nums[j] |= tmp;
            res[j] = i - j + 1; // 会重复对前面的元素进行更新
        }
    }
    return res;
}

// 其它
public int[] smallestSubarrays(int[] nums) {
    int len = nums.length;
    int[] last = new int[30]; // 记录每个bit最后出现的位置
    int[] res = new int[len];
    Arrays.fill(res, 1);
    for (int i = len - 1; i >= 0; i--) {
        for (int bit = 0; bit < 30; bit++) {
            if ((nums[i] & (1 << bit)) > 0) last[bit] = i;
            res[i] = Math.max(res[i], last[bit] - i + 1);
        }
    }
    return res;
}
```
# 2419. Longest Subarray With Maximum Bitwise AND(中等)
You are given an integer array `nums` of length `n`.
You want to choose a subarray of `nums` such that the bitwise AND of the elements in the subarray is **maximum**.

Return the length of the longest subarray with maximum bitwise AND. If there is no such subarray, return `0`.

The bitwise AND of an array is the bitwise AND of all the elements in the array.

* **约束**
  * `1 <= nums.length <= 10^5`
  * `1 <= nums[i] <= 10^6`
* **思路**：
  * 定义遍历索引，最大长度，最大AND值，当前AND值，当前长度
  * 循环nums
    * 当前AND值与当前值等值，则当前AND数组长度+1，并且索引+1
    * 当前AND值小于当前值，则重置当前AND值为当前值，并重置当前长度为1，并且索引+1
    * 当前AND值大于当前值，则对比最大AND值
      * 若大于最大AND值，则将当前AND相关数据赋值给最大AND相关数据
      * 若等于最大AND值，则对比最大AND长度与当前AND长度，取最大值
      * 重置当前AND值为当前值，并重置当前长度为1，并且索引+1
* **改进**：简化逻辑
  * **先找最大值**，最大值肯定为最大AND值
  * 遍历nums
    * 若未遇到最大AND值，则跳过
    * 若遇到最大AND值时，开始计算连续长度
    * 对比已有连续长度，取最大
* **提示**：求最大AND值，则最大值肯定为最大AND值
```java
private int longestSubarray(int[] nums) {
    int start=0,max = 0,maxAnd = 0,curMaxAnd=0,count = 0;
    while (start < nums.length) {
        if(curMaxAnd == nums[start]){
            count++;
            start++;
            continue;
        }
        // 若curMaxAnd<nums[start] 则AND结果肯定小于nums[start],AND 运算结果不大于最小的那个
        if(curMaxAnd<nums[start]){ // 重置
            curMaxAnd = nums[start];
            count = 1;
            start++;
            continue;
        } // else curMaxAnd>nums[start]
        if(curMaxAnd>maxAnd){
            maxAnd = curMaxAnd;
            max = count;
        }else if(curMaxAnd==maxAnd) max = Math.max(max,count);
        curMaxAnd = nums[start];
        count = 1;
        start++;
    }
    return curMaxAnd== maxAnd?Math.max(max,count):curMaxAnd>maxAnd?count:max;
}

// 改进版(简化版)
private int longestSubarray(int[] nums) {
    int maxCount = 0,maxAnd = 0;
    for(int num:nums) maxAnd = Math.max(maxAnd,num); // 先找到最大值，肯定为最大AND值
    for (int i = 0; i < nums.length; i++) {
        if(nums[i]!=maxAnd) continue; // 未遇到最大AND值，则跳过，如遇到，则开始计算连续长度
        int c1 = 0;
        while (i<nums.length && nums[i] == maxAnd) { // 最大AND值连续出现
            c1++;
            i++;
        }
        maxCount = Math.max(maxCount, c1); // 更新最大连续长度
        i--;
    }
    return maxCount;
}
```
# 2749. Minimum operations to Make the Integer Zero(中等)
You are given two integers num1 and num2.

In one operation, you can choose integer i in the range [0, 60] and subtract 2i + num2 from num1.

Return the integer denoting the minimum number of operations needed to make num1 equal to 0.

If it is impossible to make num1 equal to 0, return -1.

* **约束**
  * `1 <= num1 <= 10^9`
  * `-10^9 <= num2 <= 10^9`
```java
public int makeTheIntegerZero(int num1, int num2) {
    int k = 1;
    while (true) {
        long x = num1 - (long) num2 * k;
        if (x < k) return -1;
        if (k >= Long.bitCount(x)) return k;
        k++;
    }
}
```
# 2785. Sort Vowels in a String(中等)
Given a **0-indexed** string `s`, **permute** `s` to get a new string `t` such that:

* All consonants remain in their original places. More formally, if there is an index `i` with `0 <= i < s.length` such that `s[i]` is a consonant, then `t[i] = s[i]`.
* The vowels must be sorted in the nondecreasing order of their ASCII values. More formally, for pairs of indices `i, j` with `0 <= i < j < s.length` such that `s[i]` and `s[j]` are vowels, then `t[i]` must not have a higher ASCII value than `t[j]`.
Return the resulting string.

The vowels are `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`, and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.

* **约束**
  * `1 <= s.length <= 10^5`
  * `s` consists only of letters of the English alphabet in **uppercase and lowercase**.
```java
public String sortVowels(String s) {
    char[] vowels = {'A','E','I','O','U','a','e','i','o','u'};
    int[] stringCharCount = new int[128];
    char[] sChars = s.toCharArray();
    for(char ch : sChars) stringCharCount[ch]++;
    boolean found = false;
    for(char ch : vowels) found |= stringCharCount[ch]>0;
    if(!found) return s;
    
    boolean[] isVowels = new boolean[128];
    for(char ch : vowels) if(stringCharCount[ch]>0) isVowels[ch] = true;
    int left = 0;
    for(char v : vowels){
        while(stringCharCount[v]>0){
            char ch = sChars[left];
            stringCharCount[v] -= isVowels[ch]?1:0; 
            sChars[left] = isVowels[ch]?v:ch; 
            left++;
        }
    }
    return new String(sChars);
}
```

# 2787. Ways to Express an Integer as Sum of Powers(中等)
Given two positive integers `n` and `x`.

Return the number of ways `n` can be expressed as the sum of the xth power of unique positive integers, in other words, the number of sets of unique integers $[n_1, n_2, ..., n_k]$ where $n = n_1^x + n_2^x + ... + n_k^x$.

Since the result can be very large, return it modulo $10^9 + 7$.

For example, if `n = 160` and `x = 3`, one way to express n is $n = 2^3 + 3^3 + 5^3$.

* **约束**
  * `1 <= n <= 10^9`
  * `2 <= x <= 9`
* **思路**：
  * 定义最大值，最大值取n的x次方
```java
public int numberOfWays(int n, int x) {
    long[] dp = new long[n+1];
    dp[0] = 1;
    for (int i = 1,num; (num = (int)Math.pow(i,x)) <= n; i++) {
        for (int s = n; s >= num; s--) dp[s] += dp[s - num];
    }
    return (int) (dp[n] % 1_000_000_007);
}
```
# 3000. Maximum Area of Longest Diagonal Rectangle(简单)
You are given a 2D 0-indexed integer array dimensions.

For all indices i, 0 <= i < dimensions.length, dimensions[i][0] represents the length and dimensions[i][1] represents the width of the rectangle i.

Return the area of the rectangle having the longest diagonal. If there are multiple rectangles with the longest diagonal, return the area of the rectangle having the maximum area.

* **约束**
  * `1 <= dimensions.length <= 100`
  * `dimensions.length == 2`
  * `1 <= dimensions[i][0], dimensions[i][1] <= 100`
* **思路**：
  * 计算各自积和，比最大值
  * 取最大值
  * 若最大值相等，取乘积最大值
  * **建议**：不需要对结果sqrt，只要自积和越大，则sqrt结果越大
```java
public int areaOfMaxDiagonal(int[][] dimensions) {
    int max = 0,res=0;
    for (int[] dimension : dimensions) {
        int l = dimension[0],w = dimension[1];
        int tmp = l*l+w*w;
        if ((tmp > max)||(tmp==max && l*w > res)){ // 注意最大值相等时，取最大乘积
            max = tmp;
            res = l*w;
        }
    }
    return res;
}
```
# 3021. Alice and Bob Playing Flower Games(中等)
Alice and Bob are playing a turn-based game on a field, with two lanes of flowers between them. There are x flowers in the first lane between Alice and Bob, and y flowers in the second lane between them.

The game proceeds as follows:
* Alice takes the first turn.
* In each turn, a player must choose either one of the lane and pick one flower from that side.
* At the end of the turn, if there are no flowers left at all, the current player captures their opponent and wins the game.

Given two integers, n and m, the task is to compute the number of possible pairs (x, y) that satisfy the conditions:
* Alice must win the game according to the described rules.
* The number of flowers x in the first lane must be in the range [1,n].
* The number of flowers y in the second lane must be in the range [1,m].

Return the number of possible pairs (x, y) that satisfy the conditions mentioned in the statement.

* **约束**
  * `1 <= n, m <= 10^5`
* **思路**：
```java
public long flowerGame(int n, int m) {
    return ((long) m * n) / 2;
}
```
# 3025. Find the Number of Ways to Place People I(中等)
You are given a 2D array points of size `n x 2` representing integer coordinates of some points on a 2D plane, where `points[i] = [xi, yi]`.

Count the number of pairs of points `(A, B)`, where
* `A` is on the upper left side of `B`, and
* there are no other points in the rectangle (or line) they make (including the border).

Return the count.

* **约束**
  * `2 <= n <= 50`
  * `points[i].length == 2`
  * `0 <= points[i][0], points[i][1] <= 50`
  * All `points[i]` are distinct.
```java
public int numberOfPairs(int[][] points) {
    Arrays.sort(points, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);
    int cnt = 0;
    for (int i = 0; i < points.length; i++) {
        int x0 = points[i][0], y0 = points[i][1];
        int bot = Integer.MIN_VALUE, top = y0;
        for (int j = i + 1; j < points.length; j++) {
            int x1 = points[j][0], y1 = points[j][1];
            if (y1 <= top && y1 > bot) {
                cnt++; // found a valid rectangular.
                bot = y1;
                if (y1 == top) top--;// to avoid points on the same y value;
            }
        }
    }
    return cnt;
}
```
# 3027. Find the Number of Ways to Place People II(困难)
You are given a 2D array `points` of size `n x 2` representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`.

We define the **right** direction as positive x-axis (**increasing x-coordinate**) and the **left** direction as negative x-axis (**decreasing x-coordinate**). Similarly, we define the **up** direction as positive y-axis (**increasing y-coordinate**) and the down direction as negative y-axis (**decreasing y-coordinate**)

You have to place n people, including Alice and Bob, at these points such that there is **exactly one** person at every point. Alice wants to be alone with Bob, so Alice will build a rectangular fence with Alice's position as the **upper left corner** and Bob's position as the **lower right corner** of the fence (**Note** that the fence **might not** enclose any area, i.e. it can be a line). If any person other than Alice and Bob is either **inside** the fence or **on** the fence, Alice will be sad.

Note that Alice can only build a fence with Alice's position as the upper left corner, and Bob's position as the lower right corner. For example, Alice cannot build either of the fences in the picture below with four corners `(1, 1)`, `(1, 3)`, `(3, 1)`, and `(3, 3)`, because:
* With Alice at `(3, 3)` and Bob at `(1, 1)`, Alice's position is not the upper left corner and Bob's position is not the lower right corner of the fence.
* With Alice at `(1, 3)` and Bob at `(1, 1)`, Bob's position is not the lower right corner of the fence.

Return the number of **pairs of points** where you can place Alice and Bob, such that Alice **does not** become sad on building the fence.

* **约束**：
  * `2 <= n <= 1000`
  * `points[i].length == 2`
  * `-10^9 <= points[i][0], points[i][1] <= 10^9`
  * All `points[i]` are distinct.
```java
public int numberOfPairs(int[][] points) {
    // Sort by x ascending, then y descending
    Arrays.sort(points, new Comparator<int[]>() {
        public int compare(int[] a, int[] b) {
            if (a[0] != b[0]) return a[0] - b[0]; // sort by x
            return b[1] - a[1]; // if x same, y descending
        }
    });

    int n = points.length, ans = 0;
    for (int i = 0; i < n; i++) {
        int top = points[i][1], bottom = Integer.MIN_VALUE;
        for (int j = i + 1; j < n; j++) {
            if (points[j][1] <= top && points[j][1] > bottom) {
                bottom = points[j][1];
                ans++;
            }
            if (bottom == top)
                break;
        }
    }
    return ans;
}
```
# 3195. Find the Minimum Area to Cover All Ones I(中等)
You are given a 2D **binary** array `grid`. Find a rectangle with horizontal and vertical sides with the **smallest** area, such that all the 1's in `grid` lie inside this rectangle.

Return the **minimum** possible area of the rectangle.

* **约束**
  * `1 <= grid.length, grid[i].length <= 1000`
  * `grid[i][j]`is either 0 or 1
  * The input is generated such that there is at least one 1 in grid
* **思路**：
  * 寻找最小上边界和左边界
  * 寻找最大下边界和右边界
* **优化**
  * 从不同方向遍历，直接寻找对应边界，避免边界内部遍历
```java
public static int minimumArea(int[][] grid) {
    int n = grid.length, m = grid[0].length;
    int left =-1,right=-1,top=-1,bottom=-1;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if(grid[i][j] == 1){
                top = top == -1? i:Math.min(top, i);
                bottom = Math.max(bottom, i);
                left = left==-1 ? j: Math.min(left, j);
                right = Math.max(right, j);
            }
        }
    }
    return (right-left+1)*(bottom-top+1);
}
// 优化：从不同方向确定边界
public static int minimumArea(int[][] grid) {
    int n = grid.length, m = grid[0].length;
    int left =-1,right=-1,top=-1,bottom=-1;
    A:for (int i = 0; i < n; i++) { // 寻找上边界
        for (int j = 0; j < m; j++) {
            if(grid[i][j] == 1){
                top = i;
                break A;
            }
        }
    }
    A:for (int i = 0; i < m; i++) { // 寻找左边界
        for (int j = 0; j < n; j++) {
            if(grid[j][i] == 1){
                left = i;
                break A;
            }
        }
    }
    A:for (int i = n-1; i >=0; i--) { // 寻找下边界
        for (int j = m-1; j >=0; j--) {
            if(grid[i][j] == 1){
                bottom = i;
                break A;
            }
        }
    }
    A:for (int i = m-1; i >=0; i--) { // 寻找右边界
        for (int j = n-1; j >=0; j--) {
            if(grid[j][i] == 1){
                right = i;
                break A;
            }
        }
    }
    return (right-left+1)*(bottom-top+1);
}
```
# 3197. Find the Minimum Area to Cover All Ones II(困难)
You are given a 2D **binary** array `grid`. Find a rectangle with horizontal and vertical sides with the **smallest** area, such that all the 1's in `grid` lie inside this rectangle.

Return the **minimum** possible area of the rectangle.

* **约束**
  * `1 <= grid.length, grid[i].length <= 1000`
  * `grid[i][j]`is either 0 or 1
  * The input is generated such that there is at least one 1 in grid
* **思路**：
```java
public int minimumSum(int[][] grid) {
    return Math.min(f(grid), f(rotate(grid)));
}
private int f(int[][] a) {
    int m = a.length,n = a[0].length;
    int[][] lr = new int[m][2]; // 每一行最左最右 1 的列号
    for (int i = 0; i < m; i++) {
        int l = -1,r = 0;
        for (int j = 0; j < n; j++) {
            if (a[i][j] > 0) {
                if (l < 0) l = j;
                r = j;
            }
        }
        lr[i][0] = l;
        lr[i][1] = r;
    }

    // lt[i+1][j+1] = 包含【左上角为 (0,0) 右下角为 (i,j) 的子矩形】中的所有 1 的最小矩形面积
    int[][] lt = minimumArea(a);
    a = rotate(a);
    // lb[i][j+1] = 包含【左下角为 (m-1,0) 右上角为 (i,j) 的子矩形】中的所有 1 的最小矩形面积
    int[][] lb = rotate(rotate(rotate(minimumArea(a))));
    a = rotate(a);
    // rb[i][j] = 包含【右下角为 (m-1,n-1) 左上角为 (i,j) 的子矩形】中的所有 1 的最小矩形面积
    int[][] rb = rotate(rotate(minimumArea(a)));
    a = rotate(a);
    // rt[i+1][j] = 包含【右上角为 (0,n-1) 左下角为 (i,j) 的子矩形】中的所有 1 的最小矩形面积
    int[][] rt = rotate(minimumArea(a))
    int ans = Integer.MAX_VALUE;
    if (m >= 3) {
        for (int i = 1; i < m; i++) {
            int left = n,right = 0,top = m,bottom = 0;
            for (int j = i + 1; j < m; j++) {
                int l = lr[j - 1][0];
                if (l >= 0) {
                    left = Math.min(left, l);
                    right = Math.max(right, lr[j - 1][1]);
                    top = Math.min(top, j - 1);
                    bottom = j - 1;
                }
                ans = Math.min(ans, lt[i][n] + (right - left + 1) * (bottom - top + 1) + lb[j][n]);// 图片上左
            }
        }
    }
    if (m >= 2 && n >= 2) {
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                ans = Math.min(ans, lt[i][n] + lb[i][j] + rb[i][j]);// 图片上中
                ans = Math.min(ans, lt[i][j] + rt[i][j] + lb[i][n]);// 图片上右
            }
        }
    }
    return ans;
}
private int[][] minimumArea(int[][] a) {
    int m = a.length,n = a[0].length;
    // f[i+1][j+1] 表示包含【左上角为 (0,0) 右下角为 (i,j) 的子矩形】中的所有 1 的最小矩形面积
    int[][] f = new int[m + 1][n + 1];
    int[][] border = new int[n][3];
    for (int j = 0; j < n; j++) {
        border[j][0] = -1;
    }
    for (int i = 0; i < m; i++) {
        int left = -1,right = 0;
        for (int j = 0; j < n; j++) {
            if (a[i][j] == 1) {
                if (left < 0) left = j;
                right = j;
            }
            int[] preB = border[j];
            if (left < 0) { // 这一排目前全是 0
                f[i + 1][j + 1] = f[i][j + 1]; // 等于上面的结果
            } else if (preB[0] < 0) { // 这一排有 1，上面全是 0
                f[i + 1][j + 1] = right - left + 1;
                border[j][0] = i;
                border[j][1] = left;
                border[j][2] = right;
            } else { // 这一排有 1，上面也有 1
                int l = Math.min(preB[1], left);
                int r = Math.max(preB[2], right);
                f[i + 1][j + 1] = (r - l + 1) * (i - preB[0] + 1);
                border[j][1] = l;
                border[j][2] = r;
            }
        }
    }
    return f;
}
// 顺时针旋转矩阵 90°
private int[][] rotate(int[][] a) {
    int m = a.length;
    int n = a[0].length;
    int[][] b = new int[n][m];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            b[j][m - 1 - i] = a[i][j];
        }
    }
    return b;
}
```
# 3227. Vowels Game in a String(中等)
Alice and Bob are playing a game on a string.

You are given a string s, Alice and Bob will take turns playing the following game where Alice starts **first**:
* On Alice's turn, she has to remove any **non-empty** substring from s that contains an **odd** number of vowels.
* On Bob's turn, he has to remove any **non-empty** substring from s that contains an **even** number of vowels.

The first player who cannot make a move on their turn loses the game. We assume that both Alice and Bob play **optimally**.

Return `true` if Alice wins the game, and `false` otherwise.

The English vowels are: `a`, `e`, `i`, `o`, and `u`.

* **约束**
  * `1 <= s.length <= 10^5`
  * `s` consists only of lowercase English letters.
```java
public boolean doesAliceWin(String s) {
    for (int i = 0; i < s.length(); i++) {
        switch (s.charAt(i)) {
            case 'a','e','i','o','u':return true;
        }
    }
    return false;
}
```
# 3330. Find the Original Typed String I(简单)
Alice is attempting to type a specific string on her computer. However, she tends to be clumsy and **may** press a key for too long, resulting in a character being typed **multiple** times.

Although Alice tried to focus on her typing, she is aware that she may still have done this **at most** once.

You are given a string word, which represents the **final** output displayed on Alice's screen.

Return the total number of possible original strings that Alice might have intended to type.

* **约束**
  * `1 <= word.length <= 100`
  * `word` consists of lowercase English letters.
* **思路**：
  * 增加辅助变量前值
  * 循环word
    * 判断当前字符是否与下一个字符相同，相同则计数+1
    * 否则，将前值赋值当前值
* **优化**
  * 在循环中，建立内循环过滤相等值
```java
public int possibleStringCount(String word) {
    int count = 1;char pre = word.charAt(0);
    for (int i = 1; i < word.length(); i++) {
        if (word.charAt(i) != pre)  pre = word.charAt(i);
        else count++;
    }
    return count;
}
// 优化
public int possibleStringCount(String word) {
    int count = 1,n = word.length();
    for (int i = 0; i < n; i++) {
        int start = i;
        while(i+1<n && word.charAt(i+1) == word.charAt(start)) i++;
        count += i-start;
    }
    return count;
}
```
# 3363. Find the Maximum Number of Fruits Collected(困难)
There is a game dungeon comprised of `n x n` rooms arranged in a grid.

You are given a 2D array fruits of size `n x n`, where `fruits[i][j]` represents the number of fruits in the room `(i, j)`. Three children will play in the game dungeon, with **initial** positions at the corner rooms `(0, 0)`, `(0, n - 1)`, and `(n - 1, 0)`.

The children will make **exactly** `n - 1` moves according to the following rules to reach the room `(n - 1, n - 1)`:

The child starting from `(0, 0) must move from their current room `(i, j)` to one of the rooms `(i + 1, j + 1)`, `(i + 1, j)`, and `(i, j + 1)` if the target room exists.
The child starting from (0, n - 1) must move from their current room `(i, j)` to one of the rooms `(i + 1, j - 1)`, `(i + 1, j)`, and (i + 1, j + 1) if the target room exists.
The child starting from `(n - 1, 0)` must move from their current room `(i, j)` to one of the rooms `(i - 1, j + 1)`, `(i, j + 1)`, and `(i + 1, j + 1)` if the target room exists.
When a child enters a room, they will collect all the fruits there. If two or more children enter the same room, only one child will collect the fruits, and the room will be emptied after they leave.

Return the **maximum** number of fruits the children can collect from the dungeon.

* **约束**
  * `2 <= n == fruits.length == fruits[i].length <= 1000`
  * `0 <= fruits[i][j] <= 1000`
* **思路**
  * 一个小孩直沿着对角线走
  * 另外两个小孩分别将`当前值+=周边最大值`
    * 不能过界`i+j<n-1`，即不能超过对角线
  * **重点**：由于要求每个孩子只能走`n-1`次到达终点，
    * 所以不会有重复或回头走的情况
    * 孩子只能向终点方向前进，不能反方向行进
    * `(0,0)`起点的孩子只能对角线行进
```java
public int maxCollectedFruits(int[][] fruits) {
    int n = fruits.length;
    for(int i = 1; i < n; i++) {
        fruits[i][i] += fruits[i-1][i-1]; // 对角
        for(int j = i+1; j < n; j++) {
            if(i+j < n-1) continue;
            fruits[i][j] += Math.max(
                j == n-1 ? 0 : fruits[i-1][j+1], 
                i + j == n-1 ? 0 : Math.max(fruits[i-1][j], 
                    j == 0 || i + j <= n ? 0 : fruits[i-1][j-1]));
            fruits[j][i] += Math.max(j == n-1 ? 0 : fruits[j+1][i-1], 
                i + j == n-1 ?0 : Math.max(fruits[j][i-1], 
                    j == 0 || i + j <= n ? 0 : fruits[j-1][i-1]));
        }
    }
    return fruits[n-1][n-2] + fruits[n-2][n-1] + fruits[n-1][n-1];
}
```
# 3446. Sort Matrix by Diagonals(中等)
You are given an `n x n` square matrix of integers `grid`. Return the matrix such that:
* The diagonals in the **bottom-left triangle** (including the middle diagonal) are sorted in **non-increasing order**.
* The diagonals in the **top-right triangle** are sorted in **non-decreasing order**.

* **约束**
  * `grid.length == grid[i].length == n`
  * `1 <= n <= 10`
  * `-10^5 <= grid[i][j] <= 10^5`
```java
public int[][] sortMatrix(int[][] grid) {
    int n = grid.length;
    for (int i = 0; i < n; i++) {
        List<Integer> tmp = new ArrayList<>();
        for (int j = 0; i + j < n; j++) tmp.add(grid[i + j][j]);
        tmp.sort(Collections.reverseOrder());
        for (int j = 0; i + j < n; j++) grid[i + j][j] = tmp.get(j);
    }
    for (int j = 1; j < n; j++) {
        List<Integer> tmp = new ArrayList<>();
        for (int i = 0; j + i < n; i++) tmp.add(grid[i][j + i]);
        Collections.sort(tmp);
        for (int i = 0; j + i < n; i++) grid[i][j + i] = tmp.get(i);
    }
    return grid;
}

public int[][] sortMatrix(int[][] mat) {
    int rows = mat.length,cols = mat[0].length;
    for (int row = 0; row < rows; row++) sortDiagonal(mat, row, 0, false); // false for non-increasing
    for (int col = 1; col < cols; col++) sortDiagonal(mat, 0, col, true); // true for non-decreasing
    return mat;
}
private void sortDiagonal(int[][] mat, int row, int col, boolean increasing) {
    int rows = mat.length,cols = mat[0].length;
    int len = Math.min(rows - row, cols - col);
    int[] diagonal = new int[len];
    for (int i = 0; i < len; i++) diagonal[i] = mat[row + i][col + i];
    Arrays.sort(diagonal);
    if (!increasing) reverse(diagonal);
    for (int i = 0; i < len; i++) mat[row + i][col + i] = diagonal[i];
}
private void reverse(int[] arr) {
    int i = 0, j = arr.length - 1;
    while (i < j) {
        int temp = arr[i];
        arr[i] = arr[j];arr[j] = temp;
        i++;j--;
    }
}
```
# 3459. Length of Longest V-Shaped Diagonal Segment(困难)
You are given a 2D integer matrix grid of size n x m, where each element is either 0, 1, or 2.

A V-shaped diagonal segment is defined as:
* The segment starts with 1.
* The subsequent elements follow this infinite sequence: 2, 0, 2, 0, ....
* The segment:
  * Starts along a diagonal direction (top-left to bottom-right, bottom-right to top-left, top-right to bottom-left, or bottom-left to top-right).
  * Continues the sequence in the same diagonal direction.
  * Makes at most one clockwise 90-degree turn to another diagonal direction while maintaining the sequence.

Return the length of the longest V-shaped diagonal segment. If no valid segment exists, return 0.

* **约束**
* `n == grid.length`
* `m == grid[i].length`
* `1 <= n, m <= 500`
* `grid[i][j]` is either `0`, `1` or `2`.
```java
private static final int[][] DIRS = { { 1, 1 }, { 1, -1 }, { -1, -1 }, { -1, 1 } };
public int lenOfVDiagonal(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    // 开太多维度影响效率，这里把 k 和 canTurn 压缩成一个 int
    int[][][] memo = new int[m][n][1 << 3];
    int ans = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] != 1) {
                continue;
            }
            int[] maxs = { m - i, j + 1, i + 1, n - j }; // 理论最大值（走到底）
            for (int k = 0; k < 4; k++) { // 枚举起始方向
                if (maxs[k] > ans) { // 优化一：如果理论最大值没有超过 ans，那么不递归
                    ans = Math.max(ans, dfs(i, j, k, 1, 2, grid, memo) + 1);
                }
            }
        }
    }
    return ans;
}
private int dfs(int i, int j, int k, int canTurn, int target, int[][] grid, int[][][] memo) {
    i += DIRS[k][0];
    j += DIRS[k][1];
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] != target) {
        return 0;
    }
    int mask = k << 1 | canTurn;
    if (memo[i][j][mask] > 0) {
        return memo[i][j][mask];
    }
    int res = dfs(i, j, k, canTurn, 2 - target, grid, memo);
    if (canTurn == 1) {
        int[] maxs = { grid.length - i - 1, j, i, grid[i].length - j - 1 }; // 理论最大值（走到底）
        k = (k + 1) % 4;
        // 优化二：如果理论最大值没有超过 res，那么不递归
        if (maxs[k] > res) {
            res = Math.max(res, dfs(i, j, k, 0, 2 - target, grid, memo));
        }
    }
    return memo[i][j][mask] = res + 1;
}
```
# 3477. Fruits into Baskets II(简单)
You are given an integer array `fruits` where `fruits[i]` represents the type of fruit the `i`-th basket of fruits has.
You can choose any two types of fruits and swap them with each other. Afterward, the cost of swapping is equal to the product of the number of baskets of the first type and the number of baskets of the second type.

Return the minimum cost of swapping required to make the number of each type of fruit **equal**.

If it is impossible to make the number of each type of fruit equal, return `-1`.

* **约束**
  * `2 <= fruits.length <= 10^5`
  * `1 <= fruits[i] <= 10^9`
* **思路**：[参考904题](#904-fruit-into-baskets中等)
  * **先计算能可以装下数，然后由水果数量减去装下的即未装下的数量**
```java
public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
    int count = 0;
    for (int i = 0; i < fruits.length; i++) {
        for (int j = 0; j < baskets.length; j++) {
            if (fruits[i]<=baskets[j]) {
                count++;
                baskets[j]=0;
                break;
            }
        }
    }
    return fruits.length-count;
}
// 改进版
```
# 3479. Fruits into Baskets III(简单)
等同于[3477题](#3477-fruit-into-baskets-ii简单)，只不过大小和数字有所增加

* **约束**
  * `n == fruits.length==baskets.length`
  * `1 <= n <= 10^5`
  * `1 <= fruits[i], baskets[i] <= 10^9`
* **思路**：[参考3477题](#3477-fruits-into-baskets-ii简单)
  * 由于数据量增加，并且时间复杂度为O(n^2)，会超时
* **改进**：**转堆处理**，时间复杂度`O(n log n)`
  * 初始化线段树
    * 确定线段树大小N(大于等于篮子数量最小2的幂)
    * 并构建最大线段树
    * 内部节点存储子节点的最大值
  * 处理每个水果
    * 对于每个水果，从线段树根节点开始查找
    * 如果根节点最大值小于水果大小，说明没有合适篮子，计数增加
    * 否则，沿着线段树向下查找第一个合适的篮子（左子树优先）
    * 找到后将该篮子标记为已使用（设为-1），并更新线段树
  * 动画逻辑示例: `fruits = [4, 2, 5, 6], baskets = [5, 3, 7, 2]`
```txt
初始化线段树：N=4 (最小2的幂≥篮子数量4)
       7(1-4)
     /      \
   5(1-2)   7(3-4)
   /   \    /   \
5(1) 3(2) 7(3) 2(4)

处理水果4：
      7(1-4)
    /      \
  3(1-2)   7(3-4)
  /   \    /   \
-1(1) 3(2) 7(3) 2(4)

处理水果2：
      7(1-4)
    /      \
  -1(1-2)   7(3-4)
  /   \     /   \
-1(1) -1(2) 7(3) 2(4)

处理水果5：
      2(1-4)
    /      \
  -1(1-2)   2(3-4)
  /   \     /   \
-1(1) -1(2) -1(3) 2(4)

处理水果6：根节点2 < 6，无法放置，计数增加
```
```java
public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
    int n = baskets.length,N = 1;
    while(N <= n) N <<= 1;
    // Build the segment tree
    int[] segTree = new int[N << 1];
    for (int i = 0; i < n; i++) 
        segTree[N + i] = baskets[i];
    for (int i = N - 1; i > 0; i--) 
        segTree[i] = Math.max(segTree[2 * i], segTree[2 * i + 1]);
    int count = 0;
    for (int i = 0; i < n; ++i) {
        int x = fruits[i];
        int index = 1; // Start from the root of the segment tree
        if (segTree[index] < x) {
            count++;
            continue;
        }
        // Query the first valid basket
        while (index < N) {
            index *= 2;
            if (segTree[index] < x)  index += 1;
        }
        // Mark the found basket as used and update the segment tree
        segTree[index] = -1;
        while (index > 1) {
            index >>= 1;
            segTree[index] = Math.max(segTree[2 * index], segTree[2 * index + 1]);
        }
    }
    return count;     
}
```
# 3487. Maximum Unique Subarray Sum After Deletion(简单)
You are given an integer array `nums`.

You are allowed to delete any number of elements from `nums` without making it **empty**. After performing the deletions, select a subarray of `nums` such that:

All elements in the subarray are **unique**.
The sum of the elements in the subarray is **maximized**.
Return the **maximum sum** of such a subarray.

* **约束**
  * `1 <= nums.length <= 10^5`
  * `1 <= nums[i] <= 10^9`
* **思路**：
  * 使用辅助结构Set去重
  * 循环nums
    * 判断set中是否存在，存在则过滤，否则继续
    * 若>=0,判断sum是否小于0，小于0则赋值，否则相加
    * 若<0，继续判断sum是否小于0，小于0则取最大值
  * 提示：是对唯一元素进行求和
* **改进**
  * 对数组先排序
  * 从最大值从右向左遍历
    * 若`nums[i]`小于0，则直接退出
    * 若未重复，则求和
```java
public int maxSum(int[] nums) {
    int n = nums.length,max = -101;
    Set<Integer> set = new HashSet<>();
    for (int i = 0; i < n; i++) {
        int tmp = nums[i];
        if(set.contains(tmp)) continue;
        if(tmp>=0) { // 若不小于0，则附加
            if(max <0) max = tmp; // 若max小于0，则更新
            else max+=tmp; // 若max不小于0，则附加
        }
        else if(max<0) max = Math.max(max, tmp); // 若都小于0，取最大值
        set.add(tmp);
    }
    return max;
}
// 改进版
public int maxSum(int[] nums) {
    Arrays.sort(nums);
    int pre=nums[nums.length-1],sum = pre;
    for (int i = nums.length-2; i >= 0; i--) {
        int tmp = nums[i];
        if (tmp<=0) return sum;
        else if(tmp!=pre) sum += tmp;
        pre = tmp;
    }
    return sum;
}
```
# 3495. Minimum Operations to Make Array Elements zero(困难)
You are given a 2D array `queries`, where `queries[i]` is of the form `[l, r]`. Each `queries[i]` defines an array of integers `nums` consisting of elements ranging from `l` to `r`, both **inclusive**.

In one operation, you can:
* Select two integers a and b from the array.
* Replace them with `floor(a / 4)` and `floor(b / 4)`.

Your task is to determine the **minimum** number of operations required to reduce all elements of the array to zero for each query. Return the sum of the results for all queries.

* **约束**
  * `1 <= queries.length <= 10^5`
  * `queries[i].length == 2`
  * `queries[i] == [l, r]`
  * `1 <= l <= r <= 10^9`
* **思路**：
```java
public long minOperations(int[][] queries) {
    long res = 0;
    for (int[] q : queries) {
        long count1 = get(q[1]),count2 = get(q[0] - 1);
        res += (count1 - count2 + 1) / 2;
    }
    return res;
}
private long get(int num) {
    long cnt = 0;
    int i = 1,base = 1;
    while (base <= num) {
        int end = Math.min(base * 2 - 1, num);
        cnt += (long) ((i + 1) / 2) * (end - base + 1);
        i++;
        base *= 2;
    }
    return cnt;
}
// 改进
public long minOperations(int[][] queries) {
    long res = 0;
    for (int[] query: queries) res += minOperations(query);
    return res;
}
private long minOperations(int[] query) {
    long res0 = 0，x = 1;
    while (x < query[0]) {
        res0 ++;
        x *= 4;
    }
    long res1 = res0，res = 0，prev = query[0];
    while (x <= query[1] * 4L) {
        res += res1 * (Math.min(x, query[1] + 1) - prev);
        prev = x;
        res1 ++;
        x *= 4;
    }
    return (res + 1) / 2;
}
```
# 3516. Find Closest Person(简单)
You are given three integers `x`, `y`, and `z`, representing the positions of three people on a number line:
* `x` is the position of Person 1.
* `y` is the position of Person 2.
* `z` is the position of Person 3, who does **not** move.
* Both Person 1 and Person 2 move toward Person 3 at the **same** speed.

Determine which person reaches Person 3 **first**:
* Return 1 if Person 1 arrives first.
* Return 2 if Person 2 arrives first.
* Return 0 if both arrive at the **same** time.

Return the result accordingly.
* **约束**
  * `1 <= x, y, z <= 100`
* **思路**： 绝对值比较
```java
public int findClosest(int x, int y, int z) {
    int tx = Math.abs(z-x),ty = Math.abs(z-y);
    if(tx<ty) return 1;
    if(tx>ty) return 2;
    return 0;
}
```
# 3541. Find Most Frequency Vowel and Consonant(简单)
You are given a string s consisting of lowercase English letters (`'a'` to `'z'`).

Your task is to:
* Find the vowel (one of `'a'`, `'e'`, `'i'`, `'o'`, or `'u'`) with the **maximum** frequency.
* Find the consonant (all other letters excluding vowels) with the **maximum** frequency.

Return the sum of the two frequencies.

**Note**: If multiple vowels or consonants have the same maximum frequency, you may choose any one of them. If there are no vowels or no consonants in the string, consider their frequency as 0.

The **frequency** of a letter x is the number of times it occurs in the string.

* **约束**
  * `1 <= s.length <= 100`
  * `s` consists of lowercase English letters only.
```java
public int maxFreqSum(String s) {
    s=s.toLowerCase();
    int arr[]=new int[26];
    for(int i=0;i<s.length();i++){
        char c = s.charAt(i);
        arr[c-'a']++;
    }
    int vmax=0,cmax=0;
    for(int i=0;i<arr.length;i++){
        if((i==0||i==4||i==8||i==14||i==20)&&arr[i]>vmax) vmax=arr[i];
        else if((i!=0&&i!=4&&i!=8&&i!=14&&i!=20)&&arr[i]>cmax) cmax=arr[i];
    }
    return vmax+cmax;
}
```
